# INT-031: Asset Binary Format

## Type

Internal

## Parties

- **Provider:** External
- **Consumer:** UNIT-034 (Build.rs Orchestrator)

## Referenced By

- REQ-200 (Unknown)
- REQ-201 (Unknown)

## Specification


**Feature**: 003-asset-data-prep
**Date**: 2026-01-31
**Status**: Phase 1 Design Artifact

## Overview

This document specifies the exact format of all generated output files, including Rust wrapper files and binary data files. All formats are designed for direct inclusion in RP2350 firmware builds using the `include_bytes!()` macro.

**Primary output location**: Cargo's `OUT_DIR/assets/` (ephemeral, generated by build.rs at build time). The library also generates a master `mod.rs` that re-exports all asset modules.

## File Organization

### Output Directory Structure

Generated in `OUT_DIR/assets/` by build.rs:

```
$OUT_DIR/assets/
├── mod.rs                     # Master module file (re-exports all assets)
├── textures_player.rs         # Rust wrapper
├── textures_player.bin        # Binary RGBA8888 data
├── textures_enemy.rs
├── textures_enemy.bin
├── meshes_cube_patch0.rs      # Mesh patch 0
├── meshes_cube_patch0_pos.bin # Positions
├── meshes_cube_patch0_uv.bin  # UV coordinates
├── meshes_cube_patch0_norm.bin# Normals
├── meshes_cube_patch0_idx.bin # Indices
├── meshes_sphere_patch0.rs    # Multi-patch mesh
├── meshes_sphere_patch0_pos.bin
├── meshes_sphere_patch0_uv.bin
├── meshes_sphere_patch0_norm.bin
├── meshes_sphere_patch0_idx.bin
├── meshes_sphere_patch1.rs
├── meshes_sphere_patch1_pos.bin
└── ...
```

### Source Asset Directory

Committed to version control in `host_app/assets/`:

```
host_app/assets/
├── textures/
│   ├── player.png
│   └── enemy.png
└── meshes/
    ├── cube.obj
    └── sphere.obj
```

### Naming Conventions

#### Identifier Generation

**Algorithm**:
1. Extract parent directory name (immediate parent only)
2. Extract filename without extension
3. Combine: `{parent}_{filename}` (or just `{filename}` if no parent)
4. Sanitize: Replace non-alphanumeric characters with underscore
5. Convert to uppercase
6. Prefix with underscore if starts with digit

**Examples**:

| Input Path | Parent | Filename | Combined | Identifier |
|------------|--------|----------|----------|------------|
| `player.png` | - | `player` | `player` | `PLAYER` |
| `textures/player.png` | `textures` | `player` | `textures_player` | `TEXTURES_PLAYER` |
| `ui/button-hover.png` | `ui` | `button-hover` | `ui_button-hover` | `UI_BUTTON_HOVER` |
| `meshes/3d-cube.obj` | `meshes` | `3d-cube` | `meshes_3d-cube` | `MESHES_3D_CUBE` |
| `assets/textures/player.png` | `textures` | `player` | `textures_player` | `TEXTURES_PLAYER` |

**Note**: Only the immediate parent directory is used, not the full path. This prevents overly long identifiers while still avoiding most conflicts.

#### File Naming

**Textures**:
- Rust wrapper: `{identifier_lowercase}.rs`
- Binary data: `{identifier_lowercase}.bin`

**Meshes** (per patch):
- Rust wrapper: `{identifier_lowercase}_patch{n}.rs` (where n is 0-based)
- Position data: `{identifier_lowercase}_patch{n}_pos.bin`
- UV data: `{identifier_lowercase}_patch{n}_uv.bin`
- Normal data: `{identifier_lowercase}_patch{n}_norm.bin`
- Index data: `{identifier_lowercase}_patch{n}_idx.bin`

---

## Texture Output Format

### Rust Wrapper File (`.rs`)

**Template**:
```rust
// Generated from: {source_path}
// Dimensions: {width}×{height} RGBA8
// Size: {byte_count} bytes ({kb_size} KB)
// GPU Requirements: 4K-aligned base address

pub const {IDENTIFIER}_WIDTH: u32 = {width};
pub const {IDENTIFIER}_HEIGHT: u32 = {height};
pub const {IDENTIFIER}_DATA: &[u8] = include_bytes!("{bin_filename}");

// Usage in firmware:
// let texture = Texture::from_rgba8({IDENTIFIER}_WIDTH, {IDENTIFIER}_HEIGHT, {IDENTIFIER}_DATA);
```

**Field Descriptions**:
- `{source_path}`: Original PNG file path (e.g., `assets/textures/player.png`)
- `{width}`, `{height}`: Texture dimensions (u32, power-of-two, 8-1024)
- `{byte_count}`: Total bytes = width × height × 4
- `{kb_size}`: Size in KB, formatted to 1 decimal place
- `{IDENTIFIER}`: Uppercase identifier (e.g., `TEXTURES_PLAYER`)
- `{bin_filename}`: Relative path to binary file (e.g., `player.bin`)

**Example** (`player.rs`):
```rust
// Generated from: assets/textures/player.png
// Dimensions: 256×256 RGBA8
// Size: 262144 bytes (256.0 KB)
// GPU Requirements: 4K-aligned base address

pub const PLAYER_WIDTH: u32 = 256;
pub const PLAYER_HEIGHT: u32 = 256;
pub const PLAYER_DATA: &[u8] = include_bytes!("player.bin");

// Usage in firmware:
// let texture = Texture::from_rgba8(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_DATA);
```

### Binary Data File (`.bin`)

**Format**: Raw RGBA8888 pixel data

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0              | Pixel[0][0].R (u8)
1              | Pixel[0][0].G (u8)
2              | Pixel[0][0].B (u8)
3              | Pixel[0][0].A (u8)
4              | Pixel[0][1].R (u8)
5              | Pixel[0][1].G (u8)
...            | ...
width*4 - 4    | Pixel[0][width-1].R (u8)
width*4 - 3    | Pixel[0][width-1].G (u8)
width*4 - 2    | Pixel[0][width-1].B (u8)
width*4 - 1    | Pixel[0][width-1].A (u8)
width*4        | Pixel[1][0].R (u8)
...            | ...
Total          | width × height × 4 bytes
```

**Properties**:
- Byte order: N/A (single bytes)
- Row order: Top to bottom (row 0 is top of image)
- Pixel order: Left to right within each row
- Color channels: RGBA (red, green, blue, alpha)
- Channel range: 0-255 (u8)

**Size Examples**:
- 8×8: 256 bytes
- 16×16: 1,024 bytes (1 KB)
- 256×256: 262,144 bytes (256 KB)
- 1024×1024: 4,194,304 bytes (4 MB)

**Hex Dump Example** (4×4 texture, first 16 bytes):
```
00000000  ff 00 00 ff  00 ff 00 ff  00 00 ff ff  ff ff 00 ff  |................|
          └─Red px─┘  └─Green px┘  └─Blue px─┘  └─Yellow px┘
          R  G  B  A   R  G  B  A   R  G  B  A   R  G  B  A
```

---

## Mesh Output Format

### Rust Wrapper File (`.rs`)

**Template**:
```rust
// Generated from: {source_path} (patch {patch_index} of {total_patches})
// Vertices: {vertex_count}, Indices: {index_count} ({triangle_count} triangles)

pub const {IDENTIFIER}_PATCH{n}_VERTEX_COUNT: usize = {vertex_count};
pub const {IDENTIFIER}_PATCH{n}_INDEX_COUNT: usize = {index_count};

pub const {IDENTIFIER}_PATCH{n}_POSITIONS: &[u8] = include_bytes!("{base_name}_pos.bin");
pub const {IDENTIFIER}_PATCH{n}_UVS: &[u8] = include_bytes!("{base_name}_uv.bin");
pub const {IDENTIFIER}_PATCH{n}_NORMALS: &[u8] = include_bytes!("{base_name}_norm.bin");
pub const {IDENTIFIER}_PATCH{n}_INDICES: &[u8] = include_bytes!("{base_name}_idx.bin");

// Usage in firmware:
// let positions = bytemuck::cast_slice::<u8, f32>({IDENTIFIER}_PATCH{n}_POSITIONS);
// let uvs = bytemuck::cast_slice::<u8, f32>({IDENTIFIER}_PATCH{n}_UVS);
// let normals = bytemuck::cast_slice::<u8, f32>({IDENTIFIER}_PATCH{n}_NORMALS);
// let indices = bytemuck::cast_slice::<u8, u16>({IDENTIFIER}_PATCH{n}_INDICES);
```

**Field Descriptions**:
- `{source_path}`: Original OBJ file path
- `{patch_index}`: 0-based patch index
- `{total_patches}`: Total number of patches for this mesh
- `{vertex_count}`: Number of vertices in this patch (≤16 by default)
- `{index_count}`: Number of indices in this patch (≤32 by default)
- `{triangle_count}`: Number of triangles = index_count / 3
- `{IDENTIFIER}`: Uppercase identifier
- `{n}`: Patch index (0-based)
- `{base_name}`: Lowercase base name for binary files

**Example** (`cube_patch0.rs`):
```rust
// Generated from: assets/meshes/cube.obj (patch 0 of 1)
// Vertices: 24, Indices: 36 (12 triangles)

pub const CUBE_PATCH0_VERTEX_COUNT: usize = 24;
pub const CUBE_PATCH0_INDEX_COUNT: usize = 36;

pub const CUBE_PATCH0_POSITIONS: &[u8] = include_bytes!("cube_patch0_pos.bin");
pub const CUBE_PATCH0_UVS: &[u8] = include_bytes!("cube_patch0_uv.bin");
pub const CUBE_PATCH0_NORMALS: &[u8] = include_bytes!("cube_patch0_norm.bin");
pub const CUBE_PATCH0_INDICES: &[u8] = include_bytes!("cube_patch0_idx.bin");

// Usage in firmware:
// let positions = bytemuck::cast_slice::<u8, f32>(CUBE_PATCH0_POSITIONS);
// let uvs = bytemuck::cast_slice::<u8, f32>(CUBE_PATCH0_UVS);
// let normals = bytemuck::cast_slice::<u8, f32>(CUBE_PATCH0_NORMALS);
// let indices = bytemuck::cast_slice::<u8, u16>(CUBE_PATCH0_INDICES);
```

### Position Binary (`_pos.bin`)

**Format**: Raw f32 array, 3 components per vertex

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0-3            | Vertex[0].x (f32, little-endian)
4-7            | Vertex[0].y (f32, little-endian)
8-11           | Vertex[0].z (f32, little-endian)
12-15          | Vertex[1].x (f32, little-endian)
16-19          | Vertex[1].y (f32, little-endian)
20-23          | Vertex[1].z (f32, little-endian)
...            | ...
Total          | vertex_count × 3 × 4 bytes
```

**Properties**:
- Type: IEEE 754 single-precision float (f32)
- Byte order: Little-endian
- Components per vertex: 3 (x, y, z)
- Coordinate system: Model space (transformation by host software)

**Size Examples**:
- 1 vertex: 12 bytes
- 16 vertices (default max): 192 bytes

**Rust Conversion**:
```rust
let positions_bytes: &[u8] = include_bytes!("cube_patch0_pos.bin");
let positions: &[f32] = bytemuck::cast_slice(positions_bytes);
// positions = [x0, y0, z0, x1, y1, z1, ...]
```

### UV Binary (`_uv.bin`)

**Format**: Raw f32 array, 2 components per vertex

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0-3            | Vertex[0].u (f32, little-endian)
4-7            | Vertex[0].v (f32, little-endian)
8-11           | Vertex[1].u (f32, little-endian)
12-15          | Vertex[1].v (f32, little-endian)
...            | ...
Total          | vertex_count × 2 × 4 bytes
```

**Properties**:
- Type: IEEE 754 single-precision float (f32)
- Byte order: Little-endian
- Components per vertex: 2 (u, v)
- Typical range: 0.0 to 1.0 (but not enforced)
- Default if missing: [0.0, 0.0]

**Size Examples**:
- 1 vertex: 8 bytes
- 16 vertices (default max): 128 bytes

**Rust Conversion**:
```rust
let uvs_bytes: &[u8] = include_bytes!("cube_patch0_uv.bin");
let uvs: &[f32] = bytemuck::cast_slice(uvs_bytes);
// uvs = [u0, v0, u1, v1, ...]
```

### Normal Binary (`_norm.bin`)

**Format**: Raw f32 array, 3 components per vertex

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0-3            | Vertex[0].nx (f32, little-endian)
4-7            | Vertex[0].ny (f32, little-endian)
8-11           | Vertex[0].nz (f32, little-endian)
12-15          | Vertex[1].nx (f32, little-endian)
16-19          | Vertex[1].ny (f32, little-endian)
20-23          | Vertex[1].nz (f32, little-endian)
...            | ...
Total          | vertex_count × 3 × 4 bytes
```

**Properties**:
- Type: IEEE 754 single-precision float (f32)
- Byte order: Little-endian
- Components per vertex: 3 (nx, ny, nz)
- Not necessarily unit length (normalization by host software if needed)
- Default if missing: [0.0, 0.0, 0.0]

**Size Examples**:
- 1 vertex: 12 bytes
- 16 vertices (default max): 192 bytes

**Rust Conversion**:
```rust
let normals_bytes: &[u8] = include_bytes!("cube_patch0_norm.bin");
let normals: &[f32] = bytemuck::cast_slice(normals_bytes);
// normals = [nx0, ny0, nz0, nx1, ny1, nz1, ...]
```

### Index Binary (`_idx.bin`)

**Format**: Raw u16 array, triangle list

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0-1            | Triangle[0].i0 (u16, little-endian)
2-3            | Triangle[0].i1 (u16, little-endian)
4-5            | Triangle[0].i2 (u16, little-endian)
6-7            | Triangle[1].i0 (u16, little-endian)
8-9            | Triangle[1].i1 (u16, little-endian)
10-11          | Triangle[1].i2 (u16, little-endian)
...            | ...
Total          | index_count × 2 bytes
```

**Properties**:
- Type: Unsigned 16-bit integer (u16)
- Byte order: Little-endian
- Components per triangle: 3 indices
- Index range: 0 to (vertex_count - 1)
- Winding order: Preserved from OBJ file

**Size Examples**:
- 1 triangle: 6 bytes
- 10 triangles (30 indices): 60 bytes
- Max default (32 indices): 64 bytes

**Rust Conversion**:
```rust
let indices_bytes: &[u8] = include_bytes!("cube_patch0_idx.bin");
let indices: &[u16] = bytemuck::cast_slice(indices_bytes);
// indices = [i0, i1, i2, i3, i4, i5, ...] (groups of 3)
```

---

## Binary Encoding Details

### Little-Endian Byte Order

All multi-byte values use **little-endian** encoding (least significant byte first), which is the native byte order for RP2350 (ARM Cortex-M33).

**Example**: f32 value `1.0`
- IEEE 754 representation: `0x3F800000`
- Little-endian bytes: `00 80 3F 00`
- In file: `[0x00, 0x80, 0x3F, 0x00]`

**Example**: u16 value `42`
- Binary representation: `0x002A`
- Little-endian bytes: `2A 00`
- In file: `[0x2A, 0x00]`

### Rust Code Generation

**Generating f32 binary data**:
```rust
let positions: Vec<f32> = vec![1.0, 2.0, 3.0, 4.0];
let bytes: Vec<u8> = positions.iter()
    .flat_map(|&f| f.to_le_bytes())
    .collect();
std::fs::write("positions.bin", bytes)?;
```

**Generating u16 binary data**:
```rust
let indices: Vec<u16> = vec![0, 1, 2, 3, 4, 5];
let bytes: Vec<u8> = indices.iter()
    .flat_map(|&i| i.to_le_bytes())
    .collect();
std::fs::write("indices.bin", bytes)?;
```

---

## Firmware Integration

### Master Module File (mod.rs)

The library generates a master `mod.rs` in `OUT_DIR/assets/` that re-exports all generated asset modules. This is the single entry point for firmware code.

**Generated `$OUT_DIR/assets/mod.rs`**:
```rust
// Auto-generated by asset_build_tool - do not edit
// Source: host_app/assets/

// Textures
include!("textures_player.rs");
include!("textures_enemy.rs");

// Meshes
include!("meshes_cube_patch0.rs");
include!("meshes_sphere_patch0.rs");
include!("meshes_sphere_patch1.rs");
```

### Including in Firmware

```rust
// host_app/src/assets/mod.rs
include!(concat!(env!("OUT_DIR"), "/assets/mod.rs"));
```

This single `include!()` brings all generated asset constants into scope. No manual file management needed.

### Using Texture Data

```rust
use crate::assets::*;

// Constants are available directly from the included module
let texture = Texture {
    width: TEXTURES_PLAYER_WIDTH,
    height: TEXTURES_PLAYER_HEIGHT,
    data: TEXTURES_PLAYER_DATA,
};

// Upload to GPU (assumes GPU API)
gpu.upload_texture(0, &texture);
```

### Using Mesh Data

```rust
use crate::assets::*;

// Cast byte slices to typed arrays
let positions = bytemuck::cast_slice::<u8, f32>(MESHES_CUBE_PATCH0_POSITIONS);
let uvs = bytemuck::cast_slice::<u8, f32>(MESHES_CUBE_PATCH0_UVS);
let normals = bytemuck::cast_slice::<u8, f32>(MESHES_CUBE_PATCH0_NORMALS);
let indices = bytemuck::cast_slice::<u8, u16>(MESHES_CUBE_PATCH0_INDICES);

// Verify counts
assert_eq!(positions.len(), MESHES_CUBE_PATCH0_VERTEX_COUNT * 3);
assert_eq!(uvs.len(), MESHES_CUBE_PATCH0_VERTEX_COUNT * 2);
assert_eq!(normals.len(), MESHES_CUBE_PATCH0_VERTEX_COUNT * 3);
assert_eq!(indices.len(), MESHES_CUBE_PATCH0_INDEX_COUNT);

// Use in rendering
for i in (0..indices.len()).step_by(3) {
    let idx0 = indices[i] as usize;
    let idx1 = indices[i + 1] as usize;
    let idx2 = indices[i + 2] as usize;

    let v0 = [positions[idx0*3], positions[idx0*3+1], positions[idx0*3+2]];
    let v1 = [positions[idx1*3], positions[idx1*3+1], positions[idx1*3+2]];
    let v2 = [positions[idx2*3], positions[idx2*3+1], positions[idx2*3+2]];

    render_triangle(v0, v1, v2);
}
```

### Multi-Patch Meshes

```rust
// Render all patches of a mesh
const SPHERE_PATCHES: &[(&[u8], &[u8], &[u8], &[u8], usize)] = &[
    (MESHES_SPHERE_PATCH0_POSITIONS, MESHES_SPHERE_PATCH0_UVS, MESHES_SPHERE_PATCH0_NORMALS, MESHES_SPHERE_PATCH0_INDICES, MESHES_SPHERE_PATCH0_VERTEX_COUNT),
    (MESHES_SPHERE_PATCH1_POSITIONS, MESHES_SPHERE_PATCH1_UVS, MESHES_SPHERE_PATCH1_NORMALS, MESHES_SPHERE_PATCH1_INDICES, MESHES_SPHERE_PATCH1_VERTEX_COUNT),
    // ... more patches
];

for (pos_bytes, uv_bytes, norm_bytes, idx_bytes, vertex_count) in SPHERE_PATCHES {
    let positions = bytemuck::cast_slice::<u8, f32>(pos_bytes);
    let indices = bytemuck::cast_slice::<u8, u16>(idx_bytes);

    render_patch(positions, indices);
}
```

### build.rs Integration

```rust
// host_app/build.rs
use asset_build_tool::{AssetBuildConfig, build_assets};
use std::path::PathBuf;

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());

    let config = AssetBuildConfig {
        source_dir: manifest_dir.join("assets"),
        out_dir: out_dir.join("assets"),
        patch_size: 16,
        index_limit: 32,
    };

    println!("cargo:rerun-if-changed={}", config.source_dir.display());

    let generated = build_assets(&config).expect("Asset build failed");

    for asset in &generated {
        println!("cargo:rerun-if-changed={}", asset.source_path.display());
    }
}
```

---

## File Size Estimates

### Textures

| Dimensions | Pixels | Size (bytes) | Size (KB) | Size (MB) |
|------------|--------|--------------|-----------|-----------|
| 8×8 | 64 | 256 | 0.25 | 0.00024 |
| 16×16 | 256 | 1,024 | 1 | 0.001 |
| 32×32 | 1,024 | 4,096 | 4 | 0.004 |
| 64×64 | 4,096 | 16,384 | 16 | 0.016 |
| 128×128 | 16,384 | 65,536 | 64 | 0.0625 |
| 256×256 | 65,536 | 262,144 | 256 | 0.25 |
| 512×512 | 262,144 | 1,048,576 | 1,024 | 1 |
| 1024×1024 | 1,048,576 | 4,194,304 | 4,096 | 4 |

### Meshes (per patch)

| Component | Size Formula | 16 vertices | 24 vertices |
|-----------|--------------|-------------|-------------|
| Positions | vertices × 12 bytes | 192 bytes | 288 bytes |
| UVs | vertices × 8 bytes | 128 bytes | 192 bytes |
| Normals | vertices × 12 bytes | 192 bytes | 288 bytes |
| Indices (max) | indices × 2 bytes | 64 bytes | 96 bytes |
| **Total per patch** | - | **576 bytes** | **864 bytes** |

### Example Asset Set

| Asset | Type | Count | Avg Size | Total Size |
|-------|------|-------|----------|------------|
| UI textures | 64×64 | 10 | 16 KB | 160 KB |
| Character textures | 256×256 | 5 | 256 KB | 1,280 KB |
| Environment meshes | Patches | 50 | 600 bytes | 30 KB |
| Character meshes | Patches | 100 | 600 bytes | 60 KB |
| **Total** | - | - | - | **~1.5 MB** |

This fits comfortably within RP2350's 4 MB flash budget, leaving ~2.5 MB for firmware code and other data.

---

## Validation Checklist

When implementing output generation, ensure:

1. **File naming**:
   - [ ] Identifiers are uppercase with underscores
   - [ ] Filenames are lowercase versions of identifiers
   - [ ] Patch indices are 0-based and sequential
   - [ ] Parent directory is included in identifiers

2. **Rust wrapper files**:
   - [ ] Include source path comment
   - [ ] Include dimensions/counts comment
   - [ ] Include size/memory comment
   - [ ] Include usage example comment
   - [ ] Use `include_bytes!()` with correct filenames
   - [ ] Export const declarations as `pub`

3. **Binary files**:
   - [ ] Use little-endian byte order for f32 and u16
   - [ ] Use correct size (verify byte count matches expected)
   - [ ] Use raw data (no headers or padding)

4. **Texture binary**:
   - [ ] RGBA8888 format (4 bytes per pixel)
   - [ ] Row-major order (top to bottom)
   - [ ] Size = width × height × 4

5. **Mesh binaries**:
   - [ ] Positions: vertex_count × 3 × 4 bytes
   - [ ] UVs: vertex_count × 2 × 4 bytes
   - [ ] Normals: vertex_count × 3 × 4 bytes
   - [ ] Indices: index_count × 2 bytes
   - [ ] All indices < vertex_count

---

## Summary

This output format specification defines:

1. **File organization**: Clear naming conventions for identifiers and filenames
2. **Rust wrapper format**: Consistent structure with metadata comments
3. **Binary format**: Little-endian, raw data for all types
4. **Firmware integration**: Examples using `include_bytes!()` and `bytemuck`
5. **Size estimates**: Memory budgeting for typical asset sets

All formats are designed for:
- **Simplicity**: Raw binary, no parsing needed
- **Efficiency**: Direct memory mapping, compile-time inclusion
- **Compatibility**: Little-endian matches RP2350 native byte order
- **Maintainability**: Clear comments and consistent structure


## Constraints

See specification details above.

## Notes

Migrated from speckit contract: specs/003-asset-data-prep/contracts/output-format.md
