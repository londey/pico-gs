# INT-031: Asset Binary Format

## Type

Internal

## Parties

- **Provider:** External
- **Consumer:** UNIT-034 (Build.rs Orchestrator)
- **Consumer:** UNIT-033 (Codegen Engine)

## Referenced By

- REQ-012.01 (PNG Asset Processing) — area 13: Game Data Preparation/Import
- REQ-012.02 (OBJ Mesh Processing) — area 13: Game Data Preparation/Import
- REQ-012.03 (Asset Build Orchestration) — area 13: Game Data Preparation/Import

## Specification

## Overview

This document specifies the exact format of all generated output files, including Rust wrapper files and binary data files. All formats are designed for direct inclusion in RP2350 firmware builds using the `include_bytes!()` macro.

**Primary output location**: Cargo's `OUT_DIR/assets/` (ephemeral, generated by build.rs at build time). The library also generates a master `mod.rs` that re-exports all asset modules.

## File Organization

### Output Directory Structure

Generated in `OUT_DIR/assets/` by build.rs:

```
$OUT_DIR/assets/
├── mod.rs                     # Master module file (re-exports all assets)
├── textures_player.rs         # Rust wrapper
├── textures_player_rgba4444.bin  # Binary RGBA4444 data
├── textures_enemy.rs
├── textures_enemy_bc1.bin     # Binary BC1 compressed data
├── meshes_cube_patch0.rs      # Mesh patch 0 Rust wrapper
├── meshes_cube_patch0.bin     # Single SoA blob (u16 pos + i16 norm + i16 uv + u8 idx)
├── meshes_sphere_patch0.rs    # Multi-patch mesh
├── meshes_sphere_patch0.bin   # Single SoA blob
├── meshes_sphere_patch1.rs
├── meshes_sphere_patch1.bin
└── ...
```

### Source Asset Directory

Committed to version control in `host_app/assets/`:

```
host_app/assets/
├── textures/
│   ├── player.png
│   └── enemy.png
└── meshes/
    ├── cube.obj
    └── sphere.obj
```

### Naming Conventions

#### Identifier Generation

**Algorithm**:
1. Extract parent directory name (immediate parent only)
2. Extract filename without extension
3. Combine: `{parent}_{filename}` (or just `{filename}` if no parent)
4. Sanitize: Replace non-alphanumeric characters with underscore
5. Convert to uppercase
6. Prefix with underscore if starts with digit

**Examples**:

| Input Path | Parent | Filename | Combined | Identifier |
|------------|--------|----------|----------|------------|
| `player.png` | - | `player` | `player` | `PLAYER` |
| `textures/player.png` | `textures` | `player` | `textures_player` | `TEXTURES_PLAYER` |
| `ui/button-hover.png` | `ui` | `button-hover` | `ui_button-hover` | `UI_BUTTON_HOVER` |
| `meshes/3d-cube.obj` | `meshes` | `3d-cube` | `meshes_3d-cube` | `MESHES_3D_CUBE` |
| `assets/textures/player.png` | `textures` | `player` | `textures_player` | `TEXTURES_PLAYER` |

**Note**: Only the immediate parent directory is used, not the full path. This prevents overly long identifiers while still avoiding most conflicts.

#### File Naming

**Textures**:
- Rust wrapper: `{identifier_lowercase}.rs`
- Binary data: `{identifier_lowercase}_rgba4444.bin` or `{identifier_lowercase}_bc1.bin`

**Meshes** (per patch):
- Rust wrapper: `{identifier_lowercase}_patch{n}.rs` (where n is 0-based)
- Patch data: `{identifier_lowercase}_patch{n}.bin` (single SoA blob)

---

## Texture Output Format

### Rust Wrapper File (`.rs`)

**Template (textures WITH mipmaps)**:
```rust
// Generated from: {source_path}
// Dimensions: {width}x{height} (base level)
// Format: {format}
// Mipmap Levels: {mip_count}
// Total Size: {total_bytes} bytes ({total_kb} KB)
// GPU Requirements: 4K-aligned base address

pub const {IDENTIFIER}_WIDTH: u32 = {width};
pub const {IDENTIFIER}_HEIGHT: u32 = {height};
pub const {IDENTIFIER}_FORMAT: TextureFormat = TextureFormat::{format_enum};
pub const {IDENTIFIER}_MIP_LEVELS: u8 = {mip_count};
pub const {IDENTIFIER}_DATA: &[u8] = include_bytes!("{bin_filename}");

// Mipmap level offsets (bytes from start of DATA)
pub const {IDENTIFIER}_MIP_OFFSETS: [usize; {mip_count}] = [
    {offset_0},  // mip 0 (base): {width}×{height}, {size_0} bytes
    {offset_1},  // mip 1: {width_1}×{height_1}, {size_1} bytes
    {offset_2},  // mip 2: {width_2}×{height_2}, {size_2} bytes
    // ... more levels
];

// Usage in firmware:
// gpu.upload_texture_with_mipmaps(
//     0,  // slot
//     {IDENTIFIER}_WIDTH,
//     {IDENTIFIER}_HEIGHT,
//     {IDENTIFIER}_FORMAT,
//     {IDENTIFIER}_MIP_LEVELS,
//     {IDENTIFIER}_DATA,
//     &{IDENTIFIER}_MIP_OFFSETS
// );
```

**Template (textures WITHOUT mipmaps, backward compatible)**:
```rust
// Generated from: {source_path}
// Dimensions: {width}x{height}
// Format: {format}
// Size: {byte_count} bytes ({kb_size} KB)
// GPU Requirements: 4K-aligned base address

pub const {IDENTIFIER}_WIDTH: u32 = {width};
pub const {IDENTIFIER}_HEIGHT: u32 = {height};
pub const {IDENTIFIER}_FORMAT: TextureFormat = TextureFormat::{format_enum};
pub const {IDENTIFIER}_MIP_LEVELS: u8 = 1;  // Single level only
pub const {IDENTIFIER}_DATA: &[u8] = include_bytes!("{bin_filename}");

// Usage in firmware:
// gpu.set_texture(0, {IDENTIFIER}_WIDTH, {IDENTIFIER}_HEIGHT,
//                  {IDENTIFIER}_FORMAT, {IDENTIFIER}_DATA);
```

**Field Descriptions**:
- `{source_path}`: Original PNG file path (e.g., `assets/textures/player.png`)
- `{width}`, `{height}`: Texture dimensions (u32, power-of-two, 8-1024)
- `{format}`: Texture format string (`RGBA4444` or `BC1`)
- `{byte_count}`: Total bytes (format-dependent, see below)
- `{kb_size}`: Size in KB, formatted to 1 decimal place
- `{IDENTIFIER}`: Uppercase identifier (e.g., `TEXTURES_PLAYER`)
- `{format_enum}`: Rust enum variant (`RGBA4444` or `BC1`)
- `{bin_filename}`: Relative path to binary file (e.g., `player_rgba4444.bin`)

**Example** (`player.rs` - RGBA4444):
```rust
// Generated from: assets/textures/player.png
// Dimensions: 256x256
// Format: RGBA4444
// Size: 131072 bytes (128.0 KB)
// GPU Requirements: 4K-aligned base address

pub const PLAYER_WIDTH: u32 = 256;
pub const PLAYER_HEIGHT: u32 = 256;
pub const PLAYER_FORMAT: TextureFormat = TextureFormat::RGBA4444;
pub const PLAYER_DATA: &[u8] = include_bytes!("player_rgba4444.bin");

// Usage in firmware:
// gpu.set_texture(0, PLAYER_WIDTH, PLAYER_HEIGHT,
//                  PLAYER_FORMAT, PLAYER_DATA);
```

**Example** (`lightmap.rs` - BC1):
```rust
// Generated from: assets/textures/lightmap.png
// Dimensions: 256x256
// Format: BC1
// Size: 32768 bytes (32.0 KB)
// GPU Requirements: 4K-aligned base address

pub const LIGHTMAP_WIDTH: u32 = 256;
pub const LIGHTMAP_HEIGHT: u32 = 256;
pub const LIGHTMAP_FORMAT: TextureFormat = TextureFormat::BC1;
pub const LIGHTMAP_DATA: &[u8] = include_bytes!("lightmap_bc1.bin");

// Usage in firmware:
// gpu.set_texture(1, LIGHTMAP_WIDTH, LIGHTMAP_HEIGHT,
//                  LIGHTMAP_FORMAT, LIGHTMAP_DATA);
```

### RGBA4444 Binary Data File (`_rgba4444.bin`)

**Format**: Raw RGBA4444 pixel data, organized in 4x4 blocks

**Layout**:
```
Block Organization: Left-to-right, top-to-bottom
Within each 4x4 block: Left-to-right, top-to-bottom

Block 0 (pixels 0,0 to 3,3):
  Offset 0-1:   Pixel[0,0] (u16 little-endian: R4G4B4A4)
  Offset 2-3:   Pixel[1,0] (u16 little-endian)
  Offset 4-5:   Pixel[2,0] (u16 little-endian)
  Offset 6-7:   Pixel[3,0] (u16 little-endian)
  Offset 8-9:   Pixel[0,1] (u16 little-endian)
  ...
  Offset 30-31: Pixel[3,3] (u16 little-endian)

Block 1 (pixels 4,0 to 7,3):
  Offset 32-33: Pixel[4,0] (u16 little-endian)
  ...

Total size: (width / 4) x (height / 4) x 32 bytes
```

**Properties**:
- Byte order: Little-endian
- Block size: 32 bytes (16 pixels x 2 bytes)
- Pixel format: [15:12]=R, [11:8]=G, [7:4]=B, [3:0]=A
- Channel range: 0-15 (4 bits per channel)

**Size Examples**:
- 64x64: 8,192 bytes (8 KB)
- 256x256: 131,072 bytes (128 KB)
- 512x512: 524,288 bytes (512 KB)

See INT-014 for full format specification and address calculation.

### BC1 Binary Data File (`_bc1.bin`)

**Format**: BC1 block-compressed texture data

**Layout**:
```
Block Organization: Left-to-right, top-to-bottom
Each block: 8 bytes, represents 4x4 pixels

Block 0 (pixels 0,0 to 3,3):
  Offset 0-1: color0 (RGB565, u16 little-endian)
  Offset 2-3: color1 (RGB565, u16 little-endian)
  Offset 4-7: indices (2 bits per pixel, u32 little-endian)

Block 1 (pixels 4,0 to 7,3):
  Offset 8-9:   color0 (RGB565)
  Offset 10-11: color1 (RGB565)
  Offset 12-15: indices (u32)
  ...

Total size: (width / 4) x (height / 4) x 8 bytes
```

**Properties**:
- Byte order: Little-endian
- Block size: 8 bytes (4x4 pixels compressed)
- Compression ratio: 8:1 vs RGBA8, 4:1 vs RGBA4444
- Color endpoints: RGB565 format
- Indices: 2 bits per pixel

**Constraints**:
- Texture width MUST be multiple of 4
- Texture height MUST be multiple of 4

**Size Examples**:
- 64x64: 2,048 bytes (2 KB)
- 256x256: 32,768 bytes (32 KB)
- 512x512: 131,072 bytes (128 KB)
- 1024x1024: 524,288 bytes (512 KB)

See INT-014 for full format specification including BC1 decompression algorithm.

### Mipmap Chain Binary File (`_bc1.bin` or `_rgba4444.bin`)

**Format for textures with mipmaps:**

Binary file contains concatenated mipmap levels in sequential order (base first, smallest last):

```
File structure:
+0x0000: Mip level 0 (base) data
+offset_1: Mip level 1 data
+offset_2: Mip level 2 data
...
```

**Example (256×256 BC1 with 9 mipmap levels)**:

| Offset | Level | Dimensions | Size (bytes) | Block Grid |
|--------|-------|------------|--------------|------------|
| 0x0000 | 0     | 256×256    | 32,768       | 64×64      |
| 0x8000 | 1     | 128×128    | 8,192        | 32×32      |
| 0xA000 | 2     | 64×64      | 2,048        | 16×16      |
| 0xA800 | 3     | 32×32      | 512          | 8×8        |
| 0xAA00 | 4     | 16×16      | 128          | 4×4        |
| 0xAA80 | 5     | 8×8        | 32           | 2×2        |
| 0xAAA0 | 6     | 4×4        | 8            | 1×1        |
| 0xAAA8 | 7     | 2×2        | 8            | 1×1 (min)  |
| 0xAAB0 | 8     | 1×1        | 8            | 1×1 (min)  |

**Total file size**: 43,704 bytes

**Offset calculation**: Generated by codegen engine based on mipmap level sizes per INT-014.

---

## Mesh Output Format

### Rust Wrapper File (`.rs`)

**Template**:
```rust
// Generated from: {source_path} (patch {patch_index} of {total_patches})
// Vertices: {vertex_count}, Entries: {entry_count}
// Patch AABB: ({min_x}, {min_y}, {min_z}) to ({max_x}, {max_y}, {max_z})
// Data size: {data_bytes} bytes (SoA blob: u16 pos + i16 norm + i16 uv + u8 idx)

pub const {IDENTIFIER}_PATCH{n}_VERTEX_COUNT: usize = {vertex_count};
pub const {IDENTIFIER}_PATCH{n}_ENTRY_COUNT: usize = {entry_count};
pub const {IDENTIFIER}_PATCH{n}_AABB_MIN: [f32; 3] = [{min_x}, {min_y}, {min_z}];
pub const {IDENTIFIER}_PATCH{n}_AABB_MAX: [f32; 3] = [{max_x}, {max_y}, {max_z}];
pub const {IDENTIFIER}_PATCH{n}_DATA: &[u8] = include_bytes!("{base_name}_patch{n}.bin");
```

**Field Descriptions**:
- `{source_path}`: Original OBJ file path
- `{patch_index}`: 0-based patch index
- `{total_patches}`: Total number of patches for this mesh
- `{vertex_count}`: Number of vertices in this patch (≤16 by default)
- `{entry_count}`: Number of strip command entries in this patch (≤48 by default)
- `{data_bytes}`: Total blob size (vertex_count × 16 + entry_count bytes)
- `{min_x}`, `{min_y}`, `{min_z}`: Patch AABB minimum (model space, from original f32 positions)
- `{max_x}`, `{max_y}`, `{max_z}`: Patch AABB maximum (model space, from original f32 positions)
- `{IDENTIFIER}`: Uppercase identifier
- `{n}`: Patch index (0-based)
- `{base_name}`: Lowercase base name for binary files

**Example** (`cube_patch0.rs`):
```rust
// Generated from: assets/meshes/cube.obj (patch 0 of 1)
// Vertices: 16, Entries: 26
// Patch AABB: (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0)
// Data size: 282 bytes (SoA blob: u16 pos + i16 norm + i16 uv + u8 idx)

pub const CUBE_PATCH0_VERTEX_COUNT: usize = 16;
pub const CUBE_PATCH0_ENTRY_COUNT: usize = 26;
pub const CUBE_PATCH0_AABB_MIN: [f32; 3] = [-1.0, -1.0, -1.0];
pub const CUBE_PATCH0_AABB_MAX: [f32; 3] = [1.0, 1.0, 1.0];
pub const CUBE_PATCH0_DATA: &[u8] = include_bytes!("cube_patch0.bin");
```

### Patch Data Binary (`_patch{n}.bin`)

**Format**: Single contiguous SoA blob containing all vertex attributes and indices.

For N vertices and M strip entries, the layout is:

| Offset | Size | Content |
|--------|------|---------|
| 0 | N×2 | pos_x[0..N] (u16 little-endian) |
| N×2 | N×2 | pos_y[0..N] (u16 little-endian) |
| N×4 | N×2 | pos_z[0..N] (u16 little-endian) |
| N×6 | N×2 | norm_x[0..N] (i16 little-endian) |
| N×8 | N×2 | norm_y[0..N] (i16 little-endian) |
| N×10 | N×2 | norm_z[0..N] (i16 little-endian) |
| N×12 | N×2 | uv_u[0..N] (i16 little-endian) |
| N×14 | N×2 | uv_v[0..N] (i16 little-endian) |
| N×16 | M×1 | indices[0..M] (u8 strip commands) |

**Total size**: N×16 + M bytes.
**Example** (16 vertices, 48 entries): 16×16 + 48 = 304 bytes.

#### Position encoding (u16)

Mesh-wide AABB quantization grid.
All patches in a mesh share one quantization coordinate system.
Each axis maps the range [AABB_min, AABB_max] to [0, 65535].

- Type: Unsigned 16-bit integer (u16)
- Byte order: Little-endian
- Quantization: `u16_val = round((f32_pos - aabb_min) / (aabb_max - aabb_min) * 65535.0)`
- Dequantization: Folded into model matrix via bias pre-multiplication (see REQ-007.01)

#### Normal encoding (i16 1:15 signed fixed-point)

- Type: Signed 16-bit integer (i16)
- Byte order: Little-endian
- Format: 1:15 signed fixed-point (1 sign bit, 15 fractional bits)
- Range: [-1.0, +0.99997], resolution 1/32768
- Encoding: `i16_val = round(f32_normal * 32767.0)`, clamped to [-32768, 32767]
- Decoding (Core 1): `f32_normal = i16_val as f32 / 32767.0`, then normalize

#### UV encoding (i16 1:2:13 signed fixed-point)

- Type: Signed 16-bit integer (i16)
- Byte order: Little-endian
- Format: 1:2:13 (1 sign bit, 2 integer bits, 13 fractional bits)
- Range: [-4.0, +3.9998], resolution 1/8192
- Encoding: `i16_val = round(f32_uv * 8192.0)`, clamped to [-32768, 32767]
- Decoding (Core 1): `f32_uv = i16_val as f32 / 8192.0`
- Normalized 0.0–1.0 UV space (GPU handles wrapping and dimension scaling)

**Rust Conversion (SoA offset calculation)**:
```rust
let data: &[u8] = include_bytes!("cube_patch0.bin");
let n = CUBE_PATCH0_VERTEX_COUNT;

// SoA offsets (all u16/i16 little-endian, 2 bytes per element)
let pos_x = &data[0..n*2];       // u16
let pos_y = &data[n*2..n*4];     // u16
let pos_z = &data[n*4..n*6];     // u16
let norm_x = &data[n*6..n*8];    // i16
let norm_y = &data[n*8..n*10];   // i16
let norm_z = &data[n*10..n*12];  // i16
let uv_u = &data[n*12..n*14];    // i16
let uv_v = &data[n*14..n*16];    // i16
let indices = &data[n*16..n*16 + CUBE_PATCH0_ENTRY_COUNT]; // u8
```

### Index encoding (u8 strip commands)

**Format**: Packed u8 strip command stream

Each entry is a single byte encoding a vertex reference with draw control:

**Byte Layout**:
```
[7:4]  4-bit vertex index (0–15, indexing into the patch's local vertex array)
[3:2]  2-bit kick control:
         00 = NOKICK — push vertex data to GPU, no triangle emitted
         01 = KICK_012 — push vertex and emit triangle (v[0], v[1], v[2])
         10 = KICK_021 — push vertex and emit triangle (v[0], v[2], v[1])
         11 = reserved (must be 0)
[1:0]  2-bit spare (reserved, must be 0)
```

**Layout**:
```
Offset (bytes) | Data
---------------|--------------------------------------------
0              | Entry[0]: vertex_idx[7:4] | kick[3:2] | spare[1:0]
1              | Entry[1]: vertex_idx[7:4] | kick[3:2] | spare[1:0]
...            | ...
Total          | entry_count × 1 byte
```

**Properties**:
- Type: Unsigned 8-bit integer (u8)
- Byte order: N/A (single byte per entry)
- Vertex index range: 0 to 15 (4-bit, supports 16-vertex patches)
- First 2 entries of each strip segment use NOKICK (accumulate vertices), subsequent entries use KICK_012 or KICK_021 to emit triangles
- KICK_012 vs KICK_021 alternation maintains correct winding order for triangle strips
- Maps directly to GPU registers: NOKICK→VERTEX_NOKICK (0x06), KICK_012→VERTEX_KICK_012 (0x07), KICK_021→VERTEX_KICK_021 (0x08)

**Size Examples**:
- 1 triangle (3 entries): 3 bytes
- 10 triangles as strip (12 entries): 12 bytes
- 10 triangles as independent (30 entries): 30 bytes
- Max default (48 entries): 48 bytes

**Rust Conversion**:
```rust
let idx_bytes: &[u8] = &data[n*16..]; // indices are at end of SoA blob
// Each byte: vertex_index = (byte >> 4) & 0x0F, kick = (byte >> 2) & 0x03
for &entry in idx_bytes {
    let vertex_index = (entry >> 4) & 0x0F;
    let kick = (entry >> 2) & 0x03;
    // kick: 0=NOKICK, 1=KICK_012, 2=KICK_021
}
```

### Bounding Box (embedded in mesh descriptor)

**Format**: Axis-aligned bounding box (AABB) as 6× f32

**Layout**:
```
Offset (bytes) | Data
---------------|-------------------------------------
0-3            | min_x (f32, little-endian)
4-7            | min_y (f32, little-endian)
8-11           | min_z (f32, little-endian)
12-15          | max_x (f32, little-endian)
16-19          | max_y (f32, little-endian)
20-23          | max_z (f32, little-endian)
Total          | 24 bytes
```

**Properties**:
- Type: IEEE 754 single-precision float (f32)
- Byte order: Little-endian
- Coordinate system: Model space (same as vertex positions)
- Computed at build time from original f32 vertex positions in the patch (per-patch) or entire mesh (overall)
- The mesh-level AABB also serves as the quantization coordinate system for u16 position encoding

### Mesh Descriptor (Rust const format)

The mesh descriptor provides a compile-time manifest of all patches in a mesh, enabling Core 0 frustum culling and Core 1 DMA prefetch.

**Generated Rust wrapper** (per mesh, in addition to per-patch wrappers):

```rust
// Generated from: {source_path}
// Patches: {patch_count}
// Total vertices: {total_vertices}, Total entries: {total_entries}

/// Overall mesh bounding box (model space)
/// Also serves as quantization AABB for u16 position encoding
pub const {IDENTIFIER}_AABB_MIN: [f32; 3] = [{min_x}, {min_y}, {min_z}];
pub const {IDENTIFIER}_AABB_MAX: [f32; 3] = [{max_x}, {max_y}, {max_z}];
pub const {IDENTIFIER}_PATCH_COUNT: usize = {patch_count};

/// Per-patch descriptors
pub const {IDENTIFIER}_PATCHES: [MeshPatchDescriptor; {patch_count}] = [
    MeshPatchDescriptor {
        data: {IDENTIFIER}_PATCH0_DATA,
        aabb_min: [{p0_min_x}, {p0_min_y}, {p0_min_z}],
        aabb_max: [{p0_max_x}, {p0_max_y}, {p0_max_z}],
        vertex_count: {p0_vertex_count},
        entry_count: {p0_entry_count},
    },
    // ... more patches
];
```

**MeshPatchDescriptor struct** (generated in mod.rs):

```rust
#[derive(Copy, Clone)]
pub struct MeshPatchDescriptor {
    pub data: &'static [u8],
    pub aabb_min: [f32; 3],
    pub aabb_max: [f32; 3],
    pub vertex_count: usize,
    pub entry_count: usize,
}
```

---

## Binary Encoding Details

### Little-Endian Byte Order

All multi-byte values use **little-endian** encoding (least significant byte first), which is the native byte order for RP2350 (ARM Cortex-M33).

**Example**: f32 value `1.0`
- IEEE 754 representation: `0x3F800000`
- Little-endian bytes: `00 80 3F 00`
- In file: `[0x00, 0x80, 0x3F, 0x00]`

**Example**: u16 value `42`
- Binary representation: `0x002A`
- Little-endian bytes: `2A 00`
- In file: `[0x2A, 0x00]`

### Rust Code Generation

**Generating quantized SoA mesh blob**:
```rust
/// Pack a mesh patch into a single SoA blob (u16 pos, i16 norm, i16 uv, u8 idx)
fn pack_soa_blob(
    positions: &[[f32; 3]],   // N vertices
    normals: &[[f32; 3]],     // N vertices
    uvs: &[[f32; 2]],         // N vertices
    indices: &[u8],           // M strip entries
    aabb_min: [f32; 3],
    aabb_max: [f32; 3],
) -> Vec<u8> {
    let n = positions.len();
    let mut blob = Vec::with_capacity(n * 16 + indices.len());
    let extent = [aabb_max[0] - aabb_min[0], aabb_max[1] - aabb_min[1], aabb_max[2] - aabb_min[2]];
    // Positions: 3 arrays of u16 (SoA: all X, then all Y, then all Z)
    for axis in 0..3 {
        for v in positions {
            let t = if extent[axis] > 0.0 { (v[axis] - aabb_min[axis]) / extent[axis] } else { 0.0 };
            let q = (t * 65535.0).round().clamp(0.0, 65535.0) as u16;
            blob.extend_from_slice(&q.to_le_bytes());
        }
    }
    // Normals: 3 arrays of i16 1:15
    for axis in 0..3 {
        for v in normals {
            let q = (v[axis] * 32767.0).round().clamp(-32768.0, 32767.0) as i16;
            blob.extend_from_slice(&q.to_le_bytes());
        }
    }
    // UVs: 2 arrays of i16 1:2:13
    for axis in 0..2 {
        for v in uvs {
            let q = (v[axis] * 8192.0).round().clamp(-32768.0, 32767.0) as i16;
            blob.extend_from_slice(&q.to_le_bytes());
        }
    }
    // Indices: u8 strip commands (unchanged)
    blob.extend_from_slice(indices);
    blob
}
std::fs::write("cube_patch0.bin", &blob)?;
```

**Generating u8 strip command data**:
```rust
// Pack vertex index and kick control into a single byte
fn pack_strip_entry(vertex_index: u8, kick: u8) -> u8 {
    (vertex_index << 4) | (kick << 2)
}

let entries: Vec<u8> = vec![
    pack_strip_entry(0, 0),  // NOKICK
    pack_strip_entry(1, 0),  // NOKICK
    pack_strip_entry(2, 1),  // KICK_012 → triangle (v0, v1, v2)
    pack_strip_entry(3, 2),  // KICK_021 → triangle (v1, v3, v2)
];
std::fs::write("indices.bin", &entries)?;
```

**Generating RGBA4444 binary data (from RGBA8)**:
```rust
fn rgba8_to_rgba4444_blocks(rgba8: &[u8], width: usize, height: usize) -> Vec<u8> {
    let mut output = Vec::new();
    for block_y in 0..(height / 4) {
        for block_x in 0..(width / 4) {
            for texel_y in 0..4 {
                for texel_x in 0..4 {
                    let px = block_x * 4 + texel_x;
                    let py = block_y * 4 + texel_y;
                    let i = (py * width + px) * 4;
                    let r4 = (rgba8[i] >> 4) as u16;
                    let g4 = (rgba8[i + 1] >> 4) as u16;
                    let b4 = (rgba8[i + 2] >> 4) as u16;
                    let a4 = (rgba8[i + 3] >> 4) as u16;
                    let packed = (r4 << 12) | (g4 << 8) | (b4 << 4) | a4;
                    output.extend_from_slice(&packed.to_le_bytes());
                }
            }
        }
    }
    output
}
```

---

## Firmware Integration

### Master Module File (mod.rs)

The library generates a master `mod.rs` in `OUT_DIR/assets/` that re-exports all generated asset modules. This is the single entry point for firmware code.

**Generated `$OUT_DIR/assets/mod.rs`**:
```rust
// Auto-generated by asset_build_tool - do not edit
// Source: host_app/assets/

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum TextureFormat {
    RGBA4444,
    BC1,
}

#[derive(Copy, Clone)]
pub struct MeshPatchDescriptor {
    pub data: &'static [u8],
    pub aabb_min: [f32; 3],
    pub aabb_max: [f32; 3],
    pub vertex_count: usize,
    pub entry_count: usize,
}

// Textures
include!("textures_player.rs");
include!("textures_enemy.rs");

// Meshes (per-patch data + mesh descriptors)
include!("meshes_cube_patch0.rs");
include!("meshes_cube.rs");
include!("meshes_sphere_patch0.rs");
include!("meshes_sphere_patch1.rs");
include!("meshes_sphere.rs");
```

### Including in Firmware

```rust
// host_app/src/assets/mod.rs
include!(concat!(env!("OUT_DIR"), "/assets/mod.rs"));
```

This single `include!()` brings all generated asset constants into scope. No manual file management needed.

### Using Texture Data

```rust
use crate::assets::*;

// Upload texture to GPU with format
gpu.set_texture(0,
    TEXTURES_PLAYER_WIDTH,
    TEXTURES_PLAYER_HEIGHT,
    TEXTURES_PLAYER_FORMAT,
    TEXTURES_PLAYER_DATA,
);
```

### Using Mesh Data

```rust
use crate::assets::*;

// Build quantization bias matrix from mesh-level AABB
let aabb_min = MESHES_CUBE_AABB_MIN;
let aabb_max = MESHES_CUBE_AABB_MAX;
let extent = [aabb_max[0] - aabb_min[0], aabb_max[1] - aabb_min[1], aabb_max[2] - aabb_min[2]];
let bias_matrix = Mat4::from_translation(Vec3::from(aabb_min))
    * Mat4::from_scale(Vec3::new(extent[0] / 65535.0, extent[1] / 65535.0, extent[2] / 65535.0));
let adjusted_model = model_matrix * bias_matrix;
let mvp = projection * view * adjusted_model;

// Access SoA blob via offset calculation
let patch = &MESHES_CUBE_PATCHES[0];
let n = patch.vertex_count;
let data = patch.data;

// Read vertex i position (u16 → f32, bias is in MVP matrix)
let pos_x = u16::from_le_bytes([data[i*2], data[i*2+1]]) as f32;
let pos_y = u16::from_le_bytes([data[n*2 + i*2], data[n*2 + i*2+1]]) as f32;
let pos_z = u16::from_le_bytes([data[n*4 + i*2], data[n*4 + i*2+1]]) as f32;

// Read vertex i normal (i16 1:15 → f32)
let norm_x = i16::from_le_bytes([data[n*6 + i*2], data[n*6 + i*2+1]]) as f32 / 32767.0;
let norm_y = i16::from_le_bytes([data[n*8 + i*2], data[n*8 + i*2+1]]) as f32 / 32767.0;
let norm_z = i16::from_le_bytes([data[n*10 + i*2], data[n*10 + i*2+1]]) as f32 / 32767.0;

// Indices are at offset n*16
let indices = &data[n*16..n*16 + patch.entry_count];
```

### Multi-Patch Meshes

```rust
use crate::assets::*;

// Build bias matrix once per mesh (shared by all patches)
let bias_matrix = build_quantization_bias(MESHES_SPHERE_AABB_MIN, MESHES_SPHERE_AABB_MAX);
let adjusted_model = model_matrix * bias_matrix;
let mvp = projection * view * adjusted_model;

// Use the generated MeshPatchDescriptor array
for patch in &MESHES_SPHERE_PATCHES {
    // Frustum cull using per-patch AABB
    if !frustum.intersects_aabb(patch.aabb_min, patch.aabb_max) {
        continue;
    }

    // DMA prefetch single blob (~304 bytes per patch)
    dma_prefetch(patch.data);

    // Unpack SoA, convert u16/i16→f32, transform, light, submit
    // (see RenderMeshPatch processing in INT-021)
}
```

### build.rs Integration

```rust
// host_app/build.rs
use asset_build_tool::{AssetBuildConfig, build_assets};
use std::path::PathBuf;

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap());

    let config = AssetBuildConfig {
        source_dir: manifest_dir.join("assets"),
        out_dir: out_dir.join("assets"),
        patch_size: 16,
        entry_limit: 48,
    };

    println!("cargo:rerun-if-changed={}", config.source_dir.display());

    let generated = build_assets(&config).expect("Asset build failed");

    for asset in &generated {
        println!("cargo:rerun-if-changed={}", asset.source_path.display());
    }
}
```

---

## File Size Estimates

### Textures (RGBA4444)

| Dimensions | Pixels | Size (bytes) | Size (KB) |
|------------|--------|--------------|-----------|
| 8x8 | 64 | 128 | 0.125 |
| 16x16 | 256 | 512 | 0.5 |
| 32x32 | 1,024 | 2,048 | 2 |
| 64x64 | 4,096 | 8,192 | 8 |
| 128x128 | 16,384 | 32,768 | 32 |
| 256x256 | 65,536 | 131,072 | 128 |
| 512x512 | 262,144 | 524,288 | 512 |
| 1024x1024 | 1,048,576 | 2,097,152 | 2,048 |

### Textures (BC1)

| Dimensions | Pixels | Size (bytes) | Size (KB) |
|------------|--------|--------------|-----------|
| 8x8 | 64 | 32 | 0.03 |
| 16x16 | 256 | 128 | 0.125 |
| 32x32 | 1,024 | 512 | 0.5 |
| 64x64 | 4,096 | 2,048 | 2 |
| 128x128 | 16,384 | 8,192 | 8 |
| 256x256 | 65,536 | 32,768 | 32 |
| 512x512 | 262,144 | 131,072 | 128 |
| 1024x1024 | 1,048,576 | 524,288 | 512 |

### Meshes (per patch)

| Component | Size Formula | 16 vertices | Savings vs f32 |
|-----------|--------------|-------------|----------------|
| Positions (u16) | vertices × 3 × 2 bytes | 96 bytes | 50% |
| Normals (i16) | vertices × 3 × 2 bytes | 96 bytes | 50% |
| UVs (i16) | vertices × 2 × 2 bytes | 64 bytes | 50% |
| Indices (u8) | entries × 1 byte | 48 bytes | 0% |
| AABB | 6 × 4 bytes (in descriptor) | 24 bytes | 0% |
| **Total per patch binary** | vertices × 16 + entries | **304 bytes** | **46%** |

Plus mesh-level overhead: ~48 bytes for quantization AABB (6× f32, stored in Rust wrapper constants).

### Example Asset Set

| Asset | Type | Count | Avg Size | Total Size |
|-------|------|-------|----------|------------|
| UI textures (RGBA4444) | 64x64 | 10 | 8 KB | 80 KB |
| Character textures (RGBA4444) | 256x256 | 5 | 128 KB | 640 KB |
| Environment meshes | Patches | 50 | 304 bytes | 15 KB |
| Character meshes | Patches | 100 | 304 bytes | 30 KB |
| **Total** | - | - | - | **~0.76 MB** |

With RGBA4444 (50% savings vs RGBA8) and BC1 (87.5% savings vs RGBA8), this fits very comfortably within RP2350's 4 MB flash budget, leaving ~3.2 MB for firmware code and other data.

---

## Validation Checklist

When implementing output generation, ensure:

1. **File naming**:
   - [ ] Identifiers are uppercase with underscores
   - [ ] Filenames are lowercase versions of identifiers
   - [ ] Patch indices are 0-based and sequential
   - [ ] Parent directory is included in identifiers

2. **Rust wrapper files**:
   - [ ] Include source path comment
   - [ ] Include dimensions/counts comment
   - [ ] Include size/memory comment
   - [ ] Include usage example comment
   - [ ] Use `include_bytes!()` with correct filenames
   - [ ] Export const declarations as `pub`

3. **Binary files**:
   - [ ] Use little-endian byte order for f32 and u16 (textures)
   - [ ] Use correct size (verify byte count matches expected)
   - [ ] Use raw data (no headers or padding)

4. **Texture binary**:
   - [ ] RGBA4444: 4x4 block organization, 32 bytes per block
   - [ ] RGBA4444: Size = (width / 4) x (height / 4) x 32
   - [ ] BC1: 4x4 block organization, 8 bytes per block
   - [ ] BC1: Size = (width / 4) x (height / 4) x 8
   - [ ] BC1: Width and height are multiples of 4
   - [ ] Format matches filename suffix (_rgba4444.bin or _bc1.bin)

5. **Mesh binaries**:
   - [ ] Patch blob total size: vertex_count × 16 + entry_count bytes
   - [ ] Positions (u16): vertex_count × 3 × 2 bytes, values in [0, 65535]
   - [ ] Normals (i16 1:15): vertex_count × 3 × 2 bytes, values in [-32768, 32767]
   - [ ] UVs (i16 1:2:13): vertex_count × 2 × 2 bytes
   - [ ] SoA ordering: pos_x, pos_y, pos_z, norm_x, norm_y, norm_z, uv_u, uv_v, indices
   - [ ] Indices: entry_count × 1 byte (u8 strip command stream, unchanged)
   - [ ] All vertex indices (bits [7:4]) < vertex_count and ≤ 15
   - [ ] Kick control (bits [3:2]) is 0, 1, or 2 (no reserved value 3)
   - [ ] Spare bits [1:0] are zero in every entry
   - [ ] First 2 entries of each strip segment use NOKICK (kick = 0)
   - [ ] Mesh-level AABB encompasses all per-patch AABBs
   - [ ] Per-patch AABBs computed from original f32 positions (not quantized u16)
   - [ ] All patches in a mesh use the same quantization AABB (mesh-level)

---

## Summary

This output format specification defines:

1. **File organization**: Clear naming conventions for identifiers and filenames
2. **Rust wrapper format**: Consistent structure with metadata comments
3. **Binary format**: Little-endian, raw data for all types
4. **Firmware integration**: Examples using `include_bytes!()` and `bytemuck`
5. **Size estimates**: Memory budgeting for typical asset sets

All formats are designed for:
- **Simplicity**: Raw binary, no parsing needed
- **Efficiency**: Direct memory mapping, compile-time inclusion
- **Compatibility**: Little-endian matches RP2350 native byte order
- **Maintainability**: Clear comments and consistent structure


## Constraints

See specification details above.

## Notes

Migrated from speckit contract: specs/003-asset-data-prep/contracts/output-format.md
