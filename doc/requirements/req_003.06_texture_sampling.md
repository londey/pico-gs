# REQ-003.06: Texture Sampling

## Classification

- **Priority:** Essential
- **Stability:** Stable
- **Verification:** Test

## Requirement

When the pixel pipeline samples a texel during rasterization, the system SHALL decode the texture data using format-specific decoding for the configured format (BC1, BC2, BC3, BC4, RGB565, RGBA8888, or R8) and produce a decompressed RGBA8 value for downstream processing.

## Rationale

This requirement defines the functional behavior of the texture sampling subsystem, including format-specific decoding algorithms that convert stored texture data into RGBA8 values for the rendering pipeline.

## Parent Requirements

REQ-003

## Allocated To

- UNIT-006 (Pixel Pipeline)

## Interfaces

- INT-010 (GPU Register Map) - TEXn_CFG register (format, dimensions, swizzle, wrap, filter)
- INT-011 (SDRAM Memory Layout) - Texture memory region
- INT-014 (Texture Memory Layout) - Format specifications and addressing
- INT-032 (Texture Cache Architecture)

## Functional Requirements

### FR-024-1: BC1 Block Decompression

The pixel pipeline SHALL decode BC1 compressed texture data as follows:

1. **Address calculation:**
   - block_x = pixel_x / 4
   - block_y = pixel_y / 4
   - block_addr = texture_base + (block_y * blocks_per_row + block_x) * 8

2. **Read block data (8 bytes):**
   - color0 (bytes 0-1): RGB565, little-endian u16
   - color1 (bytes 2-3): RGB565, little-endian u16
   - indices (bytes 4-7): 32 bits, little-endian u32

3. **Generate color palette:**
   ```
   palette[0] = decode_rgb565(color0)
   palette[1] = decode_rgb565(color1)

   if (color0 > color1):  // as u16 comparison — 4-color opaque mode
       palette[2] = (2*palette[0] + palette[1]) / 3
       palette[3] = (palette[0] + 2*palette[1]) / 3
       alpha[0..3] = 255
   else:                  // 3-color + transparent mode
       palette[2] = (palette[0] + palette[1]) / 2
       palette[3] = RGB(0, 0, 0)
       alpha[0..2] = 255
       alpha[3] = 0
   ```

4. **Extract pixel index:**
   - texel_offset = (pixel_y % 4) * 4 + (pixel_x % 4)
   - index = (indices >> (texel_offset * 2)) & 0x3

5. **Output pixel:**
   - RGBA8 = (palette[index].rgb, alpha[index])

### FR-024-2: BC2 Block Decompression

The pixel pipeline SHALL decode BC2 compressed texture data (16 bytes per block) as follows:

1. Read alpha data from bytes 0–7: four u16 values, each holding one row of four 4-bit alpha values.
   Each row u16: bits [3:0] = alpha[col 0], [7:4] = alpha[col 1], [11:8] = alpha[col 2], [15:12] = alpha[col 3].
   Expand: A8 = (A4 << 4) | A4.

2. Decode color data from bytes 8–15 using BC1 opaque (4-color) mode color block.
   The color0 > color1 comparison is forced to true for BC2 color decode regardless of actual values.

3. Output RGBA8 combining interpolated RGB from color block with explicit A8 from alpha bytes.

### FR-024-3: BC3 Block Decompression

The pixel pipeline SHALL decode BC3 compressed texture data (16 bytes per block) as follows:

1. Read alpha0 (byte 0) and alpha1 (byte 1) as u8.
2. Decode 3-bit alpha indices from bytes 2–7 (6 bytes, 48 bits, 3 bits per texel, 16 texels).
3. **Generate alpha palette:**
   ```
   if alpha0 > alpha1:                // 8-entry interpolated
       palette[0..1] = alpha0, alpha1
       palette[2..7] = linear interpolation between alpha0 and alpha1
   else:                              // 6-entry + fixed 0 and 255
       palette[0..1] = alpha0, alpha1
       palette[2..5] = linear interpolation
       palette[6] = 0
       palette[7] = 255
   ```
4. Decode color data from bytes 8–15 using BC1 opaque (4-color) mode color block.
5. Output RGBA8 combining RGB from color block with alpha from palette.

### FR-024-4: BC4 Block Decompression

The pixel pipeline SHALL decode BC4 compressed texture data (8 bytes per block) as follows:

1. Decode the block using the BC3 alpha block encoding (FR-024-3, bytes 0–7).
2. The decoded value is the red channel (UNORM8).
3. Output: R = decoded value, G = 0, B = 0, A = 255.
4. Apply swizzle (e.g., RRR1) after decoding to replicate to RGB for grayscale use (FR-024-7).

### FR-024-5: RGB565 Decoding

The pixel pipeline SHALL decode RGB565 texture data as follows:

1. Read 16-bit pixel value from texture memory (little-endian), offset within 4×4 block per INT-014.
2. Extract channels: R5 = bits[15:11], G6 = bits[10:5], B5 = bits[4:0].
3. Expand to 8-bit with top-bit replication:
   ```
   R8 = (R5 << 3) | (R5 >> 2)
   G8 = (G6 << 2) | (G6 >> 4)
   B8 = (B5 << 3) | (B5 >> 2)
   A8 = 255
   ```
4. Output RGBA8 value.

### FR-024-6: RGBA8888 Decoding

The pixel pipeline SHALL decode RGBA8888 texture data as follows:

1. Read 32-bit pixel value from texture memory (little-endian), offset within 4×4 block per INT-014.
2. Extract channels: R = bits[7:0], G = bits[15:8], B = bits[23:16], A = bits[31:24].
3. Output directly as RGBA8 (no expansion needed; values are UNORM8).

### FR-024-7: R8 Decoding

The pixel pipeline SHALL decode R8 texture data as follows:

1. Read 8-bit value from texture memory, offset within 4×4 block per INT-014.
2. Output: R = stored byte (UNORM8), G = 0, B = 0, A = 255.
3. Apply RRR1 swizzle (or other pattern via TEXn_CFG.SWIZZLE) for grayscale broadcast.

### FR-024-8: Swizzle Application

After texture decode, apply swizzle pattern (TEXn_CFG.SWIZZLE) to
reorder or replicate channels.
See INT-010 for swizzle encoding.

### FR-024-9: Texture Coordinate Wrapping

Apply UV wrapping mode (TEXn_CFG.U_WRAP / TEXn_CFG.V_WRAP) before addressing.
UV coordinates at this stage are Q4.12 per component as received from the rasterizer (UNIT-005) fragment bus.
See REQ-003.05.

For BC-family textures, wrapping must respect 4×4 block boundaries.

### FR-024-10: Cache-Aware Sampling Pipeline

Texture sampling SHALL first check the per-sampler texture cache (REQ-003.08):

1. Apply UV wrapping (FR-024-9) and compute texel coordinates
2. Compute cache set index using XOR-folded addressing and compare tags
3. On cache hit: read decompressed RGBA5652 texels directly from interleaved banks (1 cycle for 2×2 bilinear quad)
4. On cache miss: stall pipeline, fetch 4×4 block from SDRAM (CAS latency + burst transfer), decompress to RGBA5652, fill cache line, then resume sampling
5. Apply swizzle pattern (FR-024-8) after reading from cache
6. Bilinear filtering operates on 4 texels read in parallel from the interleaved banks within each sampler's cache

**Note:** The cache stores decompressed RGBA5652 texels, so format-specific decoding (FR-024-1 through FR-024-7) occurs only on cache miss during the fill operation, not on every texel access.
Each of the 2 texture samplers has its own independent cache (REQ-003.08).

### FR-024-11: Texture Format Promotion to Q4.12

After cache read, texture pixel data SHALL be promoted from RGBA5652 to Q4.12 fixed-point for the fragment pipeline:

- **R5 → R Q4.12:** left shift 7, replicate top 5 bits to fill fractional low bits
- **G6 → G Q4.12:** left shift 6, replicate top 6 bits to fill fractional low bits
- **B5 → B Q4.12:** left shift 7, replicate top 5 bits to fill fractional low bits
- **A2 → A Q4.12:** expand (00→0, 01→1365, 10→2730, 11→4095) — three equal steps in [0, 1)

Fractional bits fill uses the same top-bit-replication approach as channel expansion.
Promotion occurs in a dedicated pipeline stage (1 cycle, pipelined).

See REQ-004.02 for Q4.12 fixed-point format details.

## Verification Method

**Test:** Execute relevant test suite for texture sampling, including:

- [ ] BC1 decode produces correct output for 4-color opaque mode (color0 > color1)
- [ ] BC1 decode produces correct output for 1-bit alpha mode (color0 ≤ color1)
- [ ] BC1 color interpolation matches reference implementation
- [ ] BC2 decode produces correct explicit alpha for all 4-bit alpha values
- [ ] BC3 decode produces correct interpolated alpha for 8-entry and 6-entry modes
- [ ] BC4 decode produces correct red channel values
- [ ] RGB565 decode produces correct RGBA8 output with top-bit replication
- [ ] RGBA8888 decode passes values through unchanged
- [ ] R8 decode produces correct red-channel output
- [ ] Swizzle patterns apply correctly to decoded RGBA values
- [ ] UV wrapping modes work correctly with block-organized textures
- [ ] Texture cache hit returns correct RGBA5652 texels
- [ ] Texture cache miss triggers SDRAM fetch and correct cache fill
- [ ] Bilinear 2×2 quad reads from interleaved banks simultaneously on cache hit
- [ ] Cache invalidation on TEXn_CFG write prevents stale data
- [ ] RGBA5652 → Q4.12 promotion produces correct values for all component ranges
- [ ] A2 expansion produces correct Q4.12 alpha values (0, 1365, 2730, 4095)

## Notes

See INT-014 for detailed format specifications.

The system supports 2 texture samplers (TEX0, TEX1), each with an independent cache (REQ-003.08).
Texture colors produced by sampling feed into the color combiner stage (REQ-004.01).
