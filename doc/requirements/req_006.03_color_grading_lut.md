# REQ-006.03: Color Grading LUT

## Classification

- **Priority:** Important
- **Stability:** Stable
- **Verification:** Demonstration

## Requirement

When the display controller reads a pixel from the framebuffer for scanout, the system SHALL optionally pass that pixel through a programmable color grading lookup table to apply real-time gamma correction, color temperature adjustment, or artistic color effects before DVI encoding.

## Rationale

Post-processing effects like gamma correction and color grading are traditionally applied by re-rendering or using compute shaders. A hardware LUT at scanout provides real-time color transformation with no rendering performance overhead and no wasted work from overdraw.

## Parent Requirements

- REQ-006 (Screen Scan Out)

## Related Requirements

- REQ-006.01 (Display Output)

## Allocated To

- UNIT-008 (Display Controller)
- UNIT-022 (GPU Driver Layer)

## Interfaces

- INT-010 (GPU Register Map) — FB_DISPLAY (0x41), FB_DISPLAY_SYNC (0x47)
- INT-011 (SDRAM Memory Layout) — Color grading LUT data storage region
- INT-020 (GPU Driver API) — `gpu_swap_buffers()`, `gpu_prepare_lut()`

## Functional Requirements

### FR-133-1: LUT Structure

The GPU SHALL implement three independent 1D LUTs for color grading, indexed by the RGB565 framebuffer components:

- **Red LUT:** 32 entries (indexed by R[4:0]), each entry is RGB888 (24 bits)
- **Green LUT:** 64 entries (indexed by G[5:0]), each entry is RGB888 (24 bits)
- **Blue LUT:** 32 entries (indexed by B[4:0]), each entry is RGB888 (24 bits)

Total storage: (32 + 64 + 32) × 24 bits = 3072 bits, fitting in 1 EBR block (512×36 configuration, using 128 of 512 entries).

### FR-133-2: LUT Lookup Process

For each scanout pixel, the GPU SHALL:
1. Read RGB565 pixel from framebuffer
2. Extract components: `r5 = pixel[15:11]`, `g6 = pixel[10:5]`, `b5 = pixel[4:0]`
3. Lookup in parallel:
   - `lut_r_out = red_lut[r5]` (returns RGB888)
   - `lut_g_out = green_lut[g6]` (returns RGB888)
   - `lut_b_out = blue_lut[b5]` (returns RGB888)
4. Sum with saturation to produce final RGB888 for DVI TMDS encoding:
   - `final_R8 = saturate(lut_r_out[23:16] + lut_g_out[23:16] + lut_b_out[23:16], 8'hFF)`
   - `final_G8 = saturate(lut_r_out[15:8] + lut_g_out[15:8] + lut_b_out[15:8], 8'hFF)`
   - `final_B8 = saturate(lut_r_out[7:0] + lut_g_out[7:0] + lut_b_out[7:0], 8'hFF)`

### FR-133-3: LUT Upload Protocol (SDRAM-Based)

The firmware SHALL upload LUT data to SDRAM and trigger auto-load using the following protocol:

1. **Prepare LUT data in SDRAM** (384 bytes at 4KiB-aligned address):
   - Use MEM_ADDR/MEM_DATA registers or bulk transfer to upload LUT to SDRAM
   - LUT format (sequential, 384 bytes total):
     - Offset 0x000-0x05D: Red LUT (32 entries × 3 bytes RGB888)
     - Offset 0x060-0x11D: Green LUT (64 entries × 3 bytes RGB888)
     - Offset 0x120-0x17D: Blue LUT (32 entries × 3 bytes RGB888)
   - Each entry: 3 bytes in order R[23:16], G[15:8], B[7:0]

2. **Trigger LUT auto-load**:
   - Write to `FB_DISPLAY` (0x41, non-blocking) or `FB_DISPLAY_SYNC` (0x47, blocking)
   - Set `FB_ADDR` to framebuffer address, `LUT_ADDR` to SDRAM LUT base address, `COLOR_GRADE_ENABLE=1`
   - Hardware auto-loads 384 bytes from SDRAM to inactive EBR bank during vblank
   - Bank swap happens atomically with framebuffer switch at vsync

3. **Skip LUT update** (framebuffer-only switch):
   - Set `LUT_ADDR=0` to skip auto-load and keep current LUT
   - Only framebuffer address changes at vsync

**SDRAM LUT Memory Format:**
```
Offset  | Data           | Description
--------|----------------|----------------------------------
0x000   | RGB888         | Red LUT entry 0 (R_in=0)
0x003   | RGB888         | Red LUT entry 1 (R_in=1)
...     | ...            | ...
0x05D   | RGB888         | Red LUT entry 31 (R_in=31)
0x060   | RGB888         | Green LUT entry 0 (G_in=0)
0x063   | RGB888         | Green LUT entry 1 (G_in=1)
...     | ...            | ...
0x11D   | RGB888         | Green LUT entry 63 (G_in=63)
0x120   | RGB888         | Blue LUT entry 0 (B_in=0)
0x123   | RGB888         | Blue LUT entry 1 (B_in=1)
...     | ...            | ...
0x17D   | RGB888         | Blue LUT entry 31 (B_in=31)
0x180   | (padding)      | Unused (pad to 4KiB boundary)
```

**LUT DMA Timing (at 100 MHz `clk_core`, same domain as SDRAM):**
- DMA transfer: 384 bytes = 192 x 16-bit SDRAM reads at 100 MHz
- Single-word transfer time: ~2.5 us (192 individual SDRAM reads, each incurring row activation + CAS latency overhead)
- Burst transfer time: ~1.2 us (192 reads issued as burst requests within a single row activation, amortizing tRCD and CAS latency; see UNIT-008)
- Vblank period: ~1.43 ms (640x480@60Hz)
- Ample margin for LUT load during vblank (SDRAM burst mode provides ~2x speedup; LUT DMA consumes <0.2% of vblank even in single-word mode)

### FR-133-4: Double-Buffering (Auto-Swap)

The LUT SHALL use two EBR banks for double-buffering:
- **Active bank**: Used by scanout for LUT lookups
- **Inactive bank**: Target for LUT DMA auto-load
- Bank swap is **implicit** and occurs atomically at vsync when LUT auto-load triggered
- No explicit `SWAP_BANKS` control needed (automatic with `FB_DISPLAY` writes when `LUT_ADDR != 0`)

**Auto-Load Sequence:**
1. Firmware writes to `FB_DISPLAY` or `FB_DISPLAY_SYNC` with `LUT_ADDR != 0`
2. At vsync edge:
   a. Hardware DMAs 384 bytes from SDRAM to inactive EBR bank
   b. After DMA completes, banks swap atomically
   c. Framebuffer address switch also takes effect
3. Scanout immediately uses new LUT from newly-active bank

This ensures LUT updates do not cause tearing or artifacts during display refresh.

### FR-133-5: Bypass Mode

When `FB_DISPLAY[0]` (COLOR_GRADE_ENABLE) is 0, the LUT SHALL be bypassed and framebuffer pixels SHALL pass directly to the DVI encoder with standard RGB565→RGB888 expansion:
- `R8 = {R5, R5[4:2]}` (replicate MSBs to fill 8 bits)
- `G8 = {G6, G6[5:4]}`
- `B8 = {B5, B5[4:2]}`

Default state after reset is disabled (bypass, `COLOR_GRADE_ENABLE=0`).

## Verification Method

**Demonstration:** The system SHALL meet the following acceptance criteria:

- [ ] Upload LUT data to SDRAM (384 bytes at 4KiB-aligned address)
- [ ] Three 1D LUTs with correct entry counts (R:32, G:64, B:32)
- [ ] Each LUT entry is RGB888 format (24 bits, 3 bytes)
- [ ] LUT lookup indexes by RGB565 component values (R5, G6, B5)
- [ ] LUT outputs are summed with saturation to produce final scanout color
- [ ] LUT applies at scanout (between framebuffer read and DVI encoder)
- [ ] LUT auto-load from SDRAM triggered by FB_DISPLAY/FB_DISPLAY_SYNC write
- [ ] LUT DMA completes within vblank period (~2.5us of 1.43ms budget)
- [ ] LUT updates are double-buffered (auto-swap during vblank, no tearing)
- [ ] Bank swap happens atomically with framebuffer switch
- [ ] Color grading can be enabled/disabled via FB_DISPLAY[0] (COLOR_GRADE_ENABLE)
- [ ] LUT_ADDR=0 skips auto-load, only switches framebuffer
- [ ] FB_DISPLAY (non-blocking) returns immediately, changes apply at next vsync
- [ ] FB_DISPLAY_SYNC (blocking) waits for vsync before completing
- [ ] Verify identity LUT (each channel maps to itself) produces unchanged output
- [ ] Verify gamma correction curve produces visually correct result
- [ ] Verify color tinting (cross-channel LUT) works correctly
- [ ] Scanout timing unaffected (2 cycle LUT latency within pixel period)
- [ ] Multiple LUTs can be pre-prepared in SDRAM and switched instantly

## Notes

The LUT architecture uses three 1D LUTs with RGB outputs (rather than one 3D LUT or three independent per-channel LUTs) to balance flexibility and resource usage. This allows cross-channel effects (e.g., red input influencing green output for color tinting) while fitting in 1 EBR.

Common use cases: gamma correction (linear→sRGB), color temperature adjustment, brightness/contrast/saturation, artistic color grading, fade-to-black effects.

See DD-013 in design_decisions.md for LUT architecture rationale.
See DD-014 in design_decisions.md for SDRAM-based auto-load rationale.
