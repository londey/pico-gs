# REQ-005.06: Framebuffer Format

## Classification

- **Priority:** Essential
- **Stability:** Stable
- **Verification:** Test

## Requirement

When the pixel pipeline writes a fragment to the framebuffer, the system SHALL store the pixel color in RGB565 format (5-bit red, 6-bit green, 5-bit blue) as a single 16-bit value at the block-tiled SDRAM address computed from the fragment's (x, y) position and the active surface width (INT-011).

When the pixel pipeline reads a framebuffer pixel for alpha blending, the system SHALL promote the RGB565 value to Q4.12 fixed-point by left-shifting and replicating MSBs, and SHALL treat the promoted alpha as fully opaque (Q4.12 value 1.0).

## Rationale

This requirement defines the functional behavior of the framebuffer format subsystem.
RGB565 is the native pixel format; the 4×4 block-tiled layout unifies the framebuffer with textures and the Z-buffer, enabling render-to-texture with no format conversion.
Native 16-bit addressing (one SDRAM column per pixel) eliminates the storage waste of the former 32-bit-per-pixel layout and is documented in INT-011.

## Parent Requirements

- REQ-005 (Blend/Frame Buffer Store)

## Allocated To

- UNIT-006 (Pixel Pipeline)
- UNIT-007 (Memory Arbiter)
- UNIT-008 (Display Controller)

## Interfaces

- INT-010 (GPU Register Map)
- INT-011 (SDRAM Memory Layout)

## Functional Requirements

### FR-025-1: Framebuffer Pixel Format

The framebuffer SHALL store pixels in RGB565 format within 16-bit SDRAM words:

- `[15:11]` = R5 (5-bit red)
- `[10:5]` = G6 (6-bit green)
- `[4:0]` = B5 (5-bit blue)

Each pixel occupies exactly one 16-bit SDRAM column.
Pixels are arranged in 4×4 block-tiled layout as defined in INT-011.

### FR-025-2: Fragment to Framebuffer Conversion

The pixel pipeline SHALL convert Q4.12 fixed-point fragment colors to RGB565 as follows:

1. Apply ordered dithering if enabled (REQ-005.10): add scaled dither value to the fractional bits
2. Saturate to [0.0, 1.0] (clamp to Q4.12 range [0x0000, 0x1000])
3. Extract upper bits from the UNORM representation: R[4:0]→R5, G[5:0]→G6, B[4:0]→B5
4. Pack into RGB565 format
5. Alpha channel is discarded (RGB565 has no alpha storage)

### FR-025-3: Framebuffer to Fragment Promotion

For alpha blending readback, the pixel pipeline SHALL promote RGB565 framebuffer pixels to Q4.12 fixed-point:

- R5→Q4.12: expand to 8-bit UNORM (`{R5, R5[4:2]}`), then convert to Q4.12 (`result = unorm8 << 4`)
- G6→Q4.12: expand to 8-bit UNORM (`{G6, G6[5:4]}`), then convert to Q4.12 (`result = unorm8 << 4`)
- B5→Q4.12: expand to 8-bit UNORM (`{B5, B5[4:2]}`), then convert to Q4.12 (`result = unorm8 << 4`)
- Alpha defaults to Q4.12 value 1.0 (0x1000) since RGB565 has no alpha storage

## Verification Method

**Test:** Execute relevant test suite for framebuffer format:

- [ ] RGB565 pixel packing matches format (R[15:11], G[10:5], B[4:0])
- [ ] Tiled address calculation produces correct SDRAM addresses for pixels at arbitrary (x, y) positions with at least two distinct FB_CONFIG.WIDTH_LOG2 values (e.g. WIDTH_LOG2=9 for 512-wide, WIDTH_LOG2=8 for 256-wide)
- [ ] Q4.12→RGB565 conversion with dithering produces correct output
- [ ] Q4.12→RGB565 conversion without dithering truncates correctly
- [ ] RGB565→Q4.12 promotion for alpha blending readback produces correct values
- [ ] Alpha channel discarded on framebuffer write

## Notes

The framebuffer format remains RGB565 for memory efficiency.
Internal pipeline processing uses Q4.12 fixed-point (REQ-004.02) with ordered dithering (REQ-005.10) to minimize visible banding during the conversion to RGB565.

**SDRAM Burst Mode Compatibility:**
The 4×4 block-tiled layout stores pixels in block-contiguous order in SDRAM (INT-011).
The rasterizer walks the bounding box in 4×4 tile order so that all pixels within a tile are processed before advancing to the next, maximizing write-coalescing opportunities.
The write-coalescing buffer collects adjacent pixels within the same tile and issues a single burst write per tile (up to 16 consecutive 16-bit writes), amortizing SDRAM row activation overhead.
Display scanout reads tiles sequentially across each scanline, also issuing burst reads.
