# REQ-010.02: Verilator Interactive Simulator

## Classification

- **Priority:** Important
- **Stability:** Draft
- **Verification:** Test

## Requirement

When running the Verilator interactive simulator, the system SHALL provide a standalone application that drives the GPU RTL model by injecting 72-bit register writes directly into the command FIFO via sim-only injection ports (bypassing SPI serial framing), renders the post-horizontal-resize display controller pixel output to an SDL3 framebuffer window, and executes programmable command sequences via a Lua scripting API.

## Rationale

The Verilator interactive simulator enables GPU development and debugging without FPGA hardware or an RP2350.
It exercises the GPU RTL in a software environment with full observability, supports scripted and ad-hoc register write sequences, and provides a live visual display of rendered output.
This complements the FT232H PC debug host (REQ-010.01), which requires real FPGA hardware; the two tools serve distinct development scenarios.

## Parent Requirements

- REQ-010 (GPU Debug GUI)

## Allocated To

A new design unit (UNIT-037, Verilator Interactive Simulator App) shall document the implementation.

## Interfaces

- `SIM_DIRECT_CMD` injection ports on `gpu_top.sv` (RTL, sim-only, guarded by `` `ifdef SIM_DIRECT_CMD ``)
- SDL3 display window (pixel output from `disp_pixel_red`, `disp_pixel_green`, `disp_pixel_blue`, `disp_enable`, `disp_vsync_out`)
- Lua scripting API (via sol2) for programmable command sequences
- Base Lua script (`spi_gpu/sim/lua/gpu_regs.lua`) providing documented helper functions (see REQ-010.02-LUA below)
- Behavioral SDRAM model substituting for the W9825G6KH (must implement W9825G6KH burst mode, CAS latency CL=3, row activation timing, and auto-refresh behavior; see UNIT-007)

## Child Requirements

### REQ-010.02-LUA: Base Lua Register Helper Script

When the Verilator interactive simulator is built, the system SHALL provide a base Lua script (`spi_gpu/sim/lua/gpu_regs.lua`) that defines one documented helper function per GPU register type.
Each helper function SHALL:

- Accept the register's named fields as arguments (not raw 64-bit integers).
- Pack the fields into the correct 64-bit data word per the register encoding defined in `registers/rdl/gpu_regs.rdl`.
- Call the underlying raw FIFO write primitive with the correct address and packed data word.
- Include a Lua doc-comment (using `---` annotation style) describing the function's purpose, each parameter by name and type, and the register address it writes.

Example helper function shape (illustrative, not normative):

```lua
--- Write the RENDER_MODE register (address 0x30).
--- @param gouraud_en  boolean  Enable Gouraud shading (bit 0)
--- @param z_test_en   boolean  Enable depth test (bit 2)
--- @param z_write_en  boolean  Enable depth write (bit 3)
--- @param color_write boolean  Enable color write (bit 4)
function gpu.set_render_mode(gouraud_en, z_test_en, z_write_en, color_write)
    local data = (gouraud_en  and 0x01 or 0)
               | (z_test_en   and 0x04 or 0)
               | (z_write_en  and 0x08 or 0)
               | (color_write and 0x10 or 0)
    gpu.write_reg(0x30, data)
end
```

The script SHALL cover at minimum the following register types: `COLOR`, `UV0_UV1`, `VERTEX_NOKICK`, `VERTEX_KICK_012`, `VERTEX_KICK_021`, `RENDER_MODE`, `Z_RANGE`, `FB_CONFIG`, `FB_CONTROL`, `FB_DISPLAY`, `TEX0_CFG`, `TEX0_FMT`, `CC_MODE`, `CONST_COLOR`, and `MEM_FILL`.

## Acceptance Criteria

- When the simulator is started, the SDL3 window opens and displays output from the GPU RTL model.
- When a Lua script submits a triangle render sequence via the FIFO injection API, the resulting pixels appear in the SDL3 window within the same rendered frame.
- When the command FIFO is full (`wr_almost_full` asserted), the Lua API and C++ injection layer apply backpressure (block or signal the caller) rather than dropping commands.
- When `disp_vsync_out` asserts, the SDL3 window presents the completed frame.
- When `gpu_regs.lua` is loaded in the Lua interpreter, all helper functions listed in REQ-010.02-LUA are available and each function writes the correct register address with correctly packed field data.

## Notes

The Verilator sim app drives the GPU out-of-band: it does not use the `SpiTransport` / `FlowControl` traits defined in INT-040, and it does not exercise UNIT-001 (SPI Slave Controller) or the physical SPI framing defined in INT-012.
The `SIM_DIRECT_CMD` path presents the same logical 72-bit format (`{rw[0], addr[6:0], data[63:0]}`) to the FIFO write port that the SPI slave would present after deserializing a transaction.

A future integration path could expose a Rust `SimTransport` implementing `SpiTransport` (INT-040), allowing `pico-gs-core` driver code (UNIT-022) to run against the sim without modification.
Whether to implement this is a design decision to be captured in `design_decisions.md` before UNIT-037 implementation begins.
