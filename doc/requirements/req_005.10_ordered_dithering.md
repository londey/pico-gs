# REQ-005.10: Ordered Dithering

## Classification

- **Priority:** Important
- **Stability:** Stable
- **Verification:** Demonstration

## Requirement

When the pixel pipeline writes a fragment color to the RGB565 framebuffer, the system SHALL apply ordered dithering before the format conversion to reduce visible color banding artifacts in smooth gradients.

## Rationale

Converting 10.8 fixed-point fragment colors to RGB565 format discards fractional bits, causing visible banding in smooth gradients. Ordered dithering trades spatial resolution for color resolution, creating the perception of smooth gradients.

## Parent Requirements

- REQ-005 (Blend/Frame Buffer Store — top-level area 5 requirement, not yet created)
- REQ-005.06 (Framebuffer Format — peer requirement)
- REQ-004.02 (Extended Precision Fragment Processing — peer requirement)

## Allocated To

- UNIT-006 (Pixel Pipeline)
- UNIT-022 (GPU Driver Layer)

## Interfaces

- INT-010 (GPU Register Map) — DITHER_MODE register (0x32)
- INT-020 (GPU Driver API) — `gpu_set_dither_mode()`

## Functional Requirements

### FR-132-1: Dither Matrix Storage

The GPU SHALL store a 16x16 blue noise dither matrix in 1 EBR block (256 entries x 18 bits, using native ECP5 1024x18 configuration). The matrix stores 6 bits per component (R, G, B) packed into 18 bits per entry. The matrix is baked into FPGA configuration at synthesis time and is not runtime-configurable.

### FR-132-2: Dither Value Scaling

For each pixel, the GPU SHALL:
1. Read dither matrix entry indexed by `{screen_y[3:0], screen_x[3:0]}`
2. Scale the 6-bit dither value per channel based on target bit depth:
   - R and B (8→5 bit targets, losing 3 bits): use top 3 bits of 6-bit value (range 0-7)
   - G (8→6 bit target, losing 2 bits): use top 2 bits of 6-bit value (range 0-3)

### FR-132-3: Dithering Algorithm

For each color component in 10.8 fixed-point format, the GPU SHALL:
1. Extract the 8-bit integer part and relevant fractional bits
2. Add the scaled dither value to the fractional bits below the RGB565 threshold
3. If the addition carries into the integer part, increment the integer
4. Extract upper bits from integer part for RGB565: R[9:5], G[9:4], B[9:5]

This effectively rounds up or down based on the dither pattern, distributing quantization error spatially.

### FR-132-4: Dithering Control

The firmware SHALL be able to enable or disable dithering via the `DITHER_MODE` register (0x32):
- Bit 0 (ENABLE): 1 = dithering enabled (default), 0 = disabled
- When disabled, 10.8 values truncate directly to RGB565 without dithering

## Verification Method

**Demonstration:** The system SHALL meet the following acceptance criteria:

- [ ] Set DITHER_MODE register to enable/disable dithering
- [ ] Dithering applies to all framebuffer writes after alpha blending
- [ ] 16x16 blue noise dither matrix stored in EBR (1 block)
- [ ] Dither values scaled per-channel (3-bit for R/B, 2-bit for G)
- [ ] Smooth gradients visible in dithered RGB565 output (no banding)
- [ ] Dithering can be disabled for pixel-perfect rendering
- [ ] No visible tiling artifacts from 16x16 pattern at normal viewing distance
- [ ] Dithering is fully pipelined (1 cycle EBR read at 100 MHz / 10 ns, no throughput reduction)

## Notes

Blue noise dithering is preferred over Bayer or white noise because it minimizes low-frequency artifacts and pushes quantization noise to high frequencies (less perceptible to the human visual system). The 16x16 pattern is small enough to fit in 1 EBR while being large enough to avoid visible tiling in most content.

See DD-012 in design_decisions.md for architectural rationale.
