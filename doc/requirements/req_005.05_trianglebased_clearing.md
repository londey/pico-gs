# REQ-005.05: Triangle-Based Clearing

## Classification

- **Priority:** Important
- **Stability:** Stable
- **Verification:** Demonstration

## Requirement

When the host submits two screen-covering triangles with a solid vertex color and Z_COMPARE=ALWAYS, the system SHALL overwrite every pixel in the active framebuffer with that color and write the far-plane depth to the Z-buffer, achieving a full-screen clear in under 5 ms at 640×480 resolution.

## Rationale

MEM_FILL (REQ-005.08) is the preferred mechanism for full-buffer clears because it uses direct SDRAM burst writes and requires no rasterizer setup.
Triangle-based clearing remains useful for partial clears (clearing a sub-region defined by a scissor rectangle), gradient fills, or pattern fills where a constant fill value is insufficient.

## Parent Requirements

- REQ-005 (Blend/Frame Buffer Store)

## Allocated To

- UNIT-006 (Pixel Pipeline)

## Interfaces

- INT-010 (GPU Register Map)

## Verification Method

**Demonstration:** The system SHALL meet the following acceptance criteria:

- [ ] Clear color buffer by rendering two triangles covering viewport with RENDER_MODE.Z_COMPARE=ALWAYS
- [ ] Clear Z-buffer by rendering triangles with RENDER_MODE.Z_COMPARE=ALWAYS and Z set to far-plane value
- [ ] Achieve clear performance comparable to MEM_FILL for full-screen triangles (<5 ms at 640×480)
- [ ] Support partial clears by setting the scissor rectangle (FB_CONTROL) to a sub-region
- [ ] Support pattern/gradient fills by varying vertex colors across the two triangles

---


## Notes

User Story: As a firmware developer, I want to clear framebuffer and z-buffer by rendering full-screen triangles, so that I have more flexible clearing with pattern fills and partial clears.

**Burst access for clears**: Full-screen triangle clears produce sequential pixel writes within each 4×4 block tile, then advance to the next block in row-major order.
The write-coalescing buffer (ARCHITECTURE.md) collects adjacent pixels within the same tile and issues a single SDRAM burst write per tile rather than individual single-word transactions.
Because both the framebuffer and Z-buffer use 4×4 block-tiled layout (see INT-011), the access pattern during a full-screen clear is burst-efficient: up to 16 consecutive 16-bit writes per tile fit within a single SDRAM row activation, amortizing row activation and CAS latency overhead.
