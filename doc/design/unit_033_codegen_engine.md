# UNIT-033: Codegen Engine

## Purpose

Rust source and binary data generation for compiled assets

## Implements Requirements

- REQ-200 (Unknown)
- REQ-201 (Unknown)
- REQ-202 (Asset Build Orchestration)

## Interfaces

### Provides

None

### Consumes

- INT-031 (Asset Binary Format)
- INT-014 (Texture Memory Layout)

### Internal Interfaces

- Called by UNIT-034 (Build.rs Orchestrator) via output generation functions
- Receives `TextureAsset` from UNIT-030 (PNG Decoder) and `MeshAsset` from UNIT-031 (OBJ Parser)
- Generates `.rs` wrapper files and `.bin` data files, plus a master `mod.rs`

## Design Description

### Inputs

- Compiled asset data (binary texture data, mesh data)
- Asset metadata (dimensions, format, source path)

### Outputs

- Rust source files (`.rs`) with const declarations
- Master `mod.rs` with TextureFormat enum and includes

### Internal State

None (stateless processing)

### Algorithm / Behavior

The codegen engine generates Rust source files for compiled assets:

1. **Scan compiled assets:** Enumerate `.bin` files in output directory
2. **Determine format:** From file extension or metadata
   - `*_rgba4444.bin` -> RGBA4444
   - `*_bc1.bin` -> BC1
3. **Generate wrapper:** Create `.rs` file with constants and metadata
4. **Generate mod.rs:** Master module file with TextureFormat enum and all asset includes

### Rust Template (Texture)

```rust
// Generated from: {source_path}
// Dimensions: {width}x{height}
// Format: {format}
// Size: {byte_count} bytes ({kb_size} KB)
// GPU Requirements: 4K-aligned base address

pub const {IDENTIFIER}_WIDTH: u32 = {width};
pub const {IDENTIFIER}_HEIGHT: u32 = {height};
pub const {IDENTIFIER}_FORMAT: TextureFormat = TextureFormat::{format};
pub const {IDENTIFIER}_DATA: &[u8] = include_bytes!("{bin_filename}");

// Per-patch mesh wrapper adds:
// pub const {IDENTIFIER}_PATCH{n}_VERTEX_COUNT: usize = {vertex_count};
// pub const {IDENTIFIER}_PATCH{n}_ENTRY_COUNT: usize = {entry_count};
// pub const {IDENTIFIER}_PATCH{n}_AABB_MIN: [f32; 3] = [{min_x}, {min_y}, {min_z}];
// pub const {IDENTIFIER}_PATCH{n}_AABB_MAX: [f32; 3] = [{max_x}, {max_y}, {max_z}];

// Usage in firmware:
// gpu.set_texture(0, {IDENTIFIER}_WIDTH, {IDENTIFIER}_HEIGHT,
//                  {IDENTIFIER}_FORMAT, {IDENTIFIER}_DATA);
```

### Master mod.rs Template

```rust
// Auto-generated by asset_build_tool - do not edit
// Source: host_app/assets/

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum TextureFormat {
    RGBA4444,
    BC1,
}

pub struct MeshPatchDescriptor {
    pub positions: &'static [u8],
    pub normals: &'static [u8],
    pub uvs: &'static [u8],
    pub indices: &'static [u8],
    pub aabb_min: [f32; 3],
    pub aabb_max: [f32; 3],
    pub vertex_count: usize,
    pub entry_count: usize,
}

// Texture includes
include!("textures_player.rs");
include!("textures_enemy.rs");
// ...

// Mesh includes
include!("meshes_cube_patch0.rs");
// ...

// Per-mesh descriptors
// pub const MESHES_CUBE_AABB_MIN: [f32; 3] = [...];
// pub const MESHES_CUBE_AABB_MAX: [f32; 3] = [...];
// pub const MESHES_CUBE_PATCH_COUNT: usize = N;
// pub const MESHES_CUBE_PATCHES: [MeshPatchDescriptor; N] = [ ... ];
```

## Implementation

- `crates/asset-build-tool/src/output_gen.rs`: Main implementation
- Update templates to include `TextureFormat` enum
- Add format detection logic based on file naming convention

## Verification

- Unit test: Generated Rust source compiles correctly
- Unit test: TextureFormat enum is included in mod.rs
- Integration test: Full asset pipeline generates valid Rust code

## Design Notes

Migrated from speckit module specification. Updated for RGBA4444/BC1 texture formats (v3.0).
