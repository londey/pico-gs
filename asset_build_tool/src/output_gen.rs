use crate::error::AssetError;
use crate::types::{GeneratedAsset, MeshAsset, TextureAsset};
use std::fs;
use std::io::Write;
use std::path::Path;

/// Write texture output files (.rs wrapper + .bin data) and return generated asset metadata.
pub fn write_texture_output(
    texture: &TextureAsset,
    out_dir: &Path,
) -> Result<Vec<GeneratedAsset>, AssetError> {
    let lower_id = texture.identifier.to_lowercase();
    let rs_filename = format!("{}.rs", lower_id);
    let bin_filename = format!("{}.bin", lower_id);

    let rs_path = out_dir.join(&rs_filename);
    let bin_path = out_dir.join(&bin_filename);

    // Write binary data (raw RGBA8888 pixels)
    fs::write(&bin_path, &texture.data)?;

    // Generate Rust wrapper
    let rust_source = format!(
        r#"// Generated from: {}
// Dimensions: {}Ã—{} RGBA8
// Size: {} bytes ({:.1} KB)
// GPU Requirements: 4K-aligned base address

pub const {id}_WIDTH: u32 = {w};
pub const {id}_HEIGHT: u32 = {h};
pub const {id}_DATA: &[u8] = include_bytes!("{bin}");
"#,
        texture.source.display(),
        texture.width,
        texture.height,
        texture.data.len(),
        texture.data.len() as f64 / 1024.0,
        id = texture.identifier,
        w = texture.width,
        h = texture.height,
        bin = bin_filename,
    );

    fs::write(&rs_path, rust_source)?;

    Ok(vec![GeneratedAsset {
        module_name: lower_id,
        identifier: texture.identifier.clone(),
        rs_path: rs_filename.into(),
        source_path: texture.source.clone(),
    }])
}

/// Write mesh output files (per-patch .rs wrappers + .bin data files).
pub fn write_mesh_output(
    mesh: &MeshAsset,
    out_dir: &Path,
) -> Result<Vec<GeneratedAsset>, AssetError> {
    let mut generated = Vec::new();

    for patch in &mesh.patches {
        let base_name = format!(
            "{}_patch{}",
            mesh.identifier.to_lowercase(),
            patch.patch_index
        );
        let rs_filename = format!("{}.rs", base_name);
        let pos_bin = format!("{}_pos.bin", base_name);
        let uv_bin = format!("{}_uv.bin", base_name);
        let norm_bin = format!("{}_norm.bin", base_name);
        let idx_bin = format!("{}_idx.bin", base_name);

        let const_name = format!("{}_PATCH{}", mesh.identifier, patch.patch_index);

        // Write binary files
        write_f32_binary(
            &out_dir.join(&pos_bin),
            &patch
                .vertices
                .iter()
                .flat_map(|v| v.position)
                .collect::<Vec<_>>(),
        )?;
        write_f32_binary(
            &out_dir.join(&uv_bin),
            &patch.vertices.iter().flat_map(|v| v.uv).collect::<Vec<_>>(),
        )?;
        write_f32_binary(
            &out_dir.join(&norm_bin),
            &patch
                .vertices
                .iter()
                .flat_map(|v| v.normal)
                .collect::<Vec<_>>(),
        )?;
        write_u16_binary(&out_dir.join(&idx_bin), &patch.indices)?;

        // Generate Rust wrapper
        let rust_source = format!(
            r#"// Generated from: {} (patch {} of {})
// Vertices: {}, Indices: {} ({} triangles)

pub const {c}_VERTEX_COUNT: usize = {vc};
pub const {c}_INDEX_COUNT: usize = {ic};

pub const {c}_POSITIONS: &[u8] = include_bytes!("{pos}");
pub const {c}_UVS: &[u8] = include_bytes!("{uv}");
pub const {c}_NORMALS: &[u8] = include_bytes!("{norm}");
pub const {c}_INDICES: &[u8] = include_bytes!("{idx}");
"#,
            mesh.source.display(),
            patch.patch_index,
            mesh.patches.len(),
            patch.vertices.len(),
            patch.indices.len(),
            patch.triangle_count(),
            c = const_name,
            vc = patch.vertices.len(),
            ic = patch.indices.len(),
            pos = pos_bin,
            uv = uv_bin,
            norm = norm_bin,
            idx = idx_bin,
        );

        fs::write(out_dir.join(&rs_filename), rust_source)?;

        generated.push(GeneratedAsset {
            module_name: base_name,
            identifier: const_name,
            rs_path: rs_filename.into(),
            source_path: mesh.source.clone(),
        });
    }

    Ok(generated)
}

/// Write the master `mod.rs` that includes all generated asset files.
pub fn write_mod_rs(generated: &[GeneratedAsset], out_dir: &Path) -> Result<(), AssetError> {
    let mod_path = out_dir.join("mod.rs");
    let mut file = fs::File::create(&mod_path)?;

    writeln!(file, "// Auto-generated by asset_build_tool - do not edit")?;
    writeln!(file)?;

    // Sort for deterministic output
    let mut rs_files: Vec<&str> = generated
        .iter()
        .map(|g| g.rs_path.to_str().unwrap_or(""))
        .collect();
    rs_files.sort();

    for rs_file in rs_files {
        if !rs_file.is_empty() {
            writeln!(file, "include!(\"{}\");", rs_file)?;
        }
    }

    Ok(())
}

/// Write a slice of f32 values as little-endian binary.
fn write_f32_binary(path: &Path, data: &[f32]) -> Result<(), AssetError> {
    let bytes: Vec<u8> = data.iter().flat_map(|&f| f.to_le_bytes()).collect();
    fs::write(path, bytes)?;
    Ok(())
}

/// Write a slice of u16 values as little-endian binary.
fn write_u16_binary(path: &Path, data: &[u16]) -> Result<(), AssetError> {
    let bytes: Vec<u8> = data.iter().flat_map(|&i| i.to_le_bytes()).collect();
    fs::write(path, bytes)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{MeshPatch, VertexData};
    use std::path::PathBuf;

    #[test]
    fn test_write_texture_output() {
        let dir = tempfile::tempdir().unwrap();
        let texture = TextureAsset {
            source: PathBuf::from("textures/test.png"),
            width: 8,
            height: 8,
            data: vec![0u8; 8 * 8 * 4],
            identifier: "TEXTURES_TEST".to_string(),
        };

        let result = write_texture_output(&texture, dir.path());
        assert!(result.is_ok());
        let generated = result.unwrap();
        assert_eq!(generated.len(), 1);
        assert_eq!(generated[0].identifier, "TEXTURES_TEST");

        // Check files exist
        assert!(dir.path().join("textures_test.rs").exists());
        assert!(dir.path().join("textures_test.bin").exists());

        // Check bin file size
        let bin_data = fs::read(dir.path().join("textures_test.bin")).unwrap();
        assert_eq!(bin_data.len(), 8 * 8 * 4);

        // Check rs file contains expected constants
        let rs_content = fs::read_to_string(dir.path().join("textures_test.rs")).unwrap();
        assert!(rs_content.contains("TEXTURES_TEST_WIDTH"));
        assert!(rs_content.contains("TEXTURES_TEST_HEIGHT"));
        assert!(rs_content.contains("TEXTURES_TEST_DATA"));
        assert!(rs_content.contains("include_bytes!"));
    }

    #[test]
    fn test_write_mesh_output() {
        let dir = tempfile::tempdir().unwrap();
        let mesh = MeshAsset {
            source: PathBuf::from("meshes/cube.obj"),
            patches: vec![MeshPatch {
                vertices: vec![
                    VertexData {
                        position: [0.0, 0.0, 0.0],
                        uv: [0.0, 0.0],
                        normal: [0.0, 1.0, 0.0],
                    },
                    VertexData {
                        position: [1.0, 0.0, 0.0],
                        uv: [1.0, 0.0],
                        normal: [0.0, 1.0, 0.0],
                    },
                    VertexData {
                        position: [0.0, 1.0, 0.0],
                        uv: [0.0, 1.0],
                        normal: [0.0, 1.0, 0.0],
                    },
                ],
                indices: vec![0, 1, 2],
                patch_index: 0,
            }],
            identifier: "MESHES_CUBE".to_string(),
            original_vertex_count: 3,
            original_triangle_count: 1,
        };

        let result = write_mesh_output(&mesh, dir.path());
        assert!(result.is_ok());
        let generated = result.unwrap();
        assert_eq!(generated.len(), 1);

        // Check files exist
        assert!(dir.path().join("meshes_cube_patch0.rs").exists());
        assert!(dir.path().join("meshes_cube_patch0_pos.bin").exists());
        assert!(dir.path().join("meshes_cube_patch0_uv.bin").exists());
        assert!(dir.path().join("meshes_cube_patch0_norm.bin").exists());
        assert!(dir.path().join("meshes_cube_patch0_idx.bin").exists());

        // Check binary sizes
        let pos_data = fs::read(dir.path().join("meshes_cube_patch0_pos.bin")).unwrap();
        assert_eq!(pos_data.len(), 3 * 3 * 4); // 3 vertices * 3 components * 4 bytes

        let idx_data = fs::read(dir.path().join("meshes_cube_patch0_idx.bin")).unwrap();
        assert_eq!(idx_data.len(), 3 * 2); // 3 indices * 2 bytes
    }

    #[test]
    fn test_write_mod_rs() {
        let dir = tempfile::tempdir().unwrap();
        let generated = vec![
            GeneratedAsset {
                module_name: "textures_player".to_string(),
                identifier: "TEXTURES_PLAYER".to_string(),
                rs_path: "textures_player.rs".into(),
                source_path: PathBuf::from("textures/player.png"),
            },
            GeneratedAsset {
                module_name: "meshes_cube_patch0".to_string(),
                identifier: "MESHES_CUBE_PATCH0".to_string(),
                rs_path: "meshes_cube_patch0.rs".into(),
                source_path: PathBuf::from("meshes/cube.obj"),
            },
        ];

        let result = write_mod_rs(&generated, dir.path());
        assert!(result.is_ok());

        let content = fs::read_to_string(dir.path().join("mod.rs")).unwrap();
        assert!(content.contains("Auto-generated"));
        assert!(content.contains(r#"include!("meshes_cube_patch0.rs")"#));
        assert!(content.contains(r#"include!("textures_player.rs")"#));
    }

    #[test]
    fn test_write_mod_rs_empty() {
        let dir = tempfile::tempdir().unwrap();
        let result = write_mod_rs(&[], dir.path());
        assert!(result.is_ok());

        let content = fs::read_to_string(dir.path().join("mod.rs")).unwrap();
        assert!(content.contains("Auto-generated"));
        assert!(!content.contains("include!"));
    }
}
