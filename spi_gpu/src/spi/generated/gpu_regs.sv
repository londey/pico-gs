// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module gpu_regs (
        input wire clk,
        input wire rst,

        input wire s_cpuif_req,
        input wire s_cpuif_req_is_wr,
        input wire [9:0] s_cpuif_addr,
        input wire [63:0] s_cpuif_wr_data,
        input wire [63:0] s_cpuif_wr_biten,
        output wire s_cpuif_req_stall_wr,
        output wire s_cpuif_req_stall_rd,
        output wire s_cpuif_rd_ack,
        output wire s_cpuif_rd_err,
        output wire [63:0] s_cpuif_rd_data,
        output wire s_cpuif_wr_ack,
        output wire s_cpuif_wr_err,

        output gpu_regs_pkg::gpu_regs__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [9:0] cpuif_addr;
    logic [63:0] cpuif_wr_data;
    logic [63:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [63:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    assign cpuif_req = s_cpuif_req;
    assign cpuif_req_is_wr = s_cpuif_req_is_wr;
    assign cpuif_addr = s_cpuif_addr;
    assign cpuif_wr_data = s_cpuif_wr_data;
    assign cpuif_wr_biten = s_cpuif_wr_biten;
    assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
    assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
    assign s_cpuif_rd_ack = cpuif_rd_ack;
    assign s_cpuif_rd_err = cpuif_rd_err;
    assign s_cpuif_rd_data = cpuif_rd_data;
    assign s_cpuif_wr_ack = cpuif_wr_ack;
    assign s_cpuif_wr_err = cpuif_wr_err;

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic COLOR;
        logic UV0_UV1;
        logic VERTEX_NOKICK;
        logic VERTEX_KICK_012;
        logic VERTEX_KICK_021;
        logic VERTEX_KICK_RECT;
        logic TEX0_CFG;
        logic TEX1_CFG;
        logic CC_MODE;
        logic CONST_COLOR;
        logic RENDER_MODE;
        logic Z_RANGE;
        logic STIPPLE_PATTERN;
        logic FB_CONFIG;
        logic FB_DISPLAY;
        logic FB_CONTROL;
        logic MEM_FILL;
        logic PERF_TEX0;
        logic PERF_TEX1;
        logic PERF_PIXELS;
        logic PERF_FRAGMENTS;
        logic PERF_STALL_VS;
        logic PERF_STALL_CT;
        logic MEM_ADDR;
        logic MEM_DATA;
        logic STATUS;
        logic ID;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_err;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [63:0] decoded_wr_data;
    logic [63:0] decoded_wr_biten;

    always_comb begin
        automatic logic is_valid_addr;
        automatic logic is_invalid_rw;
        is_valid_addr = '1; // No error checking on valid address access
        is_invalid_rw = '0;
        decoded_reg_strb.COLOR = cpuif_req_masked & (cpuif_addr == 10'h0);
        decoded_reg_strb.UV0_UV1 = cpuif_req_masked & (cpuif_addr == 10'h8);
        decoded_reg_strb.VERTEX_NOKICK = cpuif_req_masked & (cpuif_addr == 10'h30);
        decoded_reg_strb.VERTEX_KICK_012 = cpuif_req_masked & (cpuif_addr == 10'h38);
        decoded_reg_strb.VERTEX_KICK_021 = cpuif_req_masked & (cpuif_addr == 10'h40);
        decoded_reg_strb.VERTEX_KICK_RECT = cpuif_req_masked & (cpuif_addr == 10'h48);
        decoded_reg_strb.TEX0_CFG = cpuif_req_masked & (cpuif_addr == 10'h80);
        decoded_reg_strb.TEX1_CFG = cpuif_req_masked & (cpuif_addr == 10'h88);
        decoded_reg_strb.CC_MODE = cpuif_req_masked & (cpuif_addr == 10'hc0);
        decoded_reg_strb.CONST_COLOR = cpuif_req_masked & (cpuif_addr == 10'hc8);
        decoded_reg_strb.RENDER_MODE = cpuif_req_masked & (cpuif_addr == 10'h180);
        decoded_reg_strb.Z_RANGE = cpuif_req_masked & (cpuif_addr == 10'h188);
        decoded_reg_strb.STIPPLE_PATTERN = cpuif_req_masked & (cpuif_addr == 10'h190);
        decoded_reg_strb.FB_CONFIG = cpuif_req_masked & (cpuif_addr == 10'h200);
        decoded_reg_strb.FB_DISPLAY = cpuif_req_masked & (cpuif_addr == 10'h208);
        decoded_reg_strb.FB_CONTROL = cpuif_req_masked & (cpuif_addr == 10'h218);
        decoded_reg_strb.MEM_FILL = cpuif_req_masked & (cpuif_addr == 10'h220);
        decoded_reg_strb.PERF_TEX0 = cpuif_req_masked & (cpuif_addr == 10'h280) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_TEX1 = cpuif_req_masked & (cpuif_addr == 10'h288) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_PIXELS = cpuif_req_masked & (cpuif_addr == 10'h2a0) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_FRAGMENTS = cpuif_req_masked & (cpuif_addr == 10'h2a8) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_STALL_VS = cpuif_req_masked & (cpuif_addr == 10'h2b0) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_STALL_CT = cpuif_req_masked & (cpuif_addr == 10'h2b8) & !cpuif_req_is_wr;
        decoded_reg_strb.MEM_ADDR = cpuif_req_masked & (cpuif_addr == 10'h380);
        decoded_reg_strb.MEM_DATA = cpuif_req_masked & (cpuif_addr == 10'h388);
        decoded_reg_strb.STATUS = cpuif_req_masked & (cpuif_addr == 10'h3f0) & !cpuif_req_is_wr;
        decoded_reg_strb.ID = cpuif_req_masked & (cpuif_addr == 10'h3f8) & !cpuif_req_is_wr;
        decoded_err = (~is_valid_addr | is_invalid_rw) & decoded_req;
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_A;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_A;
        } COLOR;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } UV0_UQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV0_VQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV1_UQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV1_VQ;
        } UV0_UV1;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_NOKICK;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_KICK_012;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_KICK_021;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_KICK_RECT;
        struct {
            struct {
                logic next;
                logic load_next;
            } ENABLE;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic [1:0] next;
                logic load_next;
            } FILTER;
            struct {
                logic [2:0] next;
                logic load_next;
            } FORMAT;
            struct {
                logic next;
                logic load_next;
            } RSVD_7;
            struct {
                logic [3:0] next;
                logic load_next;
            } WIDTH_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } HEIGHT_LOG2;
            struct {
                logic [1:0] next;
                logic load_next;
            } U_WRAP;
            struct {
                logic [1:0] next;
                logic load_next;
            } V_WRAP;
            struct {
                logic [3:0] next;
                logic load_next;
            } MIP_LEVELS;
            struct {
                logic [7:0] next;
                logic load_next;
            } RSVD_MID;
            struct {
                logic [15:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [15:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX0_CFG;
        struct {
            struct {
                logic next;
                logic load_next;
            } ENABLE;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic [1:0] next;
                logic load_next;
            } FILTER;
            struct {
                logic [2:0] next;
                logic load_next;
            } FORMAT;
            struct {
                logic next;
                logic load_next;
            } RSVD_7;
            struct {
                logic [3:0] next;
                logic load_next;
            } WIDTH_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } HEIGHT_LOG2;
            struct {
                logic [1:0] next;
                logic load_next;
            } U_WRAP;
            struct {
                logic [1:0] next;
                logic load_next;
            } V_WRAP;
            struct {
                logic [3:0] next;
                logic load_next;
            } MIP_LEVELS;
            struct {
                logic [7:0] next;
                logic load_next;
            } RSVD_MID;
            struct {
                logic [15:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [15:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX1_CFG;
        struct {
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_RGB_A;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_RGB_B;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_RGB_C;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_RGB_D;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_ALPHA_A;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_ALPHA_B;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_ALPHA_C;
            struct {
                logic [3:0] next;
                logic load_next;
            } C0_ALPHA_D;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_RGB_A;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_RGB_B;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_RGB_C;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_RGB_D;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_ALPHA_A;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_ALPHA_B;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_ALPHA_C;
            struct {
                logic [3:0] next;
                logic load_next;
            } C1_ALPHA_D;
        } CC_MODE;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST0_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST0_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST0_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST0_A;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST1_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST1_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST1_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } CONST1_A;
        } CONST_COLOR;
        struct {
            struct {
                logic next;
                logic load_next;
            } GOURAUD;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic next;
                logic load_next;
            } Z_TEST_EN;
            struct {
                logic next;
                logic load_next;
            } Z_WRITE_EN;
            struct {
                logic next;
                logic load_next;
            } COLOR_WRITE_EN;
            struct {
                logic [1:0] next;
                logic load_next;
            } CULL_MODE;
            struct {
                logic [2:0] next;
                logic load_next;
            } ALPHA_BLEND;
            struct {
                logic next;
                logic load_next;
            } DITHER_EN;
            struct {
                logic [1:0] next;
                logic load_next;
            } DITHER_PATTERN;
            struct {
                logic [2:0] next;
                logic load_next;
            } Z_COMPARE;
            struct {
                logic next;
                logic load_next;
            } STIPPLE_EN;
            struct {
                logic [1:0] next;
                logic load_next;
            } ALPHA_TEST_FUNC;
            struct {
                logic [7:0] next;
                logic load_next;
            } ALPHA_REF;
            struct {
                logic [36:0] next;
                logic load_next;
            } RSVD_HI;
        } RENDER_MODE;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } Z_RANGE_MIN;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z_RANGE_MAX;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } Z_RANGE;
        struct {
            struct {
                logic [63:0] next;
                logic load_next;
            } PATTERN;
        } STIPPLE_PATTERN;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } COLOR_BASE;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z_BASE;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } FB_CONFIG;
        struct {
            struct {
                logic next;
                logic load_next;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [14:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [15:0] next;
                logic load_next;
            } LUT_ADDR;
            struct {
                logic [15:0] next;
                logic load_next;
            } FB_ADDR;
            struct {
                logic [15:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_DISPLAY;
        struct {
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_X;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_Y;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_WIDTH;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_HEIGHT;
            struct {
                logic next;
                logic load_next;
            } Z_WRITE_EN_OVERRIDE;
            struct {
                logic next;
                logic load_next;
            } RSVD_41;
            struct {
                logic next;
                logic load_next;
            } STENCIL_WRITE_EN;
            struct {
                logic [20:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_CONTROL;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } FILL_BASE;
            struct {
                logic [15:0] next;
                logic load_next;
            } FILL_VALUE;
            struct {
                logic [19:0] next;
                logic load_next;
            } FILL_COUNT;
            struct {
                logic [11:0] next;
                logic load_next;
            } RSVD;
        } MEM_FILL;
        struct {
            struct {
                logic [21:0] next;
                logic load_next;
            } ADDR;
            struct {
                logic [41:0] next;
                logic load_next;
            } RSVD;
        } MEM_ADDR;
        struct {
            struct {
                logic [63:0] next;
                logic load_next;
            } DATA;
        } MEM_DATA;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [7:0] value;
            } COLOR0_R;
            struct {
                logic [7:0] value;
            } COLOR0_G;
            struct {
                logic [7:0] value;
            } COLOR0_B;
            struct {
                logic [7:0] value;
            } COLOR0_A;
            struct {
                logic [7:0] value;
            } COLOR1_R;
            struct {
                logic [7:0] value;
            } COLOR1_G;
            struct {
                logic [7:0] value;
            } COLOR1_B;
            struct {
                logic [7:0] value;
            } COLOR1_A;
        } COLOR;
        struct {
            struct {
                logic [15:0] value;
            } UV0_UQ;
            struct {
                logic [15:0] value;
            } UV0_VQ;
            struct {
                logic [15:0] value;
            } UV1_UQ;
            struct {
                logic [15:0] value;
            } UV1_VQ;
        } UV0_UV1;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_NOKICK;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_KICK_012;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_KICK_021;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_KICK_RECT;
        struct {
            struct {
                logic value;
            } ENABLE;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic [1:0] value;
            } FILTER;
            struct {
                logic [2:0] value;
            } FORMAT;
            struct {
                logic value;
            } RSVD_7;
            struct {
                logic [3:0] value;
            } WIDTH_LOG2;
            struct {
                logic [3:0] value;
            } HEIGHT_LOG2;
            struct {
                logic [1:0] value;
            } U_WRAP;
            struct {
                logic [1:0] value;
            } V_WRAP;
            struct {
                logic [3:0] value;
            } MIP_LEVELS;
            struct {
                logic [7:0] value;
            } RSVD_MID;
            struct {
                logic [15:0] value;
            } BASE_ADDR;
            struct {
                logic [15:0] value;
            } RSVD_HI;
        } TEX0_CFG;
        struct {
            struct {
                logic value;
            } ENABLE;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic [1:0] value;
            } FILTER;
            struct {
                logic [2:0] value;
            } FORMAT;
            struct {
                logic value;
            } RSVD_7;
            struct {
                logic [3:0] value;
            } WIDTH_LOG2;
            struct {
                logic [3:0] value;
            } HEIGHT_LOG2;
            struct {
                logic [1:0] value;
            } U_WRAP;
            struct {
                logic [1:0] value;
            } V_WRAP;
            struct {
                logic [3:0] value;
            } MIP_LEVELS;
            struct {
                logic [7:0] value;
            } RSVD_MID;
            struct {
                logic [15:0] value;
            } BASE_ADDR;
            struct {
                logic [15:0] value;
            } RSVD_HI;
        } TEX1_CFG;
        struct {
            struct {
                logic [3:0] value;
            } C0_RGB_A;
            struct {
                logic [3:0] value;
            } C0_RGB_B;
            struct {
                logic [3:0] value;
            } C0_RGB_C;
            struct {
                logic [3:0] value;
            } C0_RGB_D;
            struct {
                logic [3:0] value;
            } C0_ALPHA_A;
            struct {
                logic [3:0] value;
            } C0_ALPHA_B;
            struct {
                logic [3:0] value;
            } C0_ALPHA_C;
            struct {
                logic [3:0] value;
            } C0_ALPHA_D;
            struct {
                logic [3:0] value;
            } C1_RGB_A;
            struct {
                logic [3:0] value;
            } C1_RGB_B;
            struct {
                logic [3:0] value;
            } C1_RGB_C;
            struct {
                logic [3:0] value;
            } C1_RGB_D;
            struct {
                logic [3:0] value;
            } C1_ALPHA_A;
            struct {
                logic [3:0] value;
            } C1_ALPHA_B;
            struct {
                logic [3:0] value;
            } C1_ALPHA_C;
            struct {
                logic [3:0] value;
            } C1_ALPHA_D;
        } CC_MODE;
        struct {
            struct {
                logic [7:0] value;
            } CONST0_R;
            struct {
                logic [7:0] value;
            } CONST0_G;
            struct {
                logic [7:0] value;
            } CONST0_B;
            struct {
                logic [7:0] value;
            } CONST0_A;
            struct {
                logic [7:0] value;
            } CONST1_R;
            struct {
                logic [7:0] value;
            } CONST1_G;
            struct {
                logic [7:0] value;
            } CONST1_B;
            struct {
                logic [7:0] value;
            } CONST1_A;
        } CONST_COLOR;
        struct {
            struct {
                logic value;
            } GOURAUD;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic value;
            } Z_TEST_EN;
            struct {
                logic value;
            } Z_WRITE_EN;
            struct {
                logic value;
            } COLOR_WRITE_EN;
            struct {
                logic [1:0] value;
            } CULL_MODE;
            struct {
                logic [2:0] value;
            } ALPHA_BLEND;
            struct {
                logic value;
            } DITHER_EN;
            struct {
                logic [1:0] value;
            } DITHER_PATTERN;
            struct {
                logic [2:0] value;
            } Z_COMPARE;
            struct {
                logic value;
            } STIPPLE_EN;
            struct {
                logic [1:0] value;
            } ALPHA_TEST_FUNC;
            struct {
                logic [7:0] value;
            } ALPHA_REF;
            struct {
                logic [36:0] value;
            } RSVD_HI;
        } RENDER_MODE;
        struct {
            struct {
                logic [15:0] value;
            } Z_RANGE_MIN;
            struct {
                logic [15:0] value;
            } Z_RANGE_MAX;
            struct {
                logic [31:0] value;
            } RSVD;
        } Z_RANGE;
        struct {
            struct {
                logic [63:0] value;
            } PATTERN;
        } STIPPLE_PATTERN;
        struct {
            struct {
                logic [15:0] value;
            } COLOR_BASE;
            struct {
                logic [15:0] value;
            } Z_BASE;
            struct {
                logic [31:0] value;
            } RSVD;
        } FB_CONFIG;
        struct {
            struct {
                logic value;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [14:0] value;
            } RSVD_LO;
            struct {
                logic [15:0] value;
            } LUT_ADDR;
            struct {
                logic [15:0] value;
            } FB_ADDR;
            struct {
                logic [15:0] value;
            } RSVD_HI;
        } FB_DISPLAY;
        struct {
            struct {
                logic [9:0] value;
            } SCISSOR_X;
            struct {
                logic [9:0] value;
            } SCISSOR_Y;
            struct {
                logic [9:0] value;
            } SCISSOR_WIDTH;
            struct {
                logic [9:0] value;
            } SCISSOR_HEIGHT;
            struct {
                logic value;
            } Z_WRITE_EN_OVERRIDE;
            struct {
                logic value;
            } RSVD_41;
            struct {
                logic value;
            } STENCIL_WRITE_EN;
            struct {
                logic [20:0] value;
            } RSVD_HI;
        } FB_CONTROL;
        struct {
            struct {
                logic [15:0] value;
            } FILL_BASE;
            struct {
                logic [15:0] value;
            } FILL_VALUE;
            struct {
                logic [19:0] value;
            } FILL_COUNT;
            struct {
                logic [11:0] value;
            } RSVD;
        } MEM_FILL;
        struct {
            struct {
                logic [21:0] value;
            } ADDR;
            struct {
                logic [41:0] value;
            } RSVD;
        } MEM_ADDR;
        struct {
            struct {
                logic [63:0] value;
            } DATA;
        } MEM_DATA;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: gpu_regs.COLOR.COLOR0_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_R.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_R.next = next_c;
        field_combo.COLOR.COLOR0_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_R.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_R.load_next) begin
                field_storage.COLOR.COLOR0_R.value <= field_combo.COLOR.COLOR0_R.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_R.value = field_storage.COLOR.COLOR0_R.value;
    // Field: gpu_regs.COLOR.COLOR0_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_G.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_G.next = next_c;
        field_combo.COLOR.COLOR0_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_G.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_G.load_next) begin
                field_storage.COLOR.COLOR0_G.value <= field_combo.COLOR.COLOR0_G.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_G.value = field_storage.COLOR.COLOR0_G.value;
    // Field: gpu_regs.COLOR.COLOR0_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_B.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_B.next = next_c;
        field_combo.COLOR.COLOR0_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_B.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_B.load_next) begin
                field_storage.COLOR.COLOR0_B.value <= field_combo.COLOR.COLOR0_B.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_B.value = field_storage.COLOR.COLOR0_B.value;
    // Field: gpu_regs.COLOR.COLOR0_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_A.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_A.next = next_c;
        field_combo.COLOR.COLOR0_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_A.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_A.load_next) begin
                field_storage.COLOR.COLOR0_A.value <= field_combo.COLOR.COLOR0_A.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_A.value = field_storage.COLOR.COLOR0_A.value;
    // Field: gpu_regs.COLOR.COLOR1_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_R.value & ~decoded_wr_biten[39:32]) | (decoded_wr_data[39:32] & decoded_wr_biten[39:32]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_R.next = next_c;
        field_combo.COLOR.COLOR1_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_R.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_R.load_next) begin
                field_storage.COLOR.COLOR1_R.value <= field_combo.COLOR.COLOR1_R.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_R.value = field_storage.COLOR.COLOR1_R.value;
    // Field: gpu_regs.COLOR.COLOR1_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_G.value & ~decoded_wr_biten[47:40]) | (decoded_wr_data[47:40] & decoded_wr_biten[47:40]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_G.next = next_c;
        field_combo.COLOR.COLOR1_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_G.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_G.load_next) begin
                field_storage.COLOR.COLOR1_G.value <= field_combo.COLOR.COLOR1_G.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_G.value = field_storage.COLOR.COLOR1_G.value;
    // Field: gpu_regs.COLOR.COLOR1_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_B.value & ~decoded_wr_biten[55:48]) | (decoded_wr_data[55:48] & decoded_wr_biten[55:48]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_B.next = next_c;
        field_combo.COLOR.COLOR1_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_B.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_B.load_next) begin
                field_storage.COLOR.COLOR1_B.value <= field_combo.COLOR.COLOR1_B.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_B.value = field_storage.COLOR.COLOR1_B.value;
    // Field: gpu_regs.COLOR.COLOR1_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_A.value & ~decoded_wr_biten[63:56]) | (decoded_wr_data[63:56] & decoded_wr_biten[63:56]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_A.next = next_c;
        field_combo.COLOR.COLOR1_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_A.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_A.load_next) begin
                field_storage.COLOR.COLOR1_A.value <= field_combo.COLOR.COLOR1_A.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_A.value = field_storage.COLOR.COLOR1_A.value;
    // Field: gpu_regs.UV0_UV1.UV0_UQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV0_UQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV0_UQ.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV0_UQ.next = next_c;
        field_combo.UV0_UV1.UV0_UQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV0_UQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV0_UQ.load_next) begin
                field_storage.UV0_UV1.UV0_UQ.value <= field_combo.UV0_UV1.UV0_UQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV0_UQ.value = field_storage.UV0_UV1.UV0_UQ.value;
    // Field: gpu_regs.UV0_UV1.UV0_VQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV0_VQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV0_VQ.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV0_VQ.next = next_c;
        field_combo.UV0_UV1.UV0_VQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV0_VQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV0_VQ.load_next) begin
                field_storage.UV0_UV1.UV0_VQ.value <= field_combo.UV0_UV1.UV0_VQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV0_VQ.value = field_storage.UV0_UV1.UV0_VQ.value;
    // Field: gpu_regs.UV0_UV1.UV1_UQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV1_UQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV1_UQ.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV1_UQ.next = next_c;
        field_combo.UV0_UV1.UV1_UQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV1_UQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV1_UQ.load_next) begin
                field_storage.UV0_UV1.UV1_UQ.value <= field_combo.UV0_UV1.UV1_UQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV1_UQ.value = field_storage.UV0_UV1.UV1_UQ.value;
    // Field: gpu_regs.UV0_UV1.UV1_VQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV1_VQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV1_VQ.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV1_VQ.next = next_c;
        field_combo.UV0_UV1.UV1_VQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV1_VQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV1_VQ.load_next) begin
                field_storage.UV0_UV1.UV1_VQ.value <= field_combo.UV0_UV1.UV1_VQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV1_VQ.value = field_storage.UV0_UV1.UV1_VQ.value;
    // Field: gpu_regs.VERTEX_NOKICK.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.X.next = next_c;
        field_combo.VERTEX_NOKICK.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.X.load_next) begin
                field_storage.VERTEX_NOKICK.X.value <= field_combo.VERTEX_NOKICK.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.X.value = field_storage.VERTEX_NOKICK.X.value;
    // Field: gpu_regs.VERTEX_NOKICK.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Y.next = next_c;
        field_combo.VERTEX_NOKICK.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Y.load_next) begin
                field_storage.VERTEX_NOKICK.Y.value <= field_combo.VERTEX_NOKICK.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Y.value = field_storage.VERTEX_NOKICK.Y.value;
    // Field: gpu_regs.VERTEX_NOKICK.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Z.next = next_c;
        field_combo.VERTEX_NOKICK.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Z.load_next) begin
                field_storage.VERTEX_NOKICK.Z.value <= field_combo.VERTEX_NOKICK.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Z.value = field_storage.VERTEX_NOKICK.Z.value;
    // Field: gpu_regs.VERTEX_NOKICK.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Q.next = next_c;
        field_combo.VERTEX_NOKICK.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Q.load_next) begin
                field_storage.VERTEX_NOKICK.Q.value <= field_combo.VERTEX_NOKICK.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Q.value = field_storage.VERTEX_NOKICK.Q.value;
    // Field: gpu_regs.VERTEX_KICK_012.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.X.next = next_c;
        field_combo.VERTEX_KICK_012.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.X.load_next) begin
                field_storage.VERTEX_KICK_012.X.value <= field_combo.VERTEX_KICK_012.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.X.value = field_storage.VERTEX_KICK_012.X.value;
    // Field: gpu_regs.VERTEX_KICK_012.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Y.next = next_c;
        field_combo.VERTEX_KICK_012.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Y.load_next) begin
                field_storage.VERTEX_KICK_012.Y.value <= field_combo.VERTEX_KICK_012.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Y.value = field_storage.VERTEX_KICK_012.Y.value;
    // Field: gpu_regs.VERTEX_KICK_012.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Z.next = next_c;
        field_combo.VERTEX_KICK_012.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Z.load_next) begin
                field_storage.VERTEX_KICK_012.Z.value <= field_combo.VERTEX_KICK_012.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Z.value = field_storage.VERTEX_KICK_012.Z.value;
    // Field: gpu_regs.VERTEX_KICK_012.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Q.next = next_c;
        field_combo.VERTEX_KICK_012.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Q.load_next) begin
                field_storage.VERTEX_KICK_012.Q.value <= field_combo.VERTEX_KICK_012.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Q.value = field_storage.VERTEX_KICK_012.Q.value;
    // Field: gpu_regs.VERTEX_KICK_021.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.X.next = next_c;
        field_combo.VERTEX_KICK_021.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.X.load_next) begin
                field_storage.VERTEX_KICK_021.X.value <= field_combo.VERTEX_KICK_021.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.X.value = field_storage.VERTEX_KICK_021.X.value;
    // Field: gpu_regs.VERTEX_KICK_021.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Y.next = next_c;
        field_combo.VERTEX_KICK_021.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Y.load_next) begin
                field_storage.VERTEX_KICK_021.Y.value <= field_combo.VERTEX_KICK_021.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Y.value = field_storage.VERTEX_KICK_021.Y.value;
    // Field: gpu_regs.VERTEX_KICK_021.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Z.next = next_c;
        field_combo.VERTEX_KICK_021.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Z.load_next) begin
                field_storage.VERTEX_KICK_021.Z.value <= field_combo.VERTEX_KICK_021.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Z.value = field_storage.VERTEX_KICK_021.Z.value;
    // Field: gpu_regs.VERTEX_KICK_021.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Q.next = next_c;
        field_combo.VERTEX_KICK_021.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Q.load_next) begin
                field_storage.VERTEX_KICK_021.Q.value <= field_combo.VERTEX_KICK_021.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Q.value = field_storage.VERTEX_KICK_021.Q.value;
    // Field: gpu_regs.VERTEX_KICK_RECT.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_RECT.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_RECT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_RECT.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_RECT.X.next = next_c;
        field_combo.VERTEX_KICK_RECT.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_RECT.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_RECT.X.load_next) begin
                field_storage.VERTEX_KICK_RECT.X.value <= field_combo.VERTEX_KICK_RECT.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_RECT.X.value = field_storage.VERTEX_KICK_RECT.X.value;
    // Field: gpu_regs.VERTEX_KICK_RECT.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_RECT.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_RECT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_RECT.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_RECT.Y.next = next_c;
        field_combo.VERTEX_KICK_RECT.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_RECT.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_RECT.Y.load_next) begin
                field_storage.VERTEX_KICK_RECT.Y.value <= field_combo.VERTEX_KICK_RECT.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_RECT.Y.value = field_storage.VERTEX_KICK_RECT.Y.value;
    // Field: gpu_regs.VERTEX_KICK_RECT.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_RECT.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_RECT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_RECT.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_RECT.Z.next = next_c;
        field_combo.VERTEX_KICK_RECT.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_RECT.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_RECT.Z.load_next) begin
                field_storage.VERTEX_KICK_RECT.Z.value <= field_combo.VERTEX_KICK_RECT.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_RECT.Z.value = field_storage.VERTEX_KICK_RECT.Z.value;
    // Field: gpu_regs.VERTEX_KICK_RECT.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_RECT.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_RECT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_RECT.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_RECT.Q.next = next_c;
        field_combo.VERTEX_KICK_RECT.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_RECT.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_RECT.Q.load_next) begin
                field_storage.VERTEX_KICK_RECT.Q.value <= field_combo.VERTEX_KICK_RECT.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_RECT.Q.value = field_storage.VERTEX_KICK_RECT.Q.value;
    // Field: gpu_regs.TEX0_CFG.ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.ENABLE.next = next_c;
        field_combo.TEX0_CFG.ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.TEX0_CFG.ENABLE.load_next) begin
                field_storage.TEX0_CFG.ENABLE.value <= field_combo.TEX0_CFG.ENABLE.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.ENABLE.value = field_storage.TEX0_CFG.ENABLE.value;
    // Field: gpu_regs.TEX0_CFG.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.RSVD_1.next = next_c;
        field_combo.TEX0_CFG.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.TEX0_CFG.RSVD_1.load_next) begin
                field_storage.TEX0_CFG.RSVD_1.value <= field_combo.TEX0_CFG.RSVD_1.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.RSVD_1.value = field_storage.TEX0_CFG.RSVD_1.value;
    // Field: gpu_regs.TEX0_CFG.FILTER
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.FILTER.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.FILTER.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.FILTER.next = next_c;
        field_combo.TEX0_CFG.FILTER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.FILTER.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_CFG.FILTER.load_next) begin
                field_storage.TEX0_CFG.FILTER.value <= field_combo.TEX0_CFG.FILTER.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.FILTER.value = field_storage.TEX0_CFG.FILTER.value;
    // Field: gpu_regs.TEX0_CFG.FORMAT
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.FORMAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.FORMAT.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.FORMAT.next = next_c;
        field_combo.TEX0_CFG.FORMAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.FORMAT.value <= 3'h0;
        end else begin
            if(field_combo.TEX0_CFG.FORMAT.load_next) begin
                field_storage.TEX0_CFG.FORMAT.value <= field_combo.TEX0_CFG.FORMAT.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.FORMAT.value = field_storage.TEX0_CFG.FORMAT.value;
    // Field: gpu_regs.TEX0_CFG.RSVD_7
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.RSVD_7.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.RSVD_7.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.RSVD_7.next = next_c;
        field_combo.TEX0_CFG.RSVD_7.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.RSVD_7.value <= 1'h0;
        end else begin
            if(field_combo.TEX0_CFG.RSVD_7.load_next) begin
                field_storage.TEX0_CFG.RSVD_7.value <= field_combo.TEX0_CFG.RSVD_7.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.RSVD_7.value = field_storage.TEX0_CFG.RSVD_7.value;
    // Field: gpu_regs.TEX0_CFG.WIDTH_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.WIDTH_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.WIDTH_LOG2.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.WIDTH_LOG2.next = next_c;
        field_combo.TEX0_CFG.WIDTH_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.WIDTH_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_CFG.WIDTH_LOG2.load_next) begin
                field_storage.TEX0_CFG.WIDTH_LOG2.value <= field_combo.TEX0_CFG.WIDTH_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.WIDTH_LOG2.value = field_storage.TEX0_CFG.WIDTH_LOG2.value;
    // Field: gpu_regs.TEX0_CFG.HEIGHT_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.HEIGHT_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.HEIGHT_LOG2.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.HEIGHT_LOG2.next = next_c;
        field_combo.TEX0_CFG.HEIGHT_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.HEIGHT_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_CFG.HEIGHT_LOG2.load_next) begin
                field_storage.TEX0_CFG.HEIGHT_LOG2.value <= field_combo.TEX0_CFG.HEIGHT_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.HEIGHT_LOG2.value = field_storage.TEX0_CFG.HEIGHT_LOG2.value;
    // Field: gpu_regs.TEX0_CFG.U_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.U_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.U_WRAP.value & ~decoded_wr_biten[17:16]) | (decoded_wr_data[17:16] & decoded_wr_biten[17:16]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.U_WRAP.next = next_c;
        field_combo.TEX0_CFG.U_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.U_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_CFG.U_WRAP.load_next) begin
                field_storage.TEX0_CFG.U_WRAP.value <= field_combo.TEX0_CFG.U_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.U_WRAP.value = field_storage.TEX0_CFG.U_WRAP.value;
    // Field: gpu_regs.TEX0_CFG.V_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.V_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.V_WRAP.value & ~decoded_wr_biten[19:18]) | (decoded_wr_data[19:18] & decoded_wr_biten[19:18]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.V_WRAP.next = next_c;
        field_combo.TEX0_CFG.V_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.V_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_CFG.V_WRAP.load_next) begin
                field_storage.TEX0_CFG.V_WRAP.value <= field_combo.TEX0_CFG.V_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.V_WRAP.value = field_storage.TEX0_CFG.V_WRAP.value;
    // Field: gpu_regs.TEX0_CFG.MIP_LEVELS
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.MIP_LEVELS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.MIP_LEVELS.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.MIP_LEVELS.next = next_c;
        field_combo.TEX0_CFG.MIP_LEVELS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.MIP_LEVELS.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_CFG.MIP_LEVELS.load_next) begin
                field_storage.TEX0_CFG.MIP_LEVELS.value <= field_combo.TEX0_CFG.MIP_LEVELS.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.MIP_LEVELS.value = field_storage.TEX0_CFG.MIP_LEVELS.value;
    // Field: gpu_regs.TEX0_CFG.RSVD_MID
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.RSVD_MID.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.RSVD_MID.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.RSVD_MID.next = next_c;
        field_combo.TEX0_CFG.RSVD_MID.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.RSVD_MID.value <= 8'h0;
        end else begin
            if(field_combo.TEX0_CFG.RSVD_MID.load_next) begin
                field_storage.TEX0_CFG.RSVD_MID.value <= field_combo.TEX0_CFG.RSVD_MID.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.RSVD_MID.value = field_storage.TEX0_CFG.RSVD_MID.value;
    // Field: gpu_regs.TEX0_CFG.BASE_ADDR
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.BASE_ADDR.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.BASE_ADDR.next = next_c;
        field_combo.TEX0_CFG.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.BASE_ADDR.value <= 16'h0;
        end else begin
            if(field_combo.TEX0_CFG.BASE_ADDR.load_next) begin
                field_storage.TEX0_CFG.BASE_ADDR.value <= field_combo.TEX0_CFG.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.BASE_ADDR.value = field_storage.TEX0_CFG.BASE_ADDR.value;
    // Field: gpu_regs.TEX0_CFG.RSVD_HI
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_CFG.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_CFG.RSVD_HI.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.TEX0_CFG.RSVD_HI.next = next_c;
        field_combo.TEX0_CFG.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_CFG.RSVD_HI.value <= 16'h0;
        end else begin
            if(field_combo.TEX0_CFG.RSVD_HI.load_next) begin
                field_storage.TEX0_CFG.RSVD_HI.value <= field_combo.TEX0_CFG.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX0_CFG.RSVD_HI.value = field_storage.TEX0_CFG.RSVD_HI.value;
    // Field: gpu_regs.TEX1_CFG.ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.ENABLE.next = next_c;
        field_combo.TEX1_CFG.ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.TEX1_CFG.ENABLE.load_next) begin
                field_storage.TEX1_CFG.ENABLE.value <= field_combo.TEX1_CFG.ENABLE.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.ENABLE.value = field_storage.TEX1_CFG.ENABLE.value;
    // Field: gpu_regs.TEX1_CFG.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.RSVD_1.next = next_c;
        field_combo.TEX1_CFG.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.TEX1_CFG.RSVD_1.load_next) begin
                field_storage.TEX1_CFG.RSVD_1.value <= field_combo.TEX1_CFG.RSVD_1.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.RSVD_1.value = field_storage.TEX1_CFG.RSVD_1.value;
    // Field: gpu_regs.TEX1_CFG.FILTER
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.FILTER.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.FILTER.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.FILTER.next = next_c;
        field_combo.TEX1_CFG.FILTER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.FILTER.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_CFG.FILTER.load_next) begin
                field_storage.TEX1_CFG.FILTER.value <= field_combo.TEX1_CFG.FILTER.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.FILTER.value = field_storage.TEX1_CFG.FILTER.value;
    // Field: gpu_regs.TEX1_CFG.FORMAT
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.FORMAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.FORMAT.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.FORMAT.next = next_c;
        field_combo.TEX1_CFG.FORMAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.FORMAT.value <= 3'h0;
        end else begin
            if(field_combo.TEX1_CFG.FORMAT.load_next) begin
                field_storage.TEX1_CFG.FORMAT.value <= field_combo.TEX1_CFG.FORMAT.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.FORMAT.value = field_storage.TEX1_CFG.FORMAT.value;
    // Field: gpu_regs.TEX1_CFG.RSVD_7
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.RSVD_7.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.RSVD_7.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.RSVD_7.next = next_c;
        field_combo.TEX1_CFG.RSVD_7.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.RSVD_7.value <= 1'h0;
        end else begin
            if(field_combo.TEX1_CFG.RSVD_7.load_next) begin
                field_storage.TEX1_CFG.RSVD_7.value <= field_combo.TEX1_CFG.RSVD_7.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.RSVD_7.value = field_storage.TEX1_CFG.RSVD_7.value;
    // Field: gpu_regs.TEX1_CFG.WIDTH_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.WIDTH_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.WIDTH_LOG2.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.WIDTH_LOG2.next = next_c;
        field_combo.TEX1_CFG.WIDTH_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.WIDTH_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_CFG.WIDTH_LOG2.load_next) begin
                field_storage.TEX1_CFG.WIDTH_LOG2.value <= field_combo.TEX1_CFG.WIDTH_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.WIDTH_LOG2.value = field_storage.TEX1_CFG.WIDTH_LOG2.value;
    // Field: gpu_regs.TEX1_CFG.HEIGHT_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.HEIGHT_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.HEIGHT_LOG2.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.HEIGHT_LOG2.next = next_c;
        field_combo.TEX1_CFG.HEIGHT_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.HEIGHT_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_CFG.HEIGHT_LOG2.load_next) begin
                field_storage.TEX1_CFG.HEIGHT_LOG2.value <= field_combo.TEX1_CFG.HEIGHT_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.HEIGHT_LOG2.value = field_storage.TEX1_CFG.HEIGHT_LOG2.value;
    // Field: gpu_regs.TEX1_CFG.U_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.U_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.U_WRAP.value & ~decoded_wr_biten[17:16]) | (decoded_wr_data[17:16] & decoded_wr_biten[17:16]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.U_WRAP.next = next_c;
        field_combo.TEX1_CFG.U_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.U_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_CFG.U_WRAP.load_next) begin
                field_storage.TEX1_CFG.U_WRAP.value <= field_combo.TEX1_CFG.U_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.U_WRAP.value = field_storage.TEX1_CFG.U_WRAP.value;
    // Field: gpu_regs.TEX1_CFG.V_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.V_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.V_WRAP.value & ~decoded_wr_biten[19:18]) | (decoded_wr_data[19:18] & decoded_wr_biten[19:18]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.V_WRAP.next = next_c;
        field_combo.TEX1_CFG.V_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.V_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_CFG.V_WRAP.load_next) begin
                field_storage.TEX1_CFG.V_WRAP.value <= field_combo.TEX1_CFG.V_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.V_WRAP.value = field_storage.TEX1_CFG.V_WRAP.value;
    // Field: gpu_regs.TEX1_CFG.MIP_LEVELS
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.MIP_LEVELS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.MIP_LEVELS.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.MIP_LEVELS.next = next_c;
        field_combo.TEX1_CFG.MIP_LEVELS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.MIP_LEVELS.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_CFG.MIP_LEVELS.load_next) begin
                field_storage.TEX1_CFG.MIP_LEVELS.value <= field_combo.TEX1_CFG.MIP_LEVELS.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.MIP_LEVELS.value = field_storage.TEX1_CFG.MIP_LEVELS.value;
    // Field: gpu_regs.TEX1_CFG.RSVD_MID
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.RSVD_MID.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.RSVD_MID.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.RSVD_MID.next = next_c;
        field_combo.TEX1_CFG.RSVD_MID.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.RSVD_MID.value <= 8'h0;
        end else begin
            if(field_combo.TEX1_CFG.RSVD_MID.load_next) begin
                field_storage.TEX1_CFG.RSVD_MID.value <= field_combo.TEX1_CFG.RSVD_MID.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.RSVD_MID.value = field_storage.TEX1_CFG.RSVD_MID.value;
    // Field: gpu_regs.TEX1_CFG.BASE_ADDR
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.BASE_ADDR.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.BASE_ADDR.next = next_c;
        field_combo.TEX1_CFG.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.BASE_ADDR.value <= 16'h0;
        end else begin
            if(field_combo.TEX1_CFG.BASE_ADDR.load_next) begin
                field_storage.TEX1_CFG.BASE_ADDR.value <= field_combo.TEX1_CFG.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.BASE_ADDR.value = field_storage.TEX1_CFG.BASE_ADDR.value;
    // Field: gpu_regs.TEX1_CFG.RSVD_HI
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_CFG.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_CFG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_CFG.RSVD_HI.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.TEX1_CFG.RSVD_HI.next = next_c;
        field_combo.TEX1_CFG.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_CFG.RSVD_HI.value <= 16'h0;
        end else begin
            if(field_combo.TEX1_CFG.RSVD_HI.load_next) begin
                field_storage.TEX1_CFG.RSVD_HI.value <= field_combo.TEX1_CFG.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX1_CFG.RSVD_HI.value = field_storage.TEX1_CFG.RSVD_HI.value;
    // Field: gpu_regs.CC_MODE.C0_RGB_A
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_RGB_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_RGB_A.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_RGB_A.next = next_c;
        field_combo.CC_MODE.C0_RGB_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_RGB_A.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_RGB_A.load_next) begin
                field_storage.CC_MODE.C0_RGB_A.value <= field_combo.CC_MODE.C0_RGB_A.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_RGB_A.value = field_storage.CC_MODE.C0_RGB_A.value;
    // Field: gpu_regs.CC_MODE.C0_RGB_B
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_RGB_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_RGB_B.value & ~decoded_wr_biten[7:4]) | (decoded_wr_data[7:4] & decoded_wr_biten[7:4]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_RGB_B.next = next_c;
        field_combo.CC_MODE.C0_RGB_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_RGB_B.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_RGB_B.load_next) begin
                field_storage.CC_MODE.C0_RGB_B.value <= field_combo.CC_MODE.C0_RGB_B.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_RGB_B.value = field_storage.CC_MODE.C0_RGB_B.value;
    // Field: gpu_regs.CC_MODE.C0_RGB_C
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_RGB_C.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_RGB_C.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_RGB_C.next = next_c;
        field_combo.CC_MODE.C0_RGB_C.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_RGB_C.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_RGB_C.load_next) begin
                field_storage.CC_MODE.C0_RGB_C.value <= field_combo.CC_MODE.C0_RGB_C.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_RGB_C.value = field_storage.CC_MODE.C0_RGB_C.value;
    // Field: gpu_regs.CC_MODE.C0_RGB_D
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_RGB_D.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_RGB_D.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_RGB_D.next = next_c;
        field_combo.CC_MODE.C0_RGB_D.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_RGB_D.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_RGB_D.load_next) begin
                field_storage.CC_MODE.C0_RGB_D.value <= field_combo.CC_MODE.C0_RGB_D.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_RGB_D.value = field_storage.CC_MODE.C0_RGB_D.value;
    // Field: gpu_regs.CC_MODE.C0_ALPHA_A
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_ALPHA_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_ALPHA_A.value & ~decoded_wr_biten[19:16]) | (decoded_wr_data[19:16] & decoded_wr_biten[19:16]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_ALPHA_A.next = next_c;
        field_combo.CC_MODE.C0_ALPHA_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_ALPHA_A.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_ALPHA_A.load_next) begin
                field_storage.CC_MODE.C0_ALPHA_A.value <= field_combo.CC_MODE.C0_ALPHA_A.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_ALPHA_A.value = field_storage.CC_MODE.C0_ALPHA_A.value;
    // Field: gpu_regs.CC_MODE.C0_ALPHA_B
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_ALPHA_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_ALPHA_B.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_ALPHA_B.next = next_c;
        field_combo.CC_MODE.C0_ALPHA_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_ALPHA_B.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_ALPHA_B.load_next) begin
                field_storage.CC_MODE.C0_ALPHA_B.value <= field_combo.CC_MODE.C0_ALPHA_B.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_ALPHA_B.value = field_storage.CC_MODE.C0_ALPHA_B.value;
    // Field: gpu_regs.CC_MODE.C0_ALPHA_C
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_ALPHA_C.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_ALPHA_C.value & ~decoded_wr_biten[27:24]) | (decoded_wr_data[27:24] & decoded_wr_biten[27:24]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_ALPHA_C.next = next_c;
        field_combo.CC_MODE.C0_ALPHA_C.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_ALPHA_C.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_ALPHA_C.load_next) begin
                field_storage.CC_MODE.C0_ALPHA_C.value <= field_combo.CC_MODE.C0_ALPHA_C.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_ALPHA_C.value = field_storage.CC_MODE.C0_ALPHA_C.value;
    // Field: gpu_regs.CC_MODE.C0_ALPHA_D
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C0_ALPHA_D.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C0_ALPHA_D.value & ~decoded_wr_biten[31:28]) | (decoded_wr_data[31:28] & decoded_wr_biten[31:28]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C0_ALPHA_D.next = next_c;
        field_combo.CC_MODE.C0_ALPHA_D.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C0_ALPHA_D.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C0_ALPHA_D.load_next) begin
                field_storage.CC_MODE.C0_ALPHA_D.value <= field_combo.CC_MODE.C0_ALPHA_D.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C0_ALPHA_D.value = field_storage.CC_MODE.C0_ALPHA_D.value;
    // Field: gpu_regs.CC_MODE.C1_RGB_A
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_RGB_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_RGB_A.value & ~decoded_wr_biten[35:32]) | (decoded_wr_data[35:32] & decoded_wr_biten[35:32]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_RGB_A.next = next_c;
        field_combo.CC_MODE.C1_RGB_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_RGB_A.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_RGB_A.load_next) begin
                field_storage.CC_MODE.C1_RGB_A.value <= field_combo.CC_MODE.C1_RGB_A.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_RGB_A.value = field_storage.CC_MODE.C1_RGB_A.value;
    // Field: gpu_regs.CC_MODE.C1_RGB_B
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_RGB_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_RGB_B.value & ~decoded_wr_biten[39:36]) | (decoded_wr_data[39:36] & decoded_wr_biten[39:36]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_RGB_B.next = next_c;
        field_combo.CC_MODE.C1_RGB_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_RGB_B.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_RGB_B.load_next) begin
                field_storage.CC_MODE.C1_RGB_B.value <= field_combo.CC_MODE.C1_RGB_B.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_RGB_B.value = field_storage.CC_MODE.C1_RGB_B.value;
    // Field: gpu_regs.CC_MODE.C1_RGB_C
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_RGB_C.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_RGB_C.value & ~decoded_wr_biten[43:40]) | (decoded_wr_data[43:40] & decoded_wr_biten[43:40]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_RGB_C.next = next_c;
        field_combo.CC_MODE.C1_RGB_C.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_RGB_C.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_RGB_C.load_next) begin
                field_storage.CC_MODE.C1_RGB_C.value <= field_combo.CC_MODE.C1_RGB_C.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_RGB_C.value = field_storage.CC_MODE.C1_RGB_C.value;
    // Field: gpu_regs.CC_MODE.C1_RGB_D
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_RGB_D.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_RGB_D.value & ~decoded_wr_biten[47:44]) | (decoded_wr_data[47:44] & decoded_wr_biten[47:44]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_RGB_D.next = next_c;
        field_combo.CC_MODE.C1_RGB_D.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_RGB_D.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_RGB_D.load_next) begin
                field_storage.CC_MODE.C1_RGB_D.value <= field_combo.CC_MODE.C1_RGB_D.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_RGB_D.value = field_storage.CC_MODE.C1_RGB_D.value;
    // Field: gpu_regs.CC_MODE.C1_ALPHA_A
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_ALPHA_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_ALPHA_A.value & ~decoded_wr_biten[51:48]) | (decoded_wr_data[51:48] & decoded_wr_biten[51:48]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_ALPHA_A.next = next_c;
        field_combo.CC_MODE.C1_ALPHA_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_ALPHA_A.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_ALPHA_A.load_next) begin
                field_storage.CC_MODE.C1_ALPHA_A.value <= field_combo.CC_MODE.C1_ALPHA_A.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_ALPHA_A.value = field_storage.CC_MODE.C1_ALPHA_A.value;
    // Field: gpu_regs.CC_MODE.C1_ALPHA_B
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_ALPHA_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_ALPHA_B.value & ~decoded_wr_biten[55:52]) | (decoded_wr_data[55:52] & decoded_wr_biten[55:52]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_ALPHA_B.next = next_c;
        field_combo.CC_MODE.C1_ALPHA_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_ALPHA_B.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_ALPHA_B.load_next) begin
                field_storage.CC_MODE.C1_ALPHA_B.value <= field_combo.CC_MODE.C1_ALPHA_B.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_ALPHA_B.value = field_storage.CC_MODE.C1_ALPHA_B.value;
    // Field: gpu_regs.CC_MODE.C1_ALPHA_C
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_ALPHA_C.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_ALPHA_C.value & ~decoded_wr_biten[59:56]) | (decoded_wr_data[59:56] & decoded_wr_biten[59:56]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_ALPHA_C.next = next_c;
        field_combo.CC_MODE.C1_ALPHA_C.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_ALPHA_C.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_ALPHA_C.load_next) begin
                field_storage.CC_MODE.C1_ALPHA_C.value <= field_combo.CC_MODE.C1_ALPHA_C.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_ALPHA_C.value = field_storage.CC_MODE.C1_ALPHA_C.value;
    // Field: gpu_regs.CC_MODE.C1_ALPHA_D
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.C1_ALPHA_D.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.C1_ALPHA_D.value & ~decoded_wr_biten[63:60]) | (decoded_wr_data[63:60] & decoded_wr_biten[63:60]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.C1_ALPHA_D.next = next_c;
        field_combo.CC_MODE.C1_ALPHA_D.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.C1_ALPHA_D.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.C1_ALPHA_D.load_next) begin
                field_storage.CC_MODE.C1_ALPHA_D.value <= field_combo.CC_MODE.C1_ALPHA_D.next;
            end
        end
    end
    assign hwif_out.CC_MODE.C1_ALPHA_D.value = field_storage.CC_MODE.C1_ALPHA_D.value;
    // Field: gpu_regs.CONST_COLOR.CONST0_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST0_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST0_R.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST0_R.next = next_c;
        field_combo.CONST_COLOR.CONST0_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST0_R.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST0_R.load_next) begin
                field_storage.CONST_COLOR.CONST0_R.value <= field_combo.CONST_COLOR.CONST0_R.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST0_R.value = field_storage.CONST_COLOR.CONST0_R.value;
    // Field: gpu_regs.CONST_COLOR.CONST0_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST0_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST0_G.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST0_G.next = next_c;
        field_combo.CONST_COLOR.CONST0_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST0_G.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST0_G.load_next) begin
                field_storage.CONST_COLOR.CONST0_G.value <= field_combo.CONST_COLOR.CONST0_G.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST0_G.value = field_storage.CONST_COLOR.CONST0_G.value;
    // Field: gpu_regs.CONST_COLOR.CONST0_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST0_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST0_B.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST0_B.next = next_c;
        field_combo.CONST_COLOR.CONST0_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST0_B.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST0_B.load_next) begin
                field_storage.CONST_COLOR.CONST0_B.value <= field_combo.CONST_COLOR.CONST0_B.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST0_B.value = field_storage.CONST_COLOR.CONST0_B.value;
    // Field: gpu_regs.CONST_COLOR.CONST0_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST0_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST0_A.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST0_A.next = next_c;
        field_combo.CONST_COLOR.CONST0_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST0_A.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST0_A.load_next) begin
                field_storage.CONST_COLOR.CONST0_A.value <= field_combo.CONST_COLOR.CONST0_A.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST0_A.value = field_storage.CONST_COLOR.CONST0_A.value;
    // Field: gpu_regs.CONST_COLOR.CONST1_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST1_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST1_R.value & ~decoded_wr_biten[39:32]) | (decoded_wr_data[39:32] & decoded_wr_biten[39:32]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST1_R.next = next_c;
        field_combo.CONST_COLOR.CONST1_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST1_R.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST1_R.load_next) begin
                field_storage.CONST_COLOR.CONST1_R.value <= field_combo.CONST_COLOR.CONST1_R.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST1_R.value = field_storage.CONST_COLOR.CONST1_R.value;
    // Field: gpu_regs.CONST_COLOR.CONST1_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST1_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST1_G.value & ~decoded_wr_biten[47:40]) | (decoded_wr_data[47:40] & decoded_wr_biten[47:40]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST1_G.next = next_c;
        field_combo.CONST_COLOR.CONST1_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST1_G.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST1_G.load_next) begin
                field_storage.CONST_COLOR.CONST1_G.value <= field_combo.CONST_COLOR.CONST1_G.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST1_G.value = field_storage.CONST_COLOR.CONST1_G.value;
    // Field: gpu_regs.CONST_COLOR.CONST1_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST1_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST1_B.value & ~decoded_wr_biten[55:48]) | (decoded_wr_data[55:48] & decoded_wr_biten[55:48]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST1_B.next = next_c;
        field_combo.CONST_COLOR.CONST1_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST1_B.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST1_B.load_next) begin
                field_storage.CONST_COLOR.CONST1_B.value <= field_combo.CONST_COLOR.CONST1_B.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST1_B.value = field_storage.CONST_COLOR.CONST1_B.value;
    // Field: gpu_regs.CONST_COLOR.CONST1_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CONST_COLOR.CONST1_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CONST_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CONST_COLOR.CONST1_A.value & ~decoded_wr_biten[63:56]) | (decoded_wr_data[63:56] & decoded_wr_biten[63:56]);
            load_next_c = '1;
        end
        field_combo.CONST_COLOR.CONST1_A.next = next_c;
        field_combo.CONST_COLOR.CONST1_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CONST_COLOR.CONST1_A.value <= 8'h0;
        end else begin
            if(field_combo.CONST_COLOR.CONST1_A.load_next) begin
                field_storage.CONST_COLOR.CONST1_A.value <= field_combo.CONST_COLOR.CONST1_A.next;
            end
        end
    end
    assign hwif_out.CONST_COLOR.CONST1_A.value = field_storage.CONST_COLOR.CONST1_A.value;
    // Field: gpu_regs.RENDER_MODE.GOURAUD
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.GOURAUD.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.GOURAUD.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.GOURAUD.next = next_c;
        field_combo.RENDER_MODE.GOURAUD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.GOURAUD.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.GOURAUD.load_next) begin
                field_storage.RENDER_MODE.GOURAUD.value <= field_combo.RENDER_MODE.GOURAUD.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.GOURAUD.value = field_storage.RENDER_MODE.GOURAUD.value;
    // Field: gpu_regs.RENDER_MODE.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.RSVD_1.next = next_c;
        field_combo.RENDER_MODE.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.RSVD_1.load_next) begin
                field_storage.RENDER_MODE.RSVD_1.value <= field_combo.RENDER_MODE.RSVD_1.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.RSVD_1.value = field_storage.RENDER_MODE.RSVD_1.value;
    // Field: gpu_regs.RENDER_MODE.Z_TEST_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_TEST_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_TEST_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_TEST_EN.next = next_c;
        field_combo.RENDER_MODE.Z_TEST_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_TEST_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_TEST_EN.load_next) begin
                field_storage.RENDER_MODE.Z_TEST_EN.value <= field_combo.RENDER_MODE.Z_TEST_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_TEST_EN.value = field_storage.RENDER_MODE.Z_TEST_EN.value;
    // Field: gpu_regs.RENDER_MODE.Z_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_WRITE_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_WRITE_EN.next = next_c;
        field_combo.RENDER_MODE.Z_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_WRITE_EN.load_next) begin
                field_storage.RENDER_MODE.Z_WRITE_EN.value <= field_combo.RENDER_MODE.Z_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_WRITE_EN.value = field_storage.RENDER_MODE.Z_WRITE_EN.value;
    // Field: gpu_regs.RENDER_MODE.COLOR_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.COLOR_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.COLOR_WRITE_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.COLOR_WRITE_EN.next = next_c;
        field_combo.RENDER_MODE.COLOR_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.COLOR_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.COLOR_WRITE_EN.load_next) begin
                field_storage.RENDER_MODE.COLOR_WRITE_EN.value <= field_combo.RENDER_MODE.COLOR_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.COLOR_WRITE_EN.value = field_storage.RENDER_MODE.COLOR_WRITE_EN.value;
    // Field: gpu_regs.RENDER_MODE.CULL_MODE
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.CULL_MODE.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.CULL_MODE.value & ~decoded_wr_biten[6:5]) | (decoded_wr_data[6:5] & decoded_wr_biten[6:5]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.CULL_MODE.next = next_c;
        field_combo.RENDER_MODE.CULL_MODE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.CULL_MODE.value <= 2'h0;
        end else begin
            if(field_combo.RENDER_MODE.CULL_MODE.load_next) begin
                field_storage.RENDER_MODE.CULL_MODE.value <= field_combo.RENDER_MODE.CULL_MODE.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.CULL_MODE.value = field_storage.RENDER_MODE.CULL_MODE.value;
    // Field: gpu_regs.RENDER_MODE.ALPHA_BLEND
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.ALPHA_BLEND.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.ALPHA_BLEND.value & ~decoded_wr_biten[9:7]) | (decoded_wr_data[9:7] & decoded_wr_biten[9:7]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.ALPHA_BLEND.next = next_c;
        field_combo.RENDER_MODE.ALPHA_BLEND.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.ALPHA_BLEND.value <= 3'h0;
        end else begin
            if(field_combo.RENDER_MODE.ALPHA_BLEND.load_next) begin
                field_storage.RENDER_MODE.ALPHA_BLEND.value <= field_combo.RENDER_MODE.ALPHA_BLEND.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.ALPHA_BLEND.value = field_storage.RENDER_MODE.ALPHA_BLEND.value;
    // Field: gpu_regs.RENDER_MODE.DITHER_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.DITHER_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.DITHER_EN.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.DITHER_EN.next = next_c;
        field_combo.RENDER_MODE.DITHER_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.DITHER_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.DITHER_EN.load_next) begin
                field_storage.RENDER_MODE.DITHER_EN.value <= field_combo.RENDER_MODE.DITHER_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.DITHER_EN.value = field_storage.RENDER_MODE.DITHER_EN.value;
    // Field: gpu_regs.RENDER_MODE.DITHER_PATTERN
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.DITHER_PATTERN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.DITHER_PATTERN.value & ~decoded_wr_biten[12:11]) | (decoded_wr_data[12:11] & decoded_wr_biten[12:11]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.DITHER_PATTERN.next = next_c;
        field_combo.RENDER_MODE.DITHER_PATTERN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.DITHER_PATTERN.value <= 2'h0;
        end else begin
            if(field_combo.RENDER_MODE.DITHER_PATTERN.load_next) begin
                field_storage.RENDER_MODE.DITHER_PATTERN.value <= field_combo.RENDER_MODE.DITHER_PATTERN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.DITHER_PATTERN.value = field_storage.RENDER_MODE.DITHER_PATTERN.value;
    // Field: gpu_regs.RENDER_MODE.Z_COMPARE
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_COMPARE.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_COMPARE.value & ~decoded_wr_biten[15:13]) | (decoded_wr_data[15:13] & decoded_wr_biten[15:13]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_COMPARE.next = next_c;
        field_combo.RENDER_MODE.Z_COMPARE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_COMPARE.value <= 3'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_COMPARE.load_next) begin
                field_storage.RENDER_MODE.Z_COMPARE.value <= field_combo.RENDER_MODE.Z_COMPARE.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_COMPARE.value = field_storage.RENDER_MODE.Z_COMPARE.value;
    // Field: gpu_regs.RENDER_MODE.STIPPLE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.STIPPLE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.STIPPLE_EN.value & ~decoded_wr_biten[16:16]) | (decoded_wr_data[16:16] & decoded_wr_biten[16:16]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.STIPPLE_EN.next = next_c;
        field_combo.RENDER_MODE.STIPPLE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.STIPPLE_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.STIPPLE_EN.load_next) begin
                field_storage.RENDER_MODE.STIPPLE_EN.value <= field_combo.RENDER_MODE.STIPPLE_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.STIPPLE_EN.value = field_storage.RENDER_MODE.STIPPLE_EN.value;
    // Field: gpu_regs.RENDER_MODE.ALPHA_TEST_FUNC
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value & ~decoded_wr_biten[18:17]) | (decoded_wr_data[18:17] & decoded_wr_biten[18:17]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.ALPHA_TEST_FUNC.next = next_c;
        field_combo.RENDER_MODE.ALPHA_TEST_FUNC.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value <= 2'h0;
        end else begin
            if(field_combo.RENDER_MODE.ALPHA_TEST_FUNC.load_next) begin
                field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value <= field_combo.RENDER_MODE.ALPHA_TEST_FUNC.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.ALPHA_TEST_FUNC.value = field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value;
    // Field: gpu_regs.RENDER_MODE.ALPHA_REF
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.ALPHA_REF.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.ALPHA_REF.value & ~decoded_wr_biten[26:19]) | (decoded_wr_data[26:19] & decoded_wr_biten[26:19]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.ALPHA_REF.next = next_c;
        field_combo.RENDER_MODE.ALPHA_REF.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.ALPHA_REF.value <= 8'h0;
        end else begin
            if(field_combo.RENDER_MODE.ALPHA_REF.load_next) begin
                field_storage.RENDER_MODE.ALPHA_REF.value <= field_combo.RENDER_MODE.ALPHA_REF.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.ALPHA_REF.value = field_storage.RENDER_MODE.ALPHA_REF.value;
    // Field: gpu_regs.RENDER_MODE.RSVD_HI
    always_comb begin
        automatic logic [36:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.RSVD_HI.value & ~decoded_wr_biten[63:27]) | (decoded_wr_data[63:27] & decoded_wr_biten[63:27]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.RSVD_HI.next = next_c;
        field_combo.RENDER_MODE.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.RSVD_HI.value <= 37'h0;
        end else begin
            if(field_combo.RENDER_MODE.RSVD_HI.load_next) begin
                field_storage.RENDER_MODE.RSVD_HI.value <= field_combo.RENDER_MODE.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.RSVD_HI.value = field_storage.RENDER_MODE.RSVD_HI.value;
    // Field: gpu_regs.Z_RANGE.Z_RANGE_MIN
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.Z_RANGE_MIN.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.Z_RANGE_MIN.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.Z_RANGE_MIN.next = next_c;
        field_combo.Z_RANGE.Z_RANGE_MIN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.Z_RANGE_MIN.value <= 16'h0;
        end else begin
            if(field_combo.Z_RANGE.Z_RANGE_MIN.load_next) begin
                field_storage.Z_RANGE.Z_RANGE_MIN.value <= field_combo.Z_RANGE.Z_RANGE_MIN.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.Z_RANGE_MIN.value = field_storage.Z_RANGE.Z_RANGE_MIN.value;
    // Field: gpu_regs.Z_RANGE.Z_RANGE_MAX
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.Z_RANGE_MAX.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.Z_RANGE_MAX.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.Z_RANGE_MAX.next = next_c;
        field_combo.Z_RANGE.Z_RANGE_MAX.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.Z_RANGE_MAX.value <= 16'hffff;
        end else begin
            if(field_combo.Z_RANGE.Z_RANGE_MAX.load_next) begin
                field_storage.Z_RANGE.Z_RANGE_MAX.value <= field_combo.Z_RANGE.Z_RANGE_MAX.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.Z_RANGE_MAX.value = field_storage.Z_RANGE.Z_RANGE_MAX.value;
    // Field: gpu_regs.Z_RANGE.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.RSVD.next = next_c;
        field_combo.Z_RANGE.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.Z_RANGE.RSVD.load_next) begin
                field_storage.Z_RANGE.RSVD.value <= field_combo.Z_RANGE.RSVD.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.RSVD.value = field_storage.Z_RANGE.RSVD.value;
    // Field: gpu_regs.STIPPLE_PATTERN.PATTERN
    always_comb begin
        automatic logic [63:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.STIPPLE_PATTERN.PATTERN.value;
        load_next_c = '0;
        if(decoded_reg_strb.STIPPLE_PATTERN && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.STIPPLE_PATTERN.PATTERN.value & ~decoded_wr_biten[63:0]) | (decoded_wr_data[63:0] & decoded_wr_biten[63:0]);
            load_next_c = '1;
        end
        field_combo.STIPPLE_PATTERN.PATTERN.next = next_c;
        field_combo.STIPPLE_PATTERN.PATTERN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.STIPPLE_PATTERN.PATTERN.value <= 64'hffffffffffffffff;
        end else begin
            if(field_combo.STIPPLE_PATTERN.PATTERN.load_next) begin
                field_storage.STIPPLE_PATTERN.PATTERN.value <= field_combo.STIPPLE_PATTERN.PATTERN.next;
            end
        end
    end
    assign hwif_out.STIPPLE_PATTERN.PATTERN.value = field_storage.STIPPLE_PATTERN.PATTERN.value;
    // Field: gpu_regs.FB_CONFIG.COLOR_BASE
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONFIG.COLOR_BASE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONFIG.COLOR_BASE.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.FB_CONFIG.COLOR_BASE.next = next_c;
        field_combo.FB_CONFIG.COLOR_BASE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONFIG.COLOR_BASE.value <= 16'h0;
        end else begin
            if(field_combo.FB_CONFIG.COLOR_BASE.load_next) begin
                field_storage.FB_CONFIG.COLOR_BASE.value <= field_combo.FB_CONFIG.COLOR_BASE.next;
            end
        end
    end
    assign hwif_out.FB_CONFIG.COLOR_BASE.value = field_storage.FB_CONFIG.COLOR_BASE.value;
    // Field: gpu_regs.FB_CONFIG.Z_BASE
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONFIG.Z_BASE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONFIG.Z_BASE.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.FB_CONFIG.Z_BASE.next = next_c;
        field_combo.FB_CONFIG.Z_BASE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONFIG.Z_BASE.value <= 16'h0;
        end else begin
            if(field_combo.FB_CONFIG.Z_BASE.load_next) begin
                field_storage.FB_CONFIG.Z_BASE.value <= field_combo.FB_CONFIG.Z_BASE.next;
            end
        end
    end
    assign hwif_out.FB_CONFIG.Z_BASE.value = field_storage.FB_CONFIG.Z_BASE.value;
    // Field: gpu_regs.FB_CONFIG.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONFIG.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONFIG.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FB_CONFIG.RSVD.next = next_c;
        field_combo.FB_CONFIG.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONFIG.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.FB_CONFIG.RSVD.load_next) begin
                field_storage.FB_CONFIG.RSVD.value <= field_combo.FB_CONFIG.RSVD.next;
            end
        end
    end
    assign hwif_out.FB_CONFIG.RSVD.value = field_storage.FB_CONFIG.RSVD.value;
    // Field: gpu_regs.FB_DISPLAY.COLOR_GRADE_ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.next = next_c;
        field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.load_next) begin
                field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value <= field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.COLOR_GRADE_ENABLE.value = field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value;
    // Field: gpu_regs.FB_DISPLAY.RSVD_LO
    always_comb begin
        automatic logic [14:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.RSVD_LO.value & ~decoded_wr_biten[15:1]) | (decoded_wr_data[15:1] & decoded_wr_biten[15:1]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.RSVD_LO.next = next_c;
        field_combo.FB_DISPLAY.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.RSVD_LO.value <= 15'h0;
        end else begin
            if(field_combo.FB_DISPLAY.RSVD_LO.load_next) begin
                field_storage.FB_DISPLAY.RSVD_LO.value <= field_combo.FB_DISPLAY.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.RSVD_LO.value = field_storage.FB_DISPLAY.RSVD_LO.value;
    // Field: gpu_regs.FB_DISPLAY.LUT_ADDR
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.LUT_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.LUT_ADDR.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.LUT_ADDR.next = next_c;
        field_combo.FB_DISPLAY.LUT_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.LUT_ADDR.value <= 16'h0;
        end else begin
            if(field_combo.FB_DISPLAY.LUT_ADDR.load_next) begin
                field_storage.FB_DISPLAY.LUT_ADDR.value <= field_combo.FB_DISPLAY.LUT_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.LUT_ADDR.value = field_storage.FB_DISPLAY.LUT_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY.FB_ADDR
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.FB_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.FB_ADDR.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.FB_ADDR.next = next_c;
        field_combo.FB_DISPLAY.FB_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.FB_ADDR.value <= 16'h0;
        end else begin
            if(field_combo.FB_DISPLAY.FB_ADDR.load_next) begin
                field_storage.FB_DISPLAY.FB_ADDR.value <= field_combo.FB_DISPLAY.FB_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.FB_ADDR.value = field_storage.FB_DISPLAY.FB_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY.RSVD_HI
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.RSVD_HI.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.RSVD_HI.next = next_c;
        field_combo.FB_DISPLAY.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.RSVD_HI.value <= 16'h0;
        end else begin
            if(field_combo.FB_DISPLAY.RSVD_HI.load_next) begin
                field_storage.FB_DISPLAY.RSVD_HI.value <= field_combo.FB_DISPLAY.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.RSVD_HI.value = field_storage.FB_DISPLAY.RSVD_HI.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_X
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_X.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_X.value & ~decoded_wr_biten[9:0]) | (decoded_wr_data[9:0] & decoded_wr_biten[9:0]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_X.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_X.value <= 10'h0;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_X.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_X.value <= field_combo.FB_CONTROL.SCISSOR_X.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_X.value = field_storage.FB_CONTROL.SCISSOR_X.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_Y
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_Y.value & ~decoded_wr_biten[19:10]) | (decoded_wr_data[19:10] & decoded_wr_biten[19:10]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_Y.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_Y.value <= 10'h0;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_Y.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_Y.value <= field_combo.FB_CONTROL.SCISSOR_Y.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_Y.value = field_storage.FB_CONTROL.SCISSOR_Y.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_WIDTH
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_WIDTH.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_WIDTH.value & ~decoded_wr_biten[29:20]) | (decoded_wr_data[29:20] & decoded_wr_biten[29:20]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_WIDTH.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_WIDTH.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_WIDTH.value <= 10'h3ff;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_WIDTH.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_WIDTH.value <= field_combo.FB_CONTROL.SCISSOR_WIDTH.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_WIDTH.value = field_storage.FB_CONTROL.SCISSOR_WIDTH.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_HEIGHT
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_HEIGHT.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_HEIGHT.value & ~decoded_wr_biten[39:30]) | (decoded_wr_data[39:30] & decoded_wr_biten[39:30]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_HEIGHT.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_HEIGHT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_HEIGHT.value <= 10'h3ff;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_HEIGHT.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_HEIGHT.value <= field_combo.FB_CONTROL.SCISSOR_HEIGHT.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_HEIGHT.value = field_storage.FB_CONTROL.SCISSOR_HEIGHT.value;
    // Field: gpu_regs.FB_CONTROL.Z_WRITE_EN_OVERRIDE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value & ~decoded_wr_biten[40:40]) | (decoded_wr_data[40:40] & decoded_wr_biten[40:40]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.next = next_c;
        field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.load_next) begin
                field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value <= field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value = field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value;
    // Field: gpu_regs.FB_CONTROL.RSVD_41
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.RSVD_41.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.RSVD_41.value & ~decoded_wr_biten[41:41]) | (decoded_wr_data[41:41] & decoded_wr_biten[41:41]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.RSVD_41.next = next_c;
        field_combo.FB_CONTROL.RSVD_41.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.RSVD_41.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.RSVD_41.load_next) begin
                field_storage.FB_CONTROL.RSVD_41.value <= field_combo.FB_CONTROL.RSVD_41.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.RSVD_41.value = field_storage.FB_CONTROL.RSVD_41.value;
    // Field: gpu_regs.FB_CONTROL.STENCIL_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.STENCIL_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.STENCIL_WRITE_EN.value & ~decoded_wr_biten[42:42]) | (decoded_wr_data[42:42] & decoded_wr_biten[42:42]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.STENCIL_WRITE_EN.next = next_c;
        field_combo.FB_CONTROL.STENCIL_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.STENCIL_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.STENCIL_WRITE_EN.load_next) begin
                field_storage.FB_CONTROL.STENCIL_WRITE_EN.value <= field_combo.FB_CONTROL.STENCIL_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.STENCIL_WRITE_EN.value = field_storage.FB_CONTROL.STENCIL_WRITE_EN.value;
    // Field: gpu_regs.FB_CONTROL.RSVD_HI
    always_comb begin
        automatic logic [20:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.RSVD_HI.value & ~decoded_wr_biten[63:43]) | (decoded_wr_data[63:43] & decoded_wr_biten[63:43]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.RSVD_HI.next = next_c;
        field_combo.FB_CONTROL.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.RSVD_HI.value <= 21'h0;
        end else begin
            if(field_combo.FB_CONTROL.RSVD_HI.load_next) begin
                field_storage.FB_CONTROL.RSVD_HI.value <= field_combo.FB_CONTROL.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.RSVD_HI.value = field_storage.FB_CONTROL.RSVD_HI.value;
    // Field: gpu_regs.MEM_FILL.FILL_BASE
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_FILL.FILL_BASE.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_FILL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_FILL.FILL_BASE.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.MEM_FILL.FILL_BASE.next = next_c;
        field_combo.MEM_FILL.FILL_BASE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_FILL.FILL_BASE.value <= 16'h0;
        end else begin
            if(field_combo.MEM_FILL.FILL_BASE.load_next) begin
                field_storage.MEM_FILL.FILL_BASE.value <= field_combo.MEM_FILL.FILL_BASE.next;
            end
        end
    end
    assign hwif_out.MEM_FILL.FILL_BASE.value = field_storage.MEM_FILL.FILL_BASE.value;
    // Field: gpu_regs.MEM_FILL.FILL_VALUE
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_FILL.FILL_VALUE.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_FILL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_FILL.FILL_VALUE.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.MEM_FILL.FILL_VALUE.next = next_c;
        field_combo.MEM_FILL.FILL_VALUE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_FILL.FILL_VALUE.value <= 16'h0;
        end else begin
            if(field_combo.MEM_FILL.FILL_VALUE.load_next) begin
                field_storage.MEM_FILL.FILL_VALUE.value <= field_combo.MEM_FILL.FILL_VALUE.next;
            end
        end
    end
    assign hwif_out.MEM_FILL.FILL_VALUE.value = field_storage.MEM_FILL.FILL_VALUE.value;
    // Field: gpu_regs.MEM_FILL.FILL_COUNT
    always_comb begin
        automatic logic [19:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_FILL.FILL_COUNT.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_FILL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_FILL.FILL_COUNT.value & ~decoded_wr_biten[51:32]) | (decoded_wr_data[51:32] & decoded_wr_biten[51:32]);
            load_next_c = '1;
        end
        field_combo.MEM_FILL.FILL_COUNT.next = next_c;
        field_combo.MEM_FILL.FILL_COUNT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_FILL.FILL_COUNT.value <= 20'h0;
        end else begin
            if(field_combo.MEM_FILL.FILL_COUNT.load_next) begin
                field_storage.MEM_FILL.FILL_COUNT.value <= field_combo.MEM_FILL.FILL_COUNT.next;
            end
        end
    end
    assign hwif_out.MEM_FILL.FILL_COUNT.value = field_storage.MEM_FILL.FILL_COUNT.value;
    // Field: gpu_regs.MEM_FILL.RSVD
    always_comb begin
        automatic logic [11:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_FILL.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_FILL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_FILL.RSVD.value & ~decoded_wr_biten[63:52]) | (decoded_wr_data[63:52] & decoded_wr_biten[63:52]);
            load_next_c = '1;
        end
        field_combo.MEM_FILL.RSVD.next = next_c;
        field_combo.MEM_FILL.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_FILL.RSVD.value <= 12'h0;
        end else begin
            if(field_combo.MEM_FILL.RSVD.load_next) begin
                field_storage.MEM_FILL.RSVD.value <= field_combo.MEM_FILL.RSVD.next;
            end
        end
    end
    assign hwif_out.MEM_FILL.RSVD.value = field_storage.MEM_FILL.RSVD.value;
    assign hwif_out.PERF_TEX0.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_TEX0.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_TEX1.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_TEX1.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_PIXELS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_PIXELS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_FRAGMENTS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_FRAGMENTS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_STALL_VS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_STALL_VS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_STALL_CT.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_STALL_CT.COUNTER_B.value = 32'h0;
    // Field: gpu_regs.MEM_ADDR.ADDR
    always_comb begin
        automatic logic [21:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_ADDR.ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_ADDR.ADDR.value & ~decoded_wr_biten[21:0]) | (decoded_wr_data[21:0] & decoded_wr_biten[21:0]);
            load_next_c = '1;
        end
        field_combo.MEM_ADDR.ADDR.next = next_c;
        field_combo.MEM_ADDR.ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_ADDR.ADDR.value <= 22'h0;
        end else begin
            if(field_combo.MEM_ADDR.ADDR.load_next) begin
                field_storage.MEM_ADDR.ADDR.value <= field_combo.MEM_ADDR.ADDR.next;
            end
        end
    end
    assign hwif_out.MEM_ADDR.ADDR.value = field_storage.MEM_ADDR.ADDR.value;
    // Field: gpu_regs.MEM_ADDR.RSVD
    always_comb begin
        automatic logic [41:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_ADDR.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_ADDR.RSVD.value & ~decoded_wr_biten[63:22]) | (decoded_wr_data[63:22] & decoded_wr_biten[63:22]);
            load_next_c = '1;
        end
        field_combo.MEM_ADDR.RSVD.next = next_c;
        field_combo.MEM_ADDR.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_ADDR.RSVD.value <= 42'h0;
        end else begin
            if(field_combo.MEM_ADDR.RSVD.load_next) begin
                field_storage.MEM_ADDR.RSVD.value <= field_combo.MEM_ADDR.RSVD.next;
            end
        end
    end
    assign hwif_out.MEM_ADDR.RSVD.value = field_storage.MEM_ADDR.RSVD.value;
    // Field: gpu_regs.MEM_DATA.DATA
    always_comb begin
        automatic logic [63:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_DATA.DATA.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_DATA && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_DATA.DATA.value & ~decoded_wr_biten[63:0]) | (decoded_wr_data[63:0] & decoded_wr_biten[63:0]);
            load_next_c = '1;
        end
        field_combo.MEM_DATA.DATA.next = next_c;
        field_combo.MEM_DATA.DATA.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_DATA.DATA.value <= 64'h0;
        end else begin
            if(field_combo.MEM_DATA.DATA.load_next) begin
                field_storage.MEM_DATA.DATA.value <= field_combo.MEM_DATA.DATA.next;
            end
        end
    end
    assign hwif_out.MEM_DATA.DATA.value = field_storage.MEM_DATA.DATA.value;
    assign hwif_out.STATUS.FIFO_DEPTH.value = 8'h0;
    assign hwif_out.STATUS.BUSY.value = 1'h0;
    assign hwif_out.STATUS.VBLANK.value = 1'h0;
    assign hwif_out.STATUS.RSVD.value = 54'h0;
    assign hwif_out.ID.DEVICE_ID.value = 16'h6702;
    assign hwif_out.ID.VERSION.value = 16'ha00;
    assign hwif_out.ID.RSVD.value = 32'h0;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [63:0] readback_data;

    // Assign readback values to a flattened array
    logic [63:0] readback_array[27];
    assign readback_array[0][7:0] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_R.value : '0;
    assign readback_array[0][15:8] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_G.value : '0;
    assign readback_array[0][23:16] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_B.value : '0;
    assign readback_array[0][31:24] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_A.value : '0;
    assign readback_array[0][39:32] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_R.value : '0;
    assign readback_array[0][47:40] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_G.value : '0;
    assign readback_array[0][55:48] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_B.value : '0;
    assign readback_array[0][63:56] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_A.value : '0;
    assign readback_array[1][15:0] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV0_UQ.value : '0;
    assign readback_array[1][31:16] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV0_VQ.value : '0;
    assign readback_array[1][47:32] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV1_UQ.value : '0;
    assign readback_array[1][63:48] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV1_VQ.value : '0;
    assign readback_array[2][15:0] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.X.value : '0;
    assign readback_array[2][31:16] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Y.value : '0;
    assign readback_array[2][47:32] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Z.value : '0;
    assign readback_array[2][63:48] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Q.value : '0;
    assign readback_array[3][15:0] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.X.value : '0;
    assign readback_array[3][31:16] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Y.value : '0;
    assign readback_array[3][47:32] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Z.value : '0;
    assign readback_array[3][63:48] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Q.value : '0;
    assign readback_array[4][15:0] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.X.value : '0;
    assign readback_array[4][31:16] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Y.value : '0;
    assign readback_array[4][47:32] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Z.value : '0;
    assign readback_array[4][63:48] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Q.value : '0;
    assign readback_array[5][15:0] = (decoded_reg_strb.VERTEX_KICK_RECT && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_RECT.X.value : '0;
    assign readback_array[5][31:16] = (decoded_reg_strb.VERTEX_KICK_RECT && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_RECT.Y.value : '0;
    assign readback_array[5][47:32] = (decoded_reg_strb.VERTEX_KICK_RECT && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_RECT.Z.value : '0;
    assign readback_array[5][63:48] = (decoded_reg_strb.VERTEX_KICK_RECT && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_RECT.Q.value : '0;
    assign readback_array[6][0:0] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.ENABLE.value : '0;
    assign readback_array[6][1:1] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.RSVD_1.value : '0;
    assign readback_array[6][3:2] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.FILTER.value : '0;
    assign readback_array[6][6:4] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.FORMAT.value : '0;
    assign readback_array[6][7:7] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.RSVD_7.value : '0;
    assign readback_array[6][11:8] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.WIDTH_LOG2.value : '0;
    assign readback_array[6][15:12] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.HEIGHT_LOG2.value : '0;
    assign readback_array[6][17:16] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.U_WRAP.value : '0;
    assign readback_array[6][19:18] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.V_WRAP.value : '0;
    assign readback_array[6][23:20] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.MIP_LEVELS.value : '0;
    assign readback_array[6][31:24] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.RSVD_MID.value : '0;
    assign readback_array[6][47:32] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.BASE_ADDR.value : '0;
    assign readback_array[6][63:48] = (decoded_reg_strb.TEX0_CFG && !decoded_req_is_wr) ? field_storage.TEX0_CFG.RSVD_HI.value : '0;
    assign readback_array[7][0:0] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.ENABLE.value : '0;
    assign readback_array[7][1:1] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.RSVD_1.value : '0;
    assign readback_array[7][3:2] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.FILTER.value : '0;
    assign readback_array[7][6:4] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.FORMAT.value : '0;
    assign readback_array[7][7:7] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.RSVD_7.value : '0;
    assign readback_array[7][11:8] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.WIDTH_LOG2.value : '0;
    assign readback_array[7][15:12] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.HEIGHT_LOG2.value : '0;
    assign readback_array[7][17:16] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.U_WRAP.value : '0;
    assign readback_array[7][19:18] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.V_WRAP.value : '0;
    assign readback_array[7][23:20] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.MIP_LEVELS.value : '0;
    assign readback_array[7][31:24] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.RSVD_MID.value : '0;
    assign readback_array[7][47:32] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.BASE_ADDR.value : '0;
    assign readback_array[7][63:48] = (decoded_reg_strb.TEX1_CFG && !decoded_req_is_wr) ? field_storage.TEX1_CFG.RSVD_HI.value : '0;
    assign readback_array[8][3:0] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_RGB_A.value : '0;
    assign readback_array[8][7:4] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_RGB_B.value : '0;
    assign readback_array[8][11:8] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_RGB_C.value : '0;
    assign readback_array[8][15:12] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_RGB_D.value : '0;
    assign readback_array[8][19:16] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_ALPHA_A.value : '0;
    assign readback_array[8][23:20] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_ALPHA_B.value : '0;
    assign readback_array[8][27:24] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_ALPHA_C.value : '0;
    assign readback_array[8][31:28] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C0_ALPHA_D.value : '0;
    assign readback_array[8][35:32] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_RGB_A.value : '0;
    assign readback_array[8][39:36] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_RGB_B.value : '0;
    assign readback_array[8][43:40] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_RGB_C.value : '0;
    assign readback_array[8][47:44] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_RGB_D.value : '0;
    assign readback_array[8][51:48] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_ALPHA_A.value : '0;
    assign readback_array[8][55:52] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_ALPHA_B.value : '0;
    assign readback_array[8][59:56] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_ALPHA_C.value : '0;
    assign readback_array[8][63:60] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.C1_ALPHA_D.value : '0;
    assign readback_array[9][7:0] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST0_R.value : '0;
    assign readback_array[9][15:8] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST0_G.value : '0;
    assign readback_array[9][23:16] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST0_B.value : '0;
    assign readback_array[9][31:24] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST0_A.value : '0;
    assign readback_array[9][39:32] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST1_R.value : '0;
    assign readback_array[9][47:40] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST1_G.value : '0;
    assign readback_array[9][55:48] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST1_B.value : '0;
    assign readback_array[9][63:56] = (decoded_reg_strb.CONST_COLOR && !decoded_req_is_wr) ? field_storage.CONST_COLOR.CONST1_A.value : '0;
    assign readback_array[10][0:0] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.GOURAUD.value : '0;
    assign readback_array[10][1:1] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.RSVD_1.value : '0;
    assign readback_array[10][2:2] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_TEST_EN.value : '0;
    assign readback_array[10][3:3] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_WRITE_EN.value : '0;
    assign readback_array[10][4:4] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.COLOR_WRITE_EN.value : '0;
    assign readback_array[10][6:5] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.CULL_MODE.value : '0;
    assign readback_array[10][9:7] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.ALPHA_BLEND.value : '0;
    assign readback_array[10][10:10] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.DITHER_EN.value : '0;
    assign readback_array[10][12:11] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.DITHER_PATTERN.value : '0;
    assign readback_array[10][15:13] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_COMPARE.value : '0;
    assign readback_array[10][16:16] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.STIPPLE_EN.value : '0;
    assign readback_array[10][18:17] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.ALPHA_TEST_FUNC.value : '0;
    assign readback_array[10][26:19] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.ALPHA_REF.value : '0;
    assign readback_array[10][63:27] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.RSVD_HI.value : '0;
    assign readback_array[11][15:0] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.Z_RANGE_MIN.value : '0;
    assign readback_array[11][31:16] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.Z_RANGE_MAX.value : '0;
    assign readback_array[11][63:32] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.RSVD.value : '0;
    assign readback_array[12][63:0] = (decoded_reg_strb.STIPPLE_PATTERN && !decoded_req_is_wr) ? field_storage.STIPPLE_PATTERN.PATTERN.value : '0;
    assign readback_array[13][15:0] = (decoded_reg_strb.FB_CONFIG && !decoded_req_is_wr) ? field_storage.FB_CONFIG.COLOR_BASE.value : '0;
    assign readback_array[13][31:16] = (decoded_reg_strb.FB_CONFIG && !decoded_req_is_wr) ? field_storage.FB_CONFIG.Z_BASE.value : '0;
    assign readback_array[13][63:32] = (decoded_reg_strb.FB_CONFIG && !decoded_req_is_wr) ? field_storage.FB_CONFIG.RSVD.value : '0;
    assign readback_array[14][0:0] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value : '0;
    assign readback_array[14][15:1] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.RSVD_LO.value : '0;
    assign readback_array[14][31:16] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.LUT_ADDR.value : '0;
    assign readback_array[14][47:32] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.FB_ADDR.value : '0;
    assign readback_array[14][63:48] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.RSVD_HI.value : '0;
    assign readback_array[15][9:0] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_X.value : '0;
    assign readback_array[15][19:10] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_Y.value : '0;
    assign readback_array[15][29:20] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_WIDTH.value : '0;
    assign readback_array[15][39:30] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_HEIGHT.value : '0;
    assign readback_array[15][40:40] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value : '0;
    assign readback_array[15][41:41] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.RSVD_41.value : '0;
    assign readback_array[15][42:42] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.STENCIL_WRITE_EN.value : '0;
    assign readback_array[15][63:43] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.RSVD_HI.value : '0;
    assign readback_array[16][15:0] = (decoded_reg_strb.MEM_FILL && !decoded_req_is_wr) ? field_storage.MEM_FILL.FILL_BASE.value : '0;
    assign readback_array[16][31:16] = (decoded_reg_strb.MEM_FILL && !decoded_req_is_wr) ? field_storage.MEM_FILL.FILL_VALUE.value : '0;
    assign readback_array[16][51:32] = (decoded_reg_strb.MEM_FILL && !decoded_req_is_wr) ? field_storage.MEM_FILL.FILL_COUNT.value : '0;
    assign readback_array[16][63:52] = (decoded_reg_strb.MEM_FILL && !decoded_req_is_wr) ? field_storage.MEM_FILL.RSVD.value : '0;
    assign readback_array[17][31:0] = (decoded_reg_strb.PERF_TEX0 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[17][63:32] = (decoded_reg_strb.PERF_TEX0 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[18][31:0] = (decoded_reg_strb.PERF_TEX1 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[18][63:32] = (decoded_reg_strb.PERF_TEX1 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[19][31:0] = (decoded_reg_strb.PERF_PIXELS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[19][63:32] = (decoded_reg_strb.PERF_PIXELS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[20][31:0] = (decoded_reg_strb.PERF_FRAGMENTS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[20][63:32] = (decoded_reg_strb.PERF_FRAGMENTS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[21][31:0] = (decoded_reg_strb.PERF_STALL_VS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[21][63:32] = (decoded_reg_strb.PERF_STALL_VS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[22][31:0] = (decoded_reg_strb.PERF_STALL_CT && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[22][63:32] = (decoded_reg_strb.PERF_STALL_CT && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[23][21:0] = (decoded_reg_strb.MEM_ADDR && !decoded_req_is_wr) ? field_storage.MEM_ADDR.ADDR.value : '0;
    assign readback_array[23][63:22] = (decoded_reg_strb.MEM_ADDR && !decoded_req_is_wr) ? field_storage.MEM_ADDR.RSVD.value : '0;
    assign readback_array[24][63:0] = (decoded_reg_strb.MEM_DATA && !decoded_req_is_wr) ? field_storage.MEM_DATA.DATA.value : '0;
    assign readback_array[25][7:0] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[25][8:8] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[25][9:9] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[25][63:10] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 54'h0 : '0;
    assign readback_array[26][15:0] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 16'h6702 : '0;
    assign readback_array[26][31:16] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 16'ha00 : '0;
    assign readback_array[26][63:32] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 32'h0 : '0;

    // Reduce the array
    always_comb begin
        automatic logic [63:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<27; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
