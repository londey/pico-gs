// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module gpu_regs (
        input wire clk,
        input wire rst,

        input wire s_cpuif_req,
        input wire s_cpuif_req_is_wr,
        input wire [9:0] s_cpuif_addr,
        input wire [63:0] s_cpuif_wr_data,
        input wire [63:0] s_cpuif_wr_biten,
        output wire s_cpuif_req_stall_wr,
        output wire s_cpuif_req_stall_rd,
        output wire s_cpuif_rd_ack,
        output wire s_cpuif_rd_err,
        output wire [63:0] s_cpuif_rd_data,
        output wire s_cpuif_wr_ack,
        output wire s_cpuif_wr_err,

        output gpu_regs_pkg::gpu_regs__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [9:0] cpuif_addr;
    logic [63:0] cpuif_wr_data;
    logic [63:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [63:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    assign cpuif_req = s_cpuif_req;
    assign cpuif_req_is_wr = s_cpuif_req_is_wr;
    assign cpuif_addr = s_cpuif_addr;
    assign cpuif_wr_data = s_cpuif_wr_data;
    assign cpuif_wr_biten = s_cpuif_wr_biten;
    assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
    assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
    assign s_cpuif_rd_ack = cpuif_rd_ack;
    assign s_cpuif_rd_err = cpuif_rd_err;
    assign s_cpuif_rd_data = cpuif_rd_data;
    assign s_cpuif_wr_ack = cpuif_wr_ack;
    assign s_cpuif_wr_err = cpuif_wr_err;

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic COLOR;
        logic UV0_UV1;
        logic LIGHT_DIR;
        logic VERTEX_NOKICK;
        logic VERTEX_KICK_012;
        logic VERTEX_KICK_021;
        logic TEX0_BASE;
        logic TEX0_FMT;
        logic TEX0_MIP_BIAS;
        logic TEX0_WRAP;
        logic TEX1_BASE;
        logic TEX1_FMT;
        logic TEX1_MIP_BIAS;
        logic TEX1_WRAP;
        logic CC_MODE;
        logic MAT_COLOR0;
        logic MAT_COLOR1;
        logic FOG_COLOR;
        logic RENDER_MODE;
        logic Z_RANGE;
        logic FB_DRAW;
        logic FB_DISPLAY;
        logic FB_ZBUFFER;
        logic FB_CONTROL;
        logic FB_DISPLAY_SYNC;
        logic PERF_TEX0;
        logic PERF_TEX1;
        logic PERF_PIXELS;
        logic PERF_FRAGMENTS;
        logic PERF_STALL_VS;
        logic PERF_STALL_CT;
        logic MEM_ADDR;
        logic MEM_DATA;
        logic STATUS;
        logic ID;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_err;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [63:0] decoded_wr_data;
    logic [63:0] decoded_wr_biten;

    always_comb begin
        automatic logic is_valid_addr;
        automatic logic is_invalid_rw;
        is_valid_addr = '1; // No error checking on valid address access
        is_invalid_rw = '0;
        decoded_reg_strb.COLOR = cpuif_req_masked & (cpuif_addr == 10'h0);
        decoded_reg_strb.UV0_UV1 = cpuif_req_masked & (cpuif_addr == 10'h8);
        decoded_reg_strb.LIGHT_DIR = cpuif_req_masked & (cpuif_addr == 10'h18);
        decoded_reg_strb.VERTEX_NOKICK = cpuif_req_masked & (cpuif_addr == 10'h30);
        decoded_reg_strb.VERTEX_KICK_012 = cpuif_req_masked & (cpuif_addr == 10'h38);
        decoded_reg_strb.VERTEX_KICK_021 = cpuif_req_masked & (cpuif_addr == 10'h40);
        decoded_reg_strb.TEX0_BASE = cpuif_req_masked & (cpuif_addr == 10'h80);
        decoded_reg_strb.TEX0_FMT = cpuif_req_masked & (cpuif_addr == 10'h88);
        decoded_reg_strb.TEX0_MIP_BIAS = cpuif_req_masked & (cpuif_addr == 10'h90);
        decoded_reg_strb.TEX0_WRAP = cpuif_req_masked & (cpuif_addr == 10'h98);
        decoded_reg_strb.TEX1_BASE = cpuif_req_masked & (cpuif_addr == 10'ha0);
        decoded_reg_strb.TEX1_FMT = cpuif_req_masked & (cpuif_addr == 10'ha8);
        decoded_reg_strb.TEX1_MIP_BIAS = cpuif_req_masked & (cpuif_addr == 10'hb0);
        decoded_reg_strb.TEX1_WRAP = cpuif_req_masked & (cpuif_addr == 10'hb8);
        decoded_reg_strb.CC_MODE = cpuif_req_masked & (cpuif_addr == 10'hc0);
        decoded_reg_strb.MAT_COLOR0 = cpuif_req_masked & (cpuif_addr == 10'hc8);
        decoded_reg_strb.MAT_COLOR1 = cpuif_req_masked & (cpuif_addr == 10'hd0);
        decoded_reg_strb.FOG_COLOR = cpuif_req_masked & (cpuif_addr == 10'hd8);
        decoded_reg_strb.RENDER_MODE = cpuif_req_masked & (cpuif_addr == 10'h180);
        decoded_reg_strb.Z_RANGE = cpuif_req_masked & (cpuif_addr == 10'h188);
        decoded_reg_strb.FB_DRAW = cpuif_req_masked & (cpuif_addr == 10'h200);
        decoded_reg_strb.FB_DISPLAY = cpuif_req_masked & (cpuif_addr == 10'h208);
        decoded_reg_strb.FB_ZBUFFER = cpuif_req_masked & (cpuif_addr == 10'h210);
        decoded_reg_strb.FB_CONTROL = cpuif_req_masked & (cpuif_addr == 10'h218);
        decoded_reg_strb.FB_DISPLAY_SYNC = cpuif_req_masked & (cpuif_addr == 10'h238);
        decoded_reg_strb.PERF_TEX0 = cpuif_req_masked & (cpuif_addr == 10'h280) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_TEX1 = cpuif_req_masked & (cpuif_addr == 10'h288) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_PIXELS = cpuif_req_masked & (cpuif_addr == 10'h2a0) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_FRAGMENTS = cpuif_req_masked & (cpuif_addr == 10'h2a8) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_STALL_VS = cpuif_req_masked & (cpuif_addr == 10'h2b0) & !cpuif_req_is_wr;
        decoded_reg_strb.PERF_STALL_CT = cpuif_req_masked & (cpuif_addr == 10'h2b8) & !cpuif_req_is_wr;
        decoded_reg_strb.MEM_ADDR = cpuif_req_masked & (cpuif_addr == 10'h380);
        decoded_reg_strb.MEM_DATA = cpuif_req_masked & (cpuif_addr == 10'h388);
        decoded_reg_strb.STATUS = cpuif_req_masked & (cpuif_addr == 10'h3f0) & !cpuif_req_is_wr;
        decoded_reg_strb.ID = cpuif_req_masked & (cpuif_addr == 10'h3f8) & !cpuif_req_is_wr;
        decoded_err = (~is_valid_addr | is_invalid_rw) & decoded_req;
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR0_A;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_R;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_G;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_B;
            struct {
                logic [7:0] next;
                logic load_next;
            } COLOR1_A;
        } COLOR;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } UV0_UQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV0_VQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV1_UQ;
            struct {
                logic [15:0] next;
                logic load_next;
            } UV1_VQ;
        } UV0_UV1;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } X_DIR;
            struct {
                logic [7:0] next;
                logic load_next;
            } Y_DIR;
            struct {
                logic [7:0] next;
                logic load_next;
            } Z_DIR;
            struct {
                logic [39:0] next;
                logic load_next;
            } RSVD;
        } LIGHT_DIR;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_NOKICK;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_KICK_012;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } X;
            struct {
                logic [15:0] next;
                logic load_next;
            } Y;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z;
            struct {
                logic [15:0] next;
                logic load_next;
            } Q;
        } VERTEX_KICK_021;
        struct {
            struct {
                logic [11:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [19:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX0_BASE;
        struct {
            struct {
                logic next;
                logic load_next;
            } ENABLE;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic [1:0] next;
                logic load_next;
            } FORMAT;
            struct {
                logic [1:0] next;
                logic load_next;
            } RSVD_54;
            struct {
                logic [1:0] next;
                logic load_next;
            } FILTER;
            struct {
                logic [3:0] next;
                logic load_next;
            } WIDTH_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } HEIGHT_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } SWIZZLE;
            struct {
                logic [3:0] next;
                logic load_next;
            } MIP_LEVELS;
            struct {
                logic [39:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX0_FMT;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } MIP_BIAS;
            struct {
                logic [55:0] next;
                logic load_next;
            } RSVD;
        } TEX0_MIP_BIAS;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } U_WRAP;
            struct {
                logic [1:0] next;
                logic load_next;
            } V_WRAP;
            struct {
                logic [59:0] next;
                logic load_next;
            } RSVD;
        } TEX0_WRAP;
        struct {
            struct {
                logic [11:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [19:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX1_BASE;
        struct {
            struct {
                logic next;
                logic load_next;
            } ENABLE;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic [1:0] next;
                logic load_next;
            } FORMAT;
            struct {
                logic [1:0] next;
                logic load_next;
            } RSVD_54;
            struct {
                logic [1:0] next;
                logic load_next;
            } FILTER;
            struct {
                logic [3:0] next;
                logic load_next;
            } WIDTH_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } HEIGHT_LOG2;
            struct {
                logic [3:0] next;
                logic load_next;
            } SWIZZLE;
            struct {
                logic [3:0] next;
                logic load_next;
            } MIP_LEVELS;
            struct {
                logic [39:0] next;
                logic load_next;
            } RSVD_HI;
        } TEX1_FMT;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } MIP_BIAS;
            struct {
                logic [55:0] next;
                logic load_next;
            } RSVD;
        } TEX1_MIP_BIAS;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } U_WRAP;
            struct {
                logic [1:0] next;
                logic load_next;
            } V_WRAP;
            struct {
                logic [59:0] next;
                logic load_next;
            } RSVD;
        } TEX1_WRAP;
        struct {
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_ALPHA_A;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_ALPHA_B;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_ALPHA_C;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_ALPHA_D;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_A_SOURCE;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_B_SOURCE;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_C_SOURCE;
            struct {
                logic [3:0] next;
                logic load_next;
            } CC_D_SOURCE;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } CC_MODE;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } RED;
            struct {
                logic [7:0] next;
                logic load_next;
            } GREEN;
            struct {
                logic [7:0] next;
                logic load_next;
            } BLUE;
            struct {
                logic [7:0] next;
                logic load_next;
            } ALPHA;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } MAT_COLOR0;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } RED;
            struct {
                logic [7:0] next;
                logic load_next;
            } GREEN;
            struct {
                logic [7:0] next;
                logic load_next;
            } BLUE;
            struct {
                logic [7:0] next;
                logic load_next;
            } ALPHA;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } MAT_COLOR1;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } RED;
            struct {
                logic [7:0] next;
                logic load_next;
            } GREEN;
            struct {
                logic [7:0] next;
                logic load_next;
            } BLUE;
            struct {
                logic [7:0] next;
                logic load_next;
            } ALPHA;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } FOG_COLOR;
        struct {
            struct {
                logic next;
                logic load_next;
            } GOURAUD;
            struct {
                logic next;
                logic load_next;
            } RSVD_1;
            struct {
                logic next;
                logic load_next;
            } Z_TEST_EN;
            struct {
                logic next;
                logic load_next;
            } Z_WRITE_EN;
            struct {
                logic next;
                logic load_next;
            } COLOR_WRITE_EN;
            struct {
                logic [1:0] next;
                logic load_next;
            } CULL_MODE;
            struct {
                logic [2:0] next;
                logic load_next;
            } ALPHA_BLEND;
            struct {
                logic next;
                logic load_next;
            } DITHER_EN;
            struct {
                logic [1:0] next;
                logic load_next;
            } DITHER_PATTERN;
            struct {
                logic [2:0] next;
                logic load_next;
            } Z_COMPARE;
            struct {
                logic [47:0] next;
                logic load_next;
            } RSVD_HI;
        } RENDER_MODE;
        struct {
            struct {
                logic [15:0] next;
                logic load_next;
            } Z_RANGE_MIN;
            struct {
                logic [15:0] next;
                logic load_next;
            } Z_RANGE_MAX;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } Z_RANGE;
        struct {
            struct {
                logic [11:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [19:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_DRAW;
        struct {
            struct {
                logic next;
                logic load_next;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [4:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [12:0] next;
                logic load_next;
            } LUT_ADDR;
            struct {
                logic [12:0] next;
                logic load_next;
            } FB_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_DISPLAY;
        struct {
            struct {
                logic [11:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [19:0] next;
                logic load_next;
            } BASE_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_ZBUFFER;
        struct {
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_X;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_Y;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_WIDTH;
            struct {
                logic [9:0] next;
                logic load_next;
            } SCISSOR_HEIGHT;
            struct {
                logic next;
                logic load_next;
            } Z_WRITE_EN_OVERRIDE;
            struct {
                logic next;
                logic load_next;
            } RSVD_41;
            struct {
                logic next;
                logic load_next;
            } STENCIL_WRITE_EN;
            struct {
                logic [20:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_CONTROL;
        struct {
            struct {
                logic next;
                logic load_next;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [4:0] next;
                logic load_next;
            } RSVD_LO;
            struct {
                logic [12:0] next;
                logic load_next;
            } LUT_ADDR;
            struct {
                logic [12:0] next;
                logic load_next;
            } FB_ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD_HI;
        } FB_DISPLAY_SYNC;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } ADDR;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } MEM_ADDR;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } DATA;
            struct {
                logic [31:0] next;
                logic load_next;
            } RSVD;
        } MEM_DATA;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [7:0] value;
            } COLOR0_R;
            struct {
                logic [7:0] value;
            } COLOR0_G;
            struct {
                logic [7:0] value;
            } COLOR0_B;
            struct {
                logic [7:0] value;
            } COLOR0_A;
            struct {
                logic [7:0] value;
            } COLOR1_R;
            struct {
                logic [7:0] value;
            } COLOR1_G;
            struct {
                logic [7:0] value;
            } COLOR1_B;
            struct {
                logic [7:0] value;
            } COLOR1_A;
        } COLOR;
        struct {
            struct {
                logic [15:0] value;
            } UV0_UQ;
            struct {
                logic [15:0] value;
            } UV0_VQ;
            struct {
                logic [15:0] value;
            } UV1_UQ;
            struct {
                logic [15:0] value;
            } UV1_VQ;
        } UV0_UV1;
        struct {
            struct {
                logic [7:0] value;
            } X_DIR;
            struct {
                logic [7:0] value;
            } Y_DIR;
            struct {
                logic [7:0] value;
            } Z_DIR;
            struct {
                logic [39:0] value;
            } RSVD;
        } LIGHT_DIR;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_NOKICK;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_KICK_012;
        struct {
            struct {
                logic [15:0] value;
            } X;
            struct {
                logic [15:0] value;
            } Y;
            struct {
                logic [15:0] value;
            } Z;
            struct {
                logic [15:0] value;
            } Q;
        } VERTEX_KICK_021;
        struct {
            struct {
                logic [11:0] value;
            } RSVD_LO;
            struct {
                logic [19:0] value;
            } BASE_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } TEX0_BASE;
        struct {
            struct {
                logic value;
            } ENABLE;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic [1:0] value;
            } FORMAT;
            struct {
                logic [1:0] value;
            } RSVD_54;
            struct {
                logic [1:0] value;
            } FILTER;
            struct {
                logic [3:0] value;
            } WIDTH_LOG2;
            struct {
                logic [3:0] value;
            } HEIGHT_LOG2;
            struct {
                logic [3:0] value;
            } SWIZZLE;
            struct {
                logic [3:0] value;
            } MIP_LEVELS;
            struct {
                logic [39:0] value;
            } RSVD_HI;
        } TEX0_FMT;
        struct {
            struct {
                logic [7:0] value;
            } MIP_BIAS;
            struct {
                logic [55:0] value;
            } RSVD;
        } TEX0_MIP_BIAS;
        struct {
            struct {
                logic [1:0] value;
            } U_WRAP;
            struct {
                logic [1:0] value;
            } V_WRAP;
            struct {
                logic [59:0] value;
            } RSVD;
        } TEX0_WRAP;
        struct {
            struct {
                logic [11:0] value;
            } RSVD_LO;
            struct {
                logic [19:0] value;
            } BASE_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } TEX1_BASE;
        struct {
            struct {
                logic value;
            } ENABLE;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic [1:0] value;
            } FORMAT;
            struct {
                logic [1:0] value;
            } RSVD_54;
            struct {
                logic [1:0] value;
            } FILTER;
            struct {
                logic [3:0] value;
            } WIDTH_LOG2;
            struct {
                logic [3:0] value;
            } HEIGHT_LOG2;
            struct {
                logic [3:0] value;
            } SWIZZLE;
            struct {
                logic [3:0] value;
            } MIP_LEVELS;
            struct {
                logic [39:0] value;
            } RSVD_HI;
        } TEX1_FMT;
        struct {
            struct {
                logic [7:0] value;
            } MIP_BIAS;
            struct {
                logic [55:0] value;
            } RSVD;
        } TEX1_MIP_BIAS;
        struct {
            struct {
                logic [1:0] value;
            } U_WRAP;
            struct {
                logic [1:0] value;
            } V_WRAP;
            struct {
                logic [59:0] value;
            } RSVD;
        } TEX1_WRAP;
        struct {
            struct {
                logic [3:0] value;
            } CC_ALPHA_A;
            struct {
                logic [3:0] value;
            } CC_ALPHA_B;
            struct {
                logic [3:0] value;
            } CC_ALPHA_C;
            struct {
                logic [3:0] value;
            } CC_ALPHA_D;
            struct {
                logic [3:0] value;
            } CC_A_SOURCE;
            struct {
                logic [3:0] value;
            } CC_B_SOURCE;
            struct {
                logic [3:0] value;
            } CC_C_SOURCE;
            struct {
                logic [3:0] value;
            } CC_D_SOURCE;
            struct {
                logic [31:0] value;
            } RSVD;
        } CC_MODE;
        struct {
            struct {
                logic [7:0] value;
            } RED;
            struct {
                logic [7:0] value;
            } GREEN;
            struct {
                logic [7:0] value;
            } BLUE;
            struct {
                logic [7:0] value;
            } ALPHA;
            struct {
                logic [31:0] value;
            } RSVD;
        } MAT_COLOR0;
        struct {
            struct {
                logic [7:0] value;
            } RED;
            struct {
                logic [7:0] value;
            } GREEN;
            struct {
                logic [7:0] value;
            } BLUE;
            struct {
                logic [7:0] value;
            } ALPHA;
            struct {
                logic [31:0] value;
            } RSVD;
        } MAT_COLOR1;
        struct {
            struct {
                logic [7:0] value;
            } RED;
            struct {
                logic [7:0] value;
            } GREEN;
            struct {
                logic [7:0] value;
            } BLUE;
            struct {
                logic [7:0] value;
            } ALPHA;
            struct {
                logic [31:0] value;
            } RSVD;
        } FOG_COLOR;
        struct {
            struct {
                logic value;
            } GOURAUD;
            struct {
                logic value;
            } RSVD_1;
            struct {
                logic value;
            } Z_TEST_EN;
            struct {
                logic value;
            } Z_WRITE_EN;
            struct {
                logic value;
            } COLOR_WRITE_EN;
            struct {
                logic [1:0] value;
            } CULL_MODE;
            struct {
                logic [2:0] value;
            } ALPHA_BLEND;
            struct {
                logic value;
            } DITHER_EN;
            struct {
                logic [1:0] value;
            } DITHER_PATTERN;
            struct {
                logic [2:0] value;
            } Z_COMPARE;
            struct {
                logic [47:0] value;
            } RSVD_HI;
        } RENDER_MODE;
        struct {
            struct {
                logic [15:0] value;
            } Z_RANGE_MIN;
            struct {
                logic [15:0] value;
            } Z_RANGE_MAX;
            struct {
                logic [31:0] value;
            } RSVD;
        } Z_RANGE;
        struct {
            struct {
                logic [11:0] value;
            } RSVD_LO;
            struct {
                logic [19:0] value;
            } BASE_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } FB_DRAW;
        struct {
            struct {
                logic value;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [4:0] value;
            } RSVD_LO;
            struct {
                logic [12:0] value;
            } LUT_ADDR;
            struct {
                logic [12:0] value;
            } FB_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } FB_DISPLAY;
        struct {
            struct {
                logic [11:0] value;
            } RSVD_LO;
            struct {
                logic [19:0] value;
            } BASE_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } FB_ZBUFFER;
        struct {
            struct {
                logic [9:0] value;
            } SCISSOR_X;
            struct {
                logic [9:0] value;
            } SCISSOR_Y;
            struct {
                logic [9:0] value;
            } SCISSOR_WIDTH;
            struct {
                logic [9:0] value;
            } SCISSOR_HEIGHT;
            struct {
                logic value;
            } Z_WRITE_EN_OVERRIDE;
            struct {
                logic value;
            } RSVD_41;
            struct {
                logic value;
            } STENCIL_WRITE_EN;
            struct {
                logic [20:0] value;
            } RSVD_HI;
        } FB_CONTROL;
        struct {
            struct {
                logic value;
            } COLOR_GRADE_ENABLE;
            struct {
                logic [4:0] value;
            } RSVD_LO;
            struct {
                logic [12:0] value;
            } LUT_ADDR;
            struct {
                logic [12:0] value;
            } FB_ADDR;
            struct {
                logic [31:0] value;
            } RSVD_HI;
        } FB_DISPLAY_SYNC;
        struct {
            struct {
                logic [31:0] value;
            } ADDR;
            struct {
                logic [31:0] value;
            } RSVD;
        } MEM_ADDR;
        struct {
            struct {
                logic [31:0] value;
            } DATA;
            struct {
                logic [31:0] value;
            } RSVD;
        } MEM_DATA;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: gpu_regs.COLOR.COLOR0_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_R.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_R.next = next_c;
        field_combo.COLOR.COLOR0_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_R.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_R.load_next) begin
                field_storage.COLOR.COLOR0_R.value <= field_combo.COLOR.COLOR0_R.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_R.value = field_storage.COLOR.COLOR0_R.value;
    // Field: gpu_regs.COLOR.COLOR0_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_G.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_G.next = next_c;
        field_combo.COLOR.COLOR0_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_G.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_G.load_next) begin
                field_storage.COLOR.COLOR0_G.value <= field_combo.COLOR.COLOR0_G.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_G.value = field_storage.COLOR.COLOR0_G.value;
    // Field: gpu_regs.COLOR.COLOR0_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_B.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_B.next = next_c;
        field_combo.COLOR.COLOR0_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_B.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_B.load_next) begin
                field_storage.COLOR.COLOR0_B.value <= field_combo.COLOR.COLOR0_B.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_B.value = field_storage.COLOR.COLOR0_B.value;
    // Field: gpu_regs.COLOR.COLOR0_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR0_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR0_A.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR0_A.next = next_c;
        field_combo.COLOR.COLOR0_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR0_A.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR0_A.load_next) begin
                field_storage.COLOR.COLOR0_A.value <= field_combo.COLOR.COLOR0_A.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR0_A.value = field_storage.COLOR.COLOR0_A.value;
    // Field: gpu_regs.COLOR.COLOR1_R
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_R.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_R.value & ~decoded_wr_biten[39:32]) | (decoded_wr_data[39:32] & decoded_wr_biten[39:32]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_R.next = next_c;
        field_combo.COLOR.COLOR1_R.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_R.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_R.load_next) begin
                field_storage.COLOR.COLOR1_R.value <= field_combo.COLOR.COLOR1_R.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_R.value = field_storage.COLOR.COLOR1_R.value;
    // Field: gpu_regs.COLOR.COLOR1_G
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_G.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_G.value & ~decoded_wr_biten[47:40]) | (decoded_wr_data[47:40] & decoded_wr_biten[47:40]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_G.next = next_c;
        field_combo.COLOR.COLOR1_G.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_G.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_G.load_next) begin
                field_storage.COLOR.COLOR1_G.value <= field_combo.COLOR.COLOR1_G.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_G.value = field_storage.COLOR.COLOR1_G.value;
    // Field: gpu_regs.COLOR.COLOR1_B
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_B.value & ~decoded_wr_biten[55:48]) | (decoded_wr_data[55:48] & decoded_wr_biten[55:48]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_B.next = next_c;
        field_combo.COLOR.COLOR1_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_B.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_B.load_next) begin
                field_storage.COLOR.COLOR1_B.value <= field_combo.COLOR.COLOR1_B.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_B.value = field_storage.COLOR.COLOR1_B.value;
    // Field: gpu_regs.COLOR.COLOR1_A
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.COLOR.COLOR1_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.COLOR.COLOR1_A.value & ~decoded_wr_biten[63:56]) | (decoded_wr_data[63:56] & decoded_wr_biten[63:56]);
            load_next_c = '1;
        end
        field_combo.COLOR.COLOR1_A.next = next_c;
        field_combo.COLOR.COLOR1_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.COLOR.COLOR1_A.value <= 8'h0;
        end else begin
            if(field_combo.COLOR.COLOR1_A.load_next) begin
                field_storage.COLOR.COLOR1_A.value <= field_combo.COLOR.COLOR1_A.next;
            end
        end
    end
    assign hwif_out.COLOR.COLOR1_A.value = field_storage.COLOR.COLOR1_A.value;
    // Field: gpu_regs.UV0_UV1.UV0_UQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV0_UQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV0_UQ.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV0_UQ.next = next_c;
        field_combo.UV0_UV1.UV0_UQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV0_UQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV0_UQ.load_next) begin
                field_storage.UV0_UV1.UV0_UQ.value <= field_combo.UV0_UV1.UV0_UQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV0_UQ.value = field_storage.UV0_UV1.UV0_UQ.value;
    // Field: gpu_regs.UV0_UV1.UV0_VQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV0_VQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV0_VQ.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV0_VQ.next = next_c;
        field_combo.UV0_UV1.UV0_VQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV0_VQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV0_VQ.load_next) begin
                field_storage.UV0_UV1.UV0_VQ.value <= field_combo.UV0_UV1.UV0_VQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV0_VQ.value = field_storage.UV0_UV1.UV0_VQ.value;
    // Field: gpu_regs.UV0_UV1.UV1_UQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV1_UQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV1_UQ.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV1_UQ.next = next_c;
        field_combo.UV0_UV1.UV1_UQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV1_UQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV1_UQ.load_next) begin
                field_storage.UV0_UV1.UV1_UQ.value <= field_combo.UV0_UV1.UV1_UQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV1_UQ.value = field_storage.UV0_UV1.UV1_UQ.value;
    // Field: gpu_regs.UV0_UV1.UV1_VQ
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.UV0_UV1.UV1_VQ.value;
        load_next_c = '0;
        if(decoded_reg_strb.UV0_UV1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UV0_UV1.UV1_VQ.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.UV0_UV1.UV1_VQ.next = next_c;
        field_combo.UV0_UV1.UV1_VQ.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UV0_UV1.UV1_VQ.value <= 16'h0;
        end else begin
            if(field_combo.UV0_UV1.UV1_VQ.load_next) begin
                field_storage.UV0_UV1.UV1_VQ.value <= field_combo.UV0_UV1.UV1_VQ.next;
            end
        end
    end
    assign hwif_out.UV0_UV1.UV1_VQ.value = field_storage.UV0_UV1.UV1_VQ.value;
    // Field: gpu_regs.LIGHT_DIR.X_DIR
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.LIGHT_DIR.X_DIR.value;
        load_next_c = '0;
        if(decoded_reg_strb.LIGHT_DIR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.LIGHT_DIR.X_DIR.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.LIGHT_DIR.X_DIR.next = next_c;
        field_combo.LIGHT_DIR.X_DIR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.LIGHT_DIR.X_DIR.value <= 8'h0;
        end else begin
            if(field_combo.LIGHT_DIR.X_DIR.load_next) begin
                field_storage.LIGHT_DIR.X_DIR.value <= field_combo.LIGHT_DIR.X_DIR.next;
            end
        end
    end
    assign hwif_out.LIGHT_DIR.X_DIR.value = field_storage.LIGHT_DIR.X_DIR.value;
    // Field: gpu_regs.LIGHT_DIR.Y_DIR
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.LIGHT_DIR.Y_DIR.value;
        load_next_c = '0;
        if(decoded_reg_strb.LIGHT_DIR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.LIGHT_DIR.Y_DIR.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.LIGHT_DIR.Y_DIR.next = next_c;
        field_combo.LIGHT_DIR.Y_DIR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.LIGHT_DIR.Y_DIR.value <= 8'h0;
        end else begin
            if(field_combo.LIGHT_DIR.Y_DIR.load_next) begin
                field_storage.LIGHT_DIR.Y_DIR.value <= field_combo.LIGHT_DIR.Y_DIR.next;
            end
        end
    end
    assign hwif_out.LIGHT_DIR.Y_DIR.value = field_storage.LIGHT_DIR.Y_DIR.value;
    // Field: gpu_regs.LIGHT_DIR.Z_DIR
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.LIGHT_DIR.Z_DIR.value;
        load_next_c = '0;
        if(decoded_reg_strb.LIGHT_DIR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.LIGHT_DIR.Z_DIR.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.LIGHT_DIR.Z_DIR.next = next_c;
        field_combo.LIGHT_DIR.Z_DIR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.LIGHT_DIR.Z_DIR.value <= 8'h0;
        end else begin
            if(field_combo.LIGHT_DIR.Z_DIR.load_next) begin
                field_storage.LIGHT_DIR.Z_DIR.value <= field_combo.LIGHT_DIR.Z_DIR.next;
            end
        end
    end
    assign hwif_out.LIGHT_DIR.Z_DIR.value = field_storage.LIGHT_DIR.Z_DIR.value;
    // Field: gpu_regs.LIGHT_DIR.RSVD
    always_comb begin
        automatic logic [39:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.LIGHT_DIR.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.LIGHT_DIR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.LIGHT_DIR.RSVD.value & ~decoded_wr_biten[63:24]) | (decoded_wr_data[63:24] & decoded_wr_biten[63:24]);
            load_next_c = '1;
        end
        field_combo.LIGHT_DIR.RSVD.next = next_c;
        field_combo.LIGHT_DIR.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.LIGHT_DIR.RSVD.value <= 40'h0;
        end else begin
            if(field_combo.LIGHT_DIR.RSVD.load_next) begin
                field_storage.LIGHT_DIR.RSVD.value <= field_combo.LIGHT_DIR.RSVD.next;
            end
        end
    end
    assign hwif_out.LIGHT_DIR.RSVD.value = field_storage.LIGHT_DIR.RSVD.value;
    // Field: gpu_regs.VERTEX_NOKICK.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.X.next = next_c;
        field_combo.VERTEX_NOKICK.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.X.load_next) begin
                field_storage.VERTEX_NOKICK.X.value <= field_combo.VERTEX_NOKICK.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.X.value = field_storage.VERTEX_NOKICK.X.value;
    // Field: gpu_regs.VERTEX_NOKICK.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Y.next = next_c;
        field_combo.VERTEX_NOKICK.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Y.load_next) begin
                field_storage.VERTEX_NOKICK.Y.value <= field_combo.VERTEX_NOKICK.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Y.value = field_storage.VERTEX_NOKICK.Y.value;
    // Field: gpu_regs.VERTEX_NOKICK.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Z.next = next_c;
        field_combo.VERTEX_NOKICK.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Z.load_next) begin
                field_storage.VERTEX_NOKICK.Z.value <= field_combo.VERTEX_NOKICK.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Z.value = field_storage.VERTEX_NOKICK.Z.value;
    // Field: gpu_regs.VERTEX_NOKICK.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_NOKICK.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_NOKICK && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_NOKICK.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_NOKICK.Q.next = next_c;
        field_combo.VERTEX_NOKICK.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_NOKICK.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_NOKICK.Q.load_next) begin
                field_storage.VERTEX_NOKICK.Q.value <= field_combo.VERTEX_NOKICK.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_NOKICK.Q.value = field_storage.VERTEX_NOKICK.Q.value;
    // Field: gpu_regs.VERTEX_KICK_012.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.X.next = next_c;
        field_combo.VERTEX_KICK_012.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.X.load_next) begin
                field_storage.VERTEX_KICK_012.X.value <= field_combo.VERTEX_KICK_012.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.X.value = field_storage.VERTEX_KICK_012.X.value;
    // Field: gpu_regs.VERTEX_KICK_012.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Y.next = next_c;
        field_combo.VERTEX_KICK_012.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Y.load_next) begin
                field_storage.VERTEX_KICK_012.Y.value <= field_combo.VERTEX_KICK_012.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Y.value = field_storage.VERTEX_KICK_012.Y.value;
    // Field: gpu_regs.VERTEX_KICK_012.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Z.next = next_c;
        field_combo.VERTEX_KICK_012.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Z.load_next) begin
                field_storage.VERTEX_KICK_012.Z.value <= field_combo.VERTEX_KICK_012.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Z.value = field_storage.VERTEX_KICK_012.Z.value;
    // Field: gpu_regs.VERTEX_KICK_012.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_012.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_012 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_012.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_012.Q.next = next_c;
        field_combo.VERTEX_KICK_012.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_012.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_012.Q.load_next) begin
                field_storage.VERTEX_KICK_012.Q.value <= field_combo.VERTEX_KICK_012.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_012.Q.value = field_storage.VERTEX_KICK_012.Q.value;
    // Field: gpu_regs.VERTEX_KICK_021.X
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.X.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.X.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.X.next = next_c;
        field_combo.VERTEX_KICK_021.X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.X.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.X.load_next) begin
                field_storage.VERTEX_KICK_021.X.value <= field_combo.VERTEX_KICK_021.X.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.X.value = field_storage.VERTEX_KICK_021.X.value;
    // Field: gpu_regs.VERTEX_KICK_021.Y
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Y.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Y.next = next_c;
        field_combo.VERTEX_KICK_021.Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Y.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Y.load_next) begin
                field_storage.VERTEX_KICK_021.Y.value <= field_combo.VERTEX_KICK_021.Y.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Y.value = field_storage.VERTEX_KICK_021.Y.value;
    // Field: gpu_regs.VERTEX_KICK_021.Z
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Z.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Z.value & ~decoded_wr_biten[47:32]) | (decoded_wr_data[47:32] & decoded_wr_biten[47:32]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Z.next = next_c;
        field_combo.VERTEX_KICK_021.Z.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Z.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Z.load_next) begin
                field_storage.VERTEX_KICK_021.Z.value <= field_combo.VERTEX_KICK_021.Z.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Z.value = field_storage.VERTEX_KICK_021.Z.value;
    // Field: gpu_regs.VERTEX_KICK_021.Q
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.VERTEX_KICK_021.Q.value;
        load_next_c = '0;
        if(decoded_reg_strb.VERTEX_KICK_021 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.VERTEX_KICK_021.Q.value & ~decoded_wr_biten[63:48]) | (decoded_wr_data[63:48] & decoded_wr_biten[63:48]);
            load_next_c = '1;
        end
        field_combo.VERTEX_KICK_021.Q.next = next_c;
        field_combo.VERTEX_KICK_021.Q.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.VERTEX_KICK_021.Q.value <= 16'h0;
        end else begin
            if(field_combo.VERTEX_KICK_021.Q.load_next) begin
                field_storage.VERTEX_KICK_021.Q.value <= field_combo.VERTEX_KICK_021.Q.next;
            end
        end
    end
    assign hwif_out.VERTEX_KICK_021.Q.value = field_storage.VERTEX_KICK_021.Q.value;
    // Field: gpu_regs.TEX0_BASE.RSVD_LO
    always_comb begin
        automatic logic [11:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_BASE.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_BASE.RSVD_LO.value & ~decoded_wr_biten[11:0]) | (decoded_wr_data[11:0] & decoded_wr_biten[11:0]);
            load_next_c = '1;
        end
        field_combo.TEX0_BASE.RSVD_LO.next = next_c;
        field_combo.TEX0_BASE.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_BASE.RSVD_LO.value <= 12'h0;
        end else begin
            if(field_combo.TEX0_BASE.RSVD_LO.load_next) begin
                field_storage.TEX0_BASE.RSVD_LO.value <= field_combo.TEX0_BASE.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.TEX0_BASE.RSVD_LO.value = field_storage.TEX0_BASE.RSVD_LO.value;
    // Field: gpu_regs.TEX0_BASE.BASE_ADDR
    always_comb begin
        automatic logic [19:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_BASE.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_BASE.BASE_ADDR.value & ~decoded_wr_biten[31:12]) | (decoded_wr_data[31:12] & decoded_wr_biten[31:12]);
            load_next_c = '1;
        end
        field_combo.TEX0_BASE.BASE_ADDR.next = next_c;
        field_combo.TEX0_BASE.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_BASE.BASE_ADDR.value <= 20'h0;
        end else begin
            if(field_combo.TEX0_BASE.BASE_ADDR.load_next) begin
                field_storage.TEX0_BASE.BASE_ADDR.value <= field_combo.TEX0_BASE.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.TEX0_BASE.BASE_ADDR.value = field_storage.TEX0_BASE.BASE_ADDR.value;
    // Field: gpu_regs.TEX0_BASE.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_BASE.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_BASE.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.TEX0_BASE.RSVD_HI.next = next_c;
        field_combo.TEX0_BASE.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_BASE.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.TEX0_BASE.RSVD_HI.load_next) begin
                field_storage.TEX0_BASE.RSVD_HI.value <= field_combo.TEX0_BASE.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX0_BASE.RSVD_HI.value = field_storage.TEX0_BASE.RSVD_HI.value;
    // Field: gpu_regs.TEX0_FMT.ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.ENABLE.next = next_c;
        field_combo.TEX0_FMT.ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.TEX0_FMT.ENABLE.load_next) begin
                field_storage.TEX0_FMT.ENABLE.value <= field_combo.TEX0_FMT.ENABLE.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.ENABLE.value = field_storage.TEX0_FMT.ENABLE.value;
    // Field: gpu_regs.TEX0_FMT.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.RSVD_1.next = next_c;
        field_combo.TEX0_FMT.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.TEX0_FMT.RSVD_1.load_next) begin
                field_storage.TEX0_FMT.RSVD_1.value <= field_combo.TEX0_FMT.RSVD_1.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.RSVD_1.value = field_storage.TEX0_FMT.RSVD_1.value;
    // Field: gpu_regs.TEX0_FMT.FORMAT
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.FORMAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.FORMAT.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.FORMAT.next = next_c;
        field_combo.TEX0_FMT.FORMAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.FORMAT.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_FMT.FORMAT.load_next) begin
                field_storage.TEX0_FMT.FORMAT.value <= field_combo.TEX0_FMT.FORMAT.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.FORMAT.value = field_storage.TEX0_FMT.FORMAT.value;
    // Field: gpu_regs.TEX0_FMT.RSVD_54
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.RSVD_54.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.RSVD_54.value & ~decoded_wr_biten[5:4]) | (decoded_wr_data[5:4] & decoded_wr_biten[5:4]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.RSVD_54.next = next_c;
        field_combo.TEX0_FMT.RSVD_54.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.RSVD_54.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_FMT.RSVD_54.load_next) begin
                field_storage.TEX0_FMT.RSVD_54.value <= field_combo.TEX0_FMT.RSVD_54.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.RSVD_54.value = field_storage.TEX0_FMT.RSVD_54.value;
    // Field: gpu_regs.TEX0_FMT.FILTER
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.FILTER.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.FILTER.value & ~decoded_wr_biten[7:6]) | (decoded_wr_data[7:6] & decoded_wr_biten[7:6]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.FILTER.next = next_c;
        field_combo.TEX0_FMT.FILTER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.FILTER.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_FMT.FILTER.load_next) begin
                field_storage.TEX0_FMT.FILTER.value <= field_combo.TEX0_FMT.FILTER.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.FILTER.value = field_storage.TEX0_FMT.FILTER.value;
    // Field: gpu_regs.TEX0_FMT.WIDTH_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.WIDTH_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.WIDTH_LOG2.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.WIDTH_LOG2.next = next_c;
        field_combo.TEX0_FMT.WIDTH_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.WIDTH_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_FMT.WIDTH_LOG2.load_next) begin
                field_storage.TEX0_FMT.WIDTH_LOG2.value <= field_combo.TEX0_FMT.WIDTH_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.WIDTH_LOG2.value = field_storage.TEX0_FMT.WIDTH_LOG2.value;
    // Field: gpu_regs.TEX0_FMT.HEIGHT_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.HEIGHT_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.HEIGHT_LOG2.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.HEIGHT_LOG2.next = next_c;
        field_combo.TEX0_FMT.HEIGHT_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.HEIGHT_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_FMT.HEIGHT_LOG2.load_next) begin
                field_storage.TEX0_FMT.HEIGHT_LOG2.value <= field_combo.TEX0_FMT.HEIGHT_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.HEIGHT_LOG2.value = field_storage.TEX0_FMT.HEIGHT_LOG2.value;
    // Field: gpu_regs.TEX0_FMT.SWIZZLE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.SWIZZLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.SWIZZLE.value & ~decoded_wr_biten[19:16]) | (decoded_wr_data[19:16] & decoded_wr_biten[19:16]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.SWIZZLE.next = next_c;
        field_combo.TEX0_FMT.SWIZZLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.SWIZZLE.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_FMT.SWIZZLE.load_next) begin
                field_storage.TEX0_FMT.SWIZZLE.value <= field_combo.TEX0_FMT.SWIZZLE.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.SWIZZLE.value = field_storage.TEX0_FMT.SWIZZLE.value;
    // Field: gpu_regs.TEX0_FMT.MIP_LEVELS
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.MIP_LEVELS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.MIP_LEVELS.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.MIP_LEVELS.next = next_c;
        field_combo.TEX0_FMT.MIP_LEVELS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.MIP_LEVELS.value <= 4'h0;
        end else begin
            if(field_combo.TEX0_FMT.MIP_LEVELS.load_next) begin
                field_storage.TEX0_FMT.MIP_LEVELS.value <= field_combo.TEX0_FMT.MIP_LEVELS.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.MIP_LEVELS.value = field_storage.TEX0_FMT.MIP_LEVELS.value;
    // Field: gpu_regs.TEX0_FMT.RSVD_HI
    always_comb begin
        automatic logic [39:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_FMT.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_FMT.RSVD_HI.value & ~decoded_wr_biten[63:24]) | (decoded_wr_data[63:24] & decoded_wr_biten[63:24]);
            load_next_c = '1;
        end
        field_combo.TEX0_FMT.RSVD_HI.next = next_c;
        field_combo.TEX0_FMT.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_FMT.RSVD_HI.value <= 40'h0;
        end else begin
            if(field_combo.TEX0_FMT.RSVD_HI.load_next) begin
                field_storage.TEX0_FMT.RSVD_HI.value <= field_combo.TEX0_FMT.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX0_FMT.RSVD_HI.value = field_storage.TEX0_FMT.RSVD_HI.value;
    // Field: gpu_regs.TEX0_MIP_BIAS.MIP_BIAS
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_MIP_BIAS.MIP_BIAS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_MIP_BIAS && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_MIP_BIAS.MIP_BIAS.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.TEX0_MIP_BIAS.MIP_BIAS.next = next_c;
        field_combo.TEX0_MIP_BIAS.MIP_BIAS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_MIP_BIAS.MIP_BIAS.value <= 8'h0;
        end else begin
            if(field_combo.TEX0_MIP_BIAS.MIP_BIAS.load_next) begin
                field_storage.TEX0_MIP_BIAS.MIP_BIAS.value <= field_combo.TEX0_MIP_BIAS.MIP_BIAS.next;
            end
        end
    end
    assign hwif_out.TEX0_MIP_BIAS.MIP_BIAS.value = field_storage.TEX0_MIP_BIAS.MIP_BIAS.value;
    // Field: gpu_regs.TEX0_MIP_BIAS.RSVD
    always_comb begin
        automatic logic [55:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_MIP_BIAS.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_MIP_BIAS && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_MIP_BIAS.RSVD.value & ~decoded_wr_biten[63:8]) | (decoded_wr_data[63:8] & decoded_wr_biten[63:8]);
            load_next_c = '1;
        end
        field_combo.TEX0_MIP_BIAS.RSVD.next = next_c;
        field_combo.TEX0_MIP_BIAS.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_MIP_BIAS.RSVD.value <= 56'h0;
        end else begin
            if(field_combo.TEX0_MIP_BIAS.RSVD.load_next) begin
                field_storage.TEX0_MIP_BIAS.RSVD.value <= field_combo.TEX0_MIP_BIAS.RSVD.next;
            end
        end
    end
    assign hwif_out.TEX0_MIP_BIAS.RSVD.value = field_storage.TEX0_MIP_BIAS.RSVD.value;
    // Field: gpu_regs.TEX0_WRAP.U_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_WRAP.U_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_WRAP.U_WRAP.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end
        field_combo.TEX0_WRAP.U_WRAP.next = next_c;
        field_combo.TEX0_WRAP.U_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_WRAP.U_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_WRAP.U_WRAP.load_next) begin
                field_storage.TEX0_WRAP.U_WRAP.value <= field_combo.TEX0_WRAP.U_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX0_WRAP.U_WRAP.value = field_storage.TEX0_WRAP.U_WRAP.value;
    // Field: gpu_regs.TEX0_WRAP.V_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_WRAP.V_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_WRAP.V_WRAP.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX0_WRAP.V_WRAP.next = next_c;
        field_combo.TEX0_WRAP.V_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_WRAP.V_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX0_WRAP.V_WRAP.load_next) begin
                field_storage.TEX0_WRAP.V_WRAP.value <= field_combo.TEX0_WRAP.V_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX0_WRAP.V_WRAP.value = field_storage.TEX0_WRAP.V_WRAP.value;
    // Field: gpu_regs.TEX0_WRAP.RSVD
    always_comb begin
        automatic logic [59:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX0_WRAP.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX0_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX0_WRAP.RSVD.value & ~decoded_wr_biten[63:4]) | (decoded_wr_data[63:4] & decoded_wr_biten[63:4]);
            load_next_c = '1;
        end
        field_combo.TEX0_WRAP.RSVD.next = next_c;
        field_combo.TEX0_WRAP.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX0_WRAP.RSVD.value <= 60'h0;
        end else begin
            if(field_combo.TEX0_WRAP.RSVD.load_next) begin
                field_storage.TEX0_WRAP.RSVD.value <= field_combo.TEX0_WRAP.RSVD.next;
            end
        end
    end
    assign hwif_out.TEX0_WRAP.RSVD.value = field_storage.TEX0_WRAP.RSVD.value;
    // Field: gpu_regs.TEX1_BASE.RSVD_LO
    always_comb begin
        automatic logic [11:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_BASE.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_BASE.RSVD_LO.value & ~decoded_wr_biten[11:0]) | (decoded_wr_data[11:0] & decoded_wr_biten[11:0]);
            load_next_c = '1;
        end
        field_combo.TEX1_BASE.RSVD_LO.next = next_c;
        field_combo.TEX1_BASE.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_BASE.RSVD_LO.value <= 12'h0;
        end else begin
            if(field_combo.TEX1_BASE.RSVD_LO.load_next) begin
                field_storage.TEX1_BASE.RSVD_LO.value <= field_combo.TEX1_BASE.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.TEX1_BASE.RSVD_LO.value = field_storage.TEX1_BASE.RSVD_LO.value;
    // Field: gpu_regs.TEX1_BASE.BASE_ADDR
    always_comb begin
        automatic logic [19:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_BASE.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_BASE.BASE_ADDR.value & ~decoded_wr_biten[31:12]) | (decoded_wr_data[31:12] & decoded_wr_biten[31:12]);
            load_next_c = '1;
        end
        field_combo.TEX1_BASE.BASE_ADDR.next = next_c;
        field_combo.TEX1_BASE.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_BASE.BASE_ADDR.value <= 20'h0;
        end else begin
            if(field_combo.TEX1_BASE.BASE_ADDR.load_next) begin
                field_storage.TEX1_BASE.BASE_ADDR.value <= field_combo.TEX1_BASE.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.TEX1_BASE.BASE_ADDR.value = field_storage.TEX1_BASE.BASE_ADDR.value;
    // Field: gpu_regs.TEX1_BASE.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_BASE.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_BASE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_BASE.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.TEX1_BASE.RSVD_HI.next = next_c;
        field_combo.TEX1_BASE.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_BASE.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.TEX1_BASE.RSVD_HI.load_next) begin
                field_storage.TEX1_BASE.RSVD_HI.value <= field_combo.TEX1_BASE.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX1_BASE.RSVD_HI.value = field_storage.TEX1_BASE.RSVD_HI.value;
    // Field: gpu_regs.TEX1_FMT.ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.ENABLE.next = next_c;
        field_combo.TEX1_FMT.ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.TEX1_FMT.ENABLE.load_next) begin
                field_storage.TEX1_FMT.ENABLE.value <= field_combo.TEX1_FMT.ENABLE.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.ENABLE.value = field_storage.TEX1_FMT.ENABLE.value;
    // Field: gpu_regs.TEX1_FMT.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.RSVD_1.next = next_c;
        field_combo.TEX1_FMT.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.TEX1_FMT.RSVD_1.load_next) begin
                field_storage.TEX1_FMT.RSVD_1.value <= field_combo.TEX1_FMT.RSVD_1.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.RSVD_1.value = field_storage.TEX1_FMT.RSVD_1.value;
    // Field: gpu_regs.TEX1_FMT.FORMAT
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.FORMAT.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.FORMAT.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.FORMAT.next = next_c;
        field_combo.TEX1_FMT.FORMAT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.FORMAT.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_FMT.FORMAT.load_next) begin
                field_storage.TEX1_FMT.FORMAT.value <= field_combo.TEX1_FMT.FORMAT.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.FORMAT.value = field_storage.TEX1_FMT.FORMAT.value;
    // Field: gpu_regs.TEX1_FMT.RSVD_54
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.RSVD_54.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.RSVD_54.value & ~decoded_wr_biten[5:4]) | (decoded_wr_data[5:4] & decoded_wr_biten[5:4]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.RSVD_54.next = next_c;
        field_combo.TEX1_FMT.RSVD_54.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.RSVD_54.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_FMT.RSVD_54.load_next) begin
                field_storage.TEX1_FMT.RSVD_54.value <= field_combo.TEX1_FMT.RSVD_54.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.RSVD_54.value = field_storage.TEX1_FMT.RSVD_54.value;
    // Field: gpu_regs.TEX1_FMT.FILTER
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.FILTER.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.FILTER.value & ~decoded_wr_biten[7:6]) | (decoded_wr_data[7:6] & decoded_wr_biten[7:6]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.FILTER.next = next_c;
        field_combo.TEX1_FMT.FILTER.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.FILTER.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_FMT.FILTER.load_next) begin
                field_storage.TEX1_FMT.FILTER.value <= field_combo.TEX1_FMT.FILTER.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.FILTER.value = field_storage.TEX1_FMT.FILTER.value;
    // Field: gpu_regs.TEX1_FMT.WIDTH_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.WIDTH_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.WIDTH_LOG2.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.WIDTH_LOG2.next = next_c;
        field_combo.TEX1_FMT.WIDTH_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.WIDTH_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_FMT.WIDTH_LOG2.load_next) begin
                field_storage.TEX1_FMT.WIDTH_LOG2.value <= field_combo.TEX1_FMT.WIDTH_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.WIDTH_LOG2.value = field_storage.TEX1_FMT.WIDTH_LOG2.value;
    // Field: gpu_regs.TEX1_FMT.HEIGHT_LOG2
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.HEIGHT_LOG2.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.HEIGHT_LOG2.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.HEIGHT_LOG2.next = next_c;
        field_combo.TEX1_FMT.HEIGHT_LOG2.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.HEIGHT_LOG2.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_FMT.HEIGHT_LOG2.load_next) begin
                field_storage.TEX1_FMT.HEIGHT_LOG2.value <= field_combo.TEX1_FMT.HEIGHT_LOG2.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.HEIGHT_LOG2.value = field_storage.TEX1_FMT.HEIGHT_LOG2.value;
    // Field: gpu_regs.TEX1_FMT.SWIZZLE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.SWIZZLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.SWIZZLE.value & ~decoded_wr_biten[19:16]) | (decoded_wr_data[19:16] & decoded_wr_biten[19:16]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.SWIZZLE.next = next_c;
        field_combo.TEX1_FMT.SWIZZLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.SWIZZLE.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_FMT.SWIZZLE.load_next) begin
                field_storage.TEX1_FMT.SWIZZLE.value <= field_combo.TEX1_FMT.SWIZZLE.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.SWIZZLE.value = field_storage.TEX1_FMT.SWIZZLE.value;
    // Field: gpu_regs.TEX1_FMT.MIP_LEVELS
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.MIP_LEVELS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.MIP_LEVELS.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.MIP_LEVELS.next = next_c;
        field_combo.TEX1_FMT.MIP_LEVELS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.MIP_LEVELS.value <= 4'h0;
        end else begin
            if(field_combo.TEX1_FMT.MIP_LEVELS.load_next) begin
                field_storage.TEX1_FMT.MIP_LEVELS.value <= field_combo.TEX1_FMT.MIP_LEVELS.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.MIP_LEVELS.value = field_storage.TEX1_FMT.MIP_LEVELS.value;
    // Field: gpu_regs.TEX1_FMT.RSVD_HI
    always_comb begin
        automatic logic [39:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_FMT.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_FMT && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_FMT.RSVD_HI.value & ~decoded_wr_biten[63:24]) | (decoded_wr_data[63:24] & decoded_wr_biten[63:24]);
            load_next_c = '1;
        end
        field_combo.TEX1_FMT.RSVD_HI.next = next_c;
        field_combo.TEX1_FMT.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_FMT.RSVD_HI.value <= 40'h0;
        end else begin
            if(field_combo.TEX1_FMT.RSVD_HI.load_next) begin
                field_storage.TEX1_FMT.RSVD_HI.value <= field_combo.TEX1_FMT.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.TEX1_FMT.RSVD_HI.value = field_storage.TEX1_FMT.RSVD_HI.value;
    // Field: gpu_regs.TEX1_MIP_BIAS.MIP_BIAS
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_MIP_BIAS.MIP_BIAS.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_MIP_BIAS && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_MIP_BIAS.MIP_BIAS.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.TEX1_MIP_BIAS.MIP_BIAS.next = next_c;
        field_combo.TEX1_MIP_BIAS.MIP_BIAS.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_MIP_BIAS.MIP_BIAS.value <= 8'h0;
        end else begin
            if(field_combo.TEX1_MIP_BIAS.MIP_BIAS.load_next) begin
                field_storage.TEX1_MIP_BIAS.MIP_BIAS.value <= field_combo.TEX1_MIP_BIAS.MIP_BIAS.next;
            end
        end
    end
    assign hwif_out.TEX1_MIP_BIAS.MIP_BIAS.value = field_storage.TEX1_MIP_BIAS.MIP_BIAS.value;
    // Field: gpu_regs.TEX1_MIP_BIAS.RSVD
    always_comb begin
        automatic logic [55:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_MIP_BIAS.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_MIP_BIAS && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_MIP_BIAS.RSVD.value & ~decoded_wr_biten[63:8]) | (decoded_wr_data[63:8] & decoded_wr_biten[63:8]);
            load_next_c = '1;
        end
        field_combo.TEX1_MIP_BIAS.RSVD.next = next_c;
        field_combo.TEX1_MIP_BIAS.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_MIP_BIAS.RSVD.value <= 56'h0;
        end else begin
            if(field_combo.TEX1_MIP_BIAS.RSVD.load_next) begin
                field_storage.TEX1_MIP_BIAS.RSVD.value <= field_combo.TEX1_MIP_BIAS.RSVD.next;
            end
        end
    end
    assign hwif_out.TEX1_MIP_BIAS.RSVD.value = field_storage.TEX1_MIP_BIAS.RSVD.value;
    // Field: gpu_regs.TEX1_WRAP.U_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_WRAP.U_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_WRAP.U_WRAP.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end
        field_combo.TEX1_WRAP.U_WRAP.next = next_c;
        field_combo.TEX1_WRAP.U_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_WRAP.U_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_WRAP.U_WRAP.load_next) begin
                field_storage.TEX1_WRAP.U_WRAP.value <= field_combo.TEX1_WRAP.U_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX1_WRAP.U_WRAP.value = field_storage.TEX1_WRAP.U_WRAP.value;
    // Field: gpu_regs.TEX1_WRAP.V_WRAP
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_WRAP.V_WRAP.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_WRAP.V_WRAP.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.TEX1_WRAP.V_WRAP.next = next_c;
        field_combo.TEX1_WRAP.V_WRAP.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_WRAP.V_WRAP.value <= 2'h0;
        end else begin
            if(field_combo.TEX1_WRAP.V_WRAP.load_next) begin
                field_storage.TEX1_WRAP.V_WRAP.value <= field_combo.TEX1_WRAP.V_WRAP.next;
            end
        end
    end
    assign hwif_out.TEX1_WRAP.V_WRAP.value = field_storage.TEX1_WRAP.V_WRAP.value;
    // Field: gpu_regs.TEX1_WRAP.RSVD
    always_comb begin
        automatic logic [59:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.TEX1_WRAP.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.TEX1_WRAP && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.TEX1_WRAP.RSVD.value & ~decoded_wr_biten[63:4]) | (decoded_wr_data[63:4] & decoded_wr_biten[63:4]);
            load_next_c = '1;
        end
        field_combo.TEX1_WRAP.RSVD.next = next_c;
        field_combo.TEX1_WRAP.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.TEX1_WRAP.RSVD.value <= 60'h0;
        end else begin
            if(field_combo.TEX1_WRAP.RSVD.load_next) begin
                field_storage.TEX1_WRAP.RSVD.value <= field_combo.TEX1_WRAP.RSVD.next;
            end
        end
    end
    assign hwif_out.TEX1_WRAP.RSVD.value = field_storage.TEX1_WRAP.RSVD.value;
    // Field: gpu_regs.CC_MODE.CC_ALPHA_A
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_ALPHA_A.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_ALPHA_A.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_ALPHA_A.next = next_c;
        field_combo.CC_MODE.CC_ALPHA_A.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_ALPHA_A.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_ALPHA_A.load_next) begin
                field_storage.CC_MODE.CC_ALPHA_A.value <= field_combo.CC_MODE.CC_ALPHA_A.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_ALPHA_A.value = field_storage.CC_MODE.CC_ALPHA_A.value;
    // Field: gpu_regs.CC_MODE.CC_ALPHA_B
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_ALPHA_B.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_ALPHA_B.value & ~decoded_wr_biten[7:4]) | (decoded_wr_data[7:4] & decoded_wr_biten[7:4]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_ALPHA_B.next = next_c;
        field_combo.CC_MODE.CC_ALPHA_B.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_ALPHA_B.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_ALPHA_B.load_next) begin
                field_storage.CC_MODE.CC_ALPHA_B.value <= field_combo.CC_MODE.CC_ALPHA_B.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_ALPHA_B.value = field_storage.CC_MODE.CC_ALPHA_B.value;
    // Field: gpu_regs.CC_MODE.CC_ALPHA_C
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_ALPHA_C.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_ALPHA_C.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_ALPHA_C.next = next_c;
        field_combo.CC_MODE.CC_ALPHA_C.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_ALPHA_C.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_ALPHA_C.load_next) begin
                field_storage.CC_MODE.CC_ALPHA_C.value <= field_combo.CC_MODE.CC_ALPHA_C.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_ALPHA_C.value = field_storage.CC_MODE.CC_ALPHA_C.value;
    // Field: gpu_regs.CC_MODE.CC_ALPHA_D
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_ALPHA_D.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_ALPHA_D.value & ~decoded_wr_biten[15:12]) | (decoded_wr_data[15:12] & decoded_wr_biten[15:12]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_ALPHA_D.next = next_c;
        field_combo.CC_MODE.CC_ALPHA_D.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_ALPHA_D.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_ALPHA_D.load_next) begin
                field_storage.CC_MODE.CC_ALPHA_D.value <= field_combo.CC_MODE.CC_ALPHA_D.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_ALPHA_D.value = field_storage.CC_MODE.CC_ALPHA_D.value;
    // Field: gpu_regs.CC_MODE.CC_A_SOURCE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_A_SOURCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_A_SOURCE.value & ~decoded_wr_biten[19:16]) | (decoded_wr_data[19:16] & decoded_wr_biten[19:16]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_A_SOURCE.next = next_c;
        field_combo.CC_MODE.CC_A_SOURCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_A_SOURCE.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_A_SOURCE.load_next) begin
                field_storage.CC_MODE.CC_A_SOURCE.value <= field_combo.CC_MODE.CC_A_SOURCE.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_A_SOURCE.value = field_storage.CC_MODE.CC_A_SOURCE.value;
    // Field: gpu_regs.CC_MODE.CC_B_SOURCE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_B_SOURCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_B_SOURCE.value & ~decoded_wr_biten[23:20]) | (decoded_wr_data[23:20] & decoded_wr_biten[23:20]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_B_SOURCE.next = next_c;
        field_combo.CC_MODE.CC_B_SOURCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_B_SOURCE.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_B_SOURCE.load_next) begin
                field_storage.CC_MODE.CC_B_SOURCE.value <= field_combo.CC_MODE.CC_B_SOURCE.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_B_SOURCE.value = field_storage.CC_MODE.CC_B_SOURCE.value;
    // Field: gpu_regs.CC_MODE.CC_C_SOURCE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_C_SOURCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_C_SOURCE.value & ~decoded_wr_biten[27:24]) | (decoded_wr_data[27:24] & decoded_wr_biten[27:24]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_C_SOURCE.next = next_c;
        field_combo.CC_MODE.CC_C_SOURCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_C_SOURCE.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_C_SOURCE.load_next) begin
                field_storage.CC_MODE.CC_C_SOURCE.value <= field_combo.CC_MODE.CC_C_SOURCE.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_C_SOURCE.value = field_storage.CC_MODE.CC_C_SOURCE.value;
    // Field: gpu_regs.CC_MODE.CC_D_SOURCE
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.CC_D_SOURCE.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.CC_D_SOURCE.value & ~decoded_wr_biten[31:28]) | (decoded_wr_data[31:28] & decoded_wr_biten[31:28]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.CC_D_SOURCE.next = next_c;
        field_combo.CC_MODE.CC_D_SOURCE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.CC_D_SOURCE.value <= 4'h0;
        end else begin
            if(field_combo.CC_MODE.CC_D_SOURCE.load_next) begin
                field_storage.CC_MODE.CC_D_SOURCE.value <= field_combo.CC_MODE.CC_D_SOURCE.next;
            end
        end
    end
    assign hwif_out.CC_MODE.CC_D_SOURCE.value = field_storage.CC_MODE.CC_D_SOURCE.value;
    // Field: gpu_regs.CC_MODE.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.CC_MODE.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.CC_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.CC_MODE.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.CC_MODE.RSVD.next = next_c;
        field_combo.CC_MODE.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.CC_MODE.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.CC_MODE.RSVD.load_next) begin
                field_storage.CC_MODE.RSVD.value <= field_combo.CC_MODE.RSVD.next;
            end
        end
    end
    assign hwif_out.CC_MODE.RSVD.value = field_storage.CC_MODE.RSVD.value;
    // Field: gpu_regs.MAT_COLOR0.RED
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR0.RED.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR0.RED.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR0.RED.next = next_c;
        field_combo.MAT_COLOR0.RED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR0.RED.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR0.RED.load_next) begin
                field_storage.MAT_COLOR0.RED.value <= field_combo.MAT_COLOR0.RED.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR0.RED.value = field_storage.MAT_COLOR0.RED.value;
    // Field: gpu_regs.MAT_COLOR0.GREEN
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR0.GREEN.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR0.GREEN.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR0.GREEN.next = next_c;
        field_combo.MAT_COLOR0.GREEN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR0.GREEN.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR0.GREEN.load_next) begin
                field_storage.MAT_COLOR0.GREEN.value <= field_combo.MAT_COLOR0.GREEN.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR0.GREEN.value = field_storage.MAT_COLOR0.GREEN.value;
    // Field: gpu_regs.MAT_COLOR0.BLUE
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR0.BLUE.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR0.BLUE.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR0.BLUE.next = next_c;
        field_combo.MAT_COLOR0.BLUE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR0.BLUE.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR0.BLUE.load_next) begin
                field_storage.MAT_COLOR0.BLUE.value <= field_combo.MAT_COLOR0.BLUE.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR0.BLUE.value = field_storage.MAT_COLOR0.BLUE.value;
    // Field: gpu_regs.MAT_COLOR0.ALPHA
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR0.ALPHA.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR0.ALPHA.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR0.ALPHA.next = next_c;
        field_combo.MAT_COLOR0.ALPHA.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR0.ALPHA.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR0.ALPHA.load_next) begin
                field_storage.MAT_COLOR0.ALPHA.value <= field_combo.MAT_COLOR0.ALPHA.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR0.ALPHA.value = field_storage.MAT_COLOR0.ALPHA.value;
    // Field: gpu_regs.MAT_COLOR0.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR0.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR0 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR0.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR0.RSVD.next = next_c;
        field_combo.MAT_COLOR0.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR0.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.MAT_COLOR0.RSVD.load_next) begin
                field_storage.MAT_COLOR0.RSVD.value <= field_combo.MAT_COLOR0.RSVD.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR0.RSVD.value = field_storage.MAT_COLOR0.RSVD.value;
    // Field: gpu_regs.MAT_COLOR1.RED
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR1.RED.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR1.RED.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR1.RED.next = next_c;
        field_combo.MAT_COLOR1.RED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR1.RED.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR1.RED.load_next) begin
                field_storage.MAT_COLOR1.RED.value <= field_combo.MAT_COLOR1.RED.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR1.RED.value = field_storage.MAT_COLOR1.RED.value;
    // Field: gpu_regs.MAT_COLOR1.GREEN
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR1.GREEN.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR1.GREEN.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR1.GREEN.next = next_c;
        field_combo.MAT_COLOR1.GREEN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR1.GREEN.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR1.GREEN.load_next) begin
                field_storage.MAT_COLOR1.GREEN.value <= field_combo.MAT_COLOR1.GREEN.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR1.GREEN.value = field_storage.MAT_COLOR1.GREEN.value;
    // Field: gpu_regs.MAT_COLOR1.BLUE
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR1.BLUE.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR1.BLUE.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR1.BLUE.next = next_c;
        field_combo.MAT_COLOR1.BLUE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR1.BLUE.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR1.BLUE.load_next) begin
                field_storage.MAT_COLOR1.BLUE.value <= field_combo.MAT_COLOR1.BLUE.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR1.BLUE.value = field_storage.MAT_COLOR1.BLUE.value;
    // Field: gpu_regs.MAT_COLOR1.ALPHA
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR1.ALPHA.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR1.ALPHA.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR1.ALPHA.next = next_c;
        field_combo.MAT_COLOR1.ALPHA.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR1.ALPHA.value <= 8'h0;
        end else begin
            if(field_combo.MAT_COLOR1.ALPHA.load_next) begin
                field_storage.MAT_COLOR1.ALPHA.value <= field_combo.MAT_COLOR1.ALPHA.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR1.ALPHA.value = field_storage.MAT_COLOR1.ALPHA.value;
    // Field: gpu_regs.MAT_COLOR1.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MAT_COLOR1.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MAT_COLOR1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MAT_COLOR1.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.MAT_COLOR1.RSVD.next = next_c;
        field_combo.MAT_COLOR1.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MAT_COLOR1.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.MAT_COLOR1.RSVD.load_next) begin
                field_storage.MAT_COLOR1.RSVD.value <= field_combo.MAT_COLOR1.RSVD.next;
            end
        end
    end
    assign hwif_out.MAT_COLOR1.RSVD.value = field_storage.MAT_COLOR1.RSVD.value;
    // Field: gpu_regs.FOG_COLOR.RED
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FOG_COLOR.RED.value;
        load_next_c = '0;
        if(decoded_reg_strb.FOG_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FOG_COLOR.RED.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.FOG_COLOR.RED.next = next_c;
        field_combo.FOG_COLOR.RED.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FOG_COLOR.RED.value <= 8'h0;
        end else begin
            if(field_combo.FOG_COLOR.RED.load_next) begin
                field_storage.FOG_COLOR.RED.value <= field_combo.FOG_COLOR.RED.next;
            end
        end
    end
    assign hwif_out.FOG_COLOR.RED.value = field_storage.FOG_COLOR.RED.value;
    // Field: gpu_regs.FOG_COLOR.GREEN
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FOG_COLOR.GREEN.value;
        load_next_c = '0;
        if(decoded_reg_strb.FOG_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FOG_COLOR.GREEN.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end
        field_combo.FOG_COLOR.GREEN.next = next_c;
        field_combo.FOG_COLOR.GREEN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FOG_COLOR.GREEN.value <= 8'h0;
        end else begin
            if(field_combo.FOG_COLOR.GREEN.load_next) begin
                field_storage.FOG_COLOR.GREEN.value <= field_combo.FOG_COLOR.GREEN.next;
            end
        end
    end
    assign hwif_out.FOG_COLOR.GREEN.value = field_storage.FOG_COLOR.GREEN.value;
    // Field: gpu_regs.FOG_COLOR.BLUE
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FOG_COLOR.BLUE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FOG_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FOG_COLOR.BLUE.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end
        field_combo.FOG_COLOR.BLUE.next = next_c;
        field_combo.FOG_COLOR.BLUE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FOG_COLOR.BLUE.value <= 8'h0;
        end else begin
            if(field_combo.FOG_COLOR.BLUE.load_next) begin
                field_storage.FOG_COLOR.BLUE.value <= field_combo.FOG_COLOR.BLUE.next;
            end
        end
    end
    assign hwif_out.FOG_COLOR.BLUE.value = field_storage.FOG_COLOR.BLUE.value;
    // Field: gpu_regs.FOG_COLOR.ALPHA
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FOG_COLOR.ALPHA.value;
        load_next_c = '0;
        if(decoded_reg_strb.FOG_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FOG_COLOR.ALPHA.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.FOG_COLOR.ALPHA.next = next_c;
        field_combo.FOG_COLOR.ALPHA.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FOG_COLOR.ALPHA.value <= 8'h0;
        end else begin
            if(field_combo.FOG_COLOR.ALPHA.load_next) begin
                field_storage.FOG_COLOR.ALPHA.value <= field_combo.FOG_COLOR.ALPHA.next;
            end
        end
    end
    assign hwif_out.FOG_COLOR.ALPHA.value = field_storage.FOG_COLOR.ALPHA.value;
    // Field: gpu_regs.FOG_COLOR.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FOG_COLOR.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.FOG_COLOR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FOG_COLOR.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FOG_COLOR.RSVD.next = next_c;
        field_combo.FOG_COLOR.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FOG_COLOR.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.FOG_COLOR.RSVD.load_next) begin
                field_storage.FOG_COLOR.RSVD.value <= field_combo.FOG_COLOR.RSVD.next;
            end
        end
    end
    assign hwif_out.FOG_COLOR.RSVD.value = field_storage.FOG_COLOR.RSVD.value;
    // Field: gpu_regs.RENDER_MODE.GOURAUD
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.GOURAUD.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.GOURAUD.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.GOURAUD.next = next_c;
        field_combo.RENDER_MODE.GOURAUD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.GOURAUD.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.GOURAUD.load_next) begin
                field_storage.RENDER_MODE.GOURAUD.value <= field_combo.RENDER_MODE.GOURAUD.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.GOURAUD.value = field_storage.RENDER_MODE.GOURAUD.value;
    // Field: gpu_regs.RENDER_MODE.RSVD_1
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.RSVD_1.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.RSVD_1.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.RSVD_1.next = next_c;
        field_combo.RENDER_MODE.RSVD_1.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.RSVD_1.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.RSVD_1.load_next) begin
                field_storage.RENDER_MODE.RSVD_1.value <= field_combo.RENDER_MODE.RSVD_1.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.RSVD_1.value = field_storage.RENDER_MODE.RSVD_1.value;
    // Field: gpu_regs.RENDER_MODE.Z_TEST_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_TEST_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_TEST_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_TEST_EN.next = next_c;
        field_combo.RENDER_MODE.Z_TEST_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_TEST_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_TEST_EN.load_next) begin
                field_storage.RENDER_MODE.Z_TEST_EN.value <= field_combo.RENDER_MODE.Z_TEST_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_TEST_EN.value = field_storage.RENDER_MODE.Z_TEST_EN.value;
    // Field: gpu_regs.RENDER_MODE.Z_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_WRITE_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_WRITE_EN.next = next_c;
        field_combo.RENDER_MODE.Z_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_WRITE_EN.load_next) begin
                field_storage.RENDER_MODE.Z_WRITE_EN.value <= field_combo.RENDER_MODE.Z_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_WRITE_EN.value = field_storage.RENDER_MODE.Z_WRITE_EN.value;
    // Field: gpu_regs.RENDER_MODE.COLOR_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.COLOR_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.COLOR_WRITE_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.COLOR_WRITE_EN.next = next_c;
        field_combo.RENDER_MODE.COLOR_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.COLOR_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.COLOR_WRITE_EN.load_next) begin
                field_storage.RENDER_MODE.COLOR_WRITE_EN.value <= field_combo.RENDER_MODE.COLOR_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.COLOR_WRITE_EN.value = field_storage.RENDER_MODE.COLOR_WRITE_EN.value;
    // Field: gpu_regs.RENDER_MODE.CULL_MODE
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.CULL_MODE.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.CULL_MODE.value & ~decoded_wr_biten[6:5]) | (decoded_wr_data[6:5] & decoded_wr_biten[6:5]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.CULL_MODE.next = next_c;
        field_combo.RENDER_MODE.CULL_MODE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.CULL_MODE.value <= 2'h0;
        end else begin
            if(field_combo.RENDER_MODE.CULL_MODE.load_next) begin
                field_storage.RENDER_MODE.CULL_MODE.value <= field_combo.RENDER_MODE.CULL_MODE.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.CULL_MODE.value = field_storage.RENDER_MODE.CULL_MODE.value;
    // Field: gpu_regs.RENDER_MODE.ALPHA_BLEND
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.ALPHA_BLEND.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.ALPHA_BLEND.value & ~decoded_wr_biten[9:7]) | (decoded_wr_data[9:7] & decoded_wr_biten[9:7]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.ALPHA_BLEND.next = next_c;
        field_combo.RENDER_MODE.ALPHA_BLEND.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.ALPHA_BLEND.value <= 3'h0;
        end else begin
            if(field_combo.RENDER_MODE.ALPHA_BLEND.load_next) begin
                field_storage.RENDER_MODE.ALPHA_BLEND.value <= field_combo.RENDER_MODE.ALPHA_BLEND.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.ALPHA_BLEND.value = field_storage.RENDER_MODE.ALPHA_BLEND.value;
    // Field: gpu_regs.RENDER_MODE.DITHER_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.DITHER_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.DITHER_EN.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.DITHER_EN.next = next_c;
        field_combo.RENDER_MODE.DITHER_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.DITHER_EN.value <= 1'h0;
        end else begin
            if(field_combo.RENDER_MODE.DITHER_EN.load_next) begin
                field_storage.RENDER_MODE.DITHER_EN.value <= field_combo.RENDER_MODE.DITHER_EN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.DITHER_EN.value = field_storage.RENDER_MODE.DITHER_EN.value;
    // Field: gpu_regs.RENDER_MODE.DITHER_PATTERN
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.DITHER_PATTERN.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.DITHER_PATTERN.value & ~decoded_wr_biten[12:11]) | (decoded_wr_data[12:11] & decoded_wr_biten[12:11]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.DITHER_PATTERN.next = next_c;
        field_combo.RENDER_MODE.DITHER_PATTERN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.DITHER_PATTERN.value <= 2'h0;
        end else begin
            if(field_combo.RENDER_MODE.DITHER_PATTERN.load_next) begin
                field_storage.RENDER_MODE.DITHER_PATTERN.value <= field_combo.RENDER_MODE.DITHER_PATTERN.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.DITHER_PATTERN.value = field_storage.RENDER_MODE.DITHER_PATTERN.value;
    // Field: gpu_regs.RENDER_MODE.Z_COMPARE
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.Z_COMPARE.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.Z_COMPARE.value & ~decoded_wr_biten[15:13]) | (decoded_wr_data[15:13] & decoded_wr_biten[15:13]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.Z_COMPARE.next = next_c;
        field_combo.RENDER_MODE.Z_COMPARE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.Z_COMPARE.value <= 3'h0;
        end else begin
            if(field_combo.RENDER_MODE.Z_COMPARE.load_next) begin
                field_storage.RENDER_MODE.Z_COMPARE.value <= field_combo.RENDER_MODE.Z_COMPARE.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.Z_COMPARE.value = field_storage.RENDER_MODE.Z_COMPARE.value;
    // Field: gpu_regs.RENDER_MODE.RSVD_HI
    always_comb begin
        automatic logic [47:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.RENDER_MODE.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.RENDER_MODE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.RENDER_MODE.RSVD_HI.value & ~decoded_wr_biten[63:16]) | (decoded_wr_data[63:16] & decoded_wr_biten[63:16]);
            load_next_c = '1;
        end
        field_combo.RENDER_MODE.RSVD_HI.next = next_c;
        field_combo.RENDER_MODE.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.RENDER_MODE.RSVD_HI.value <= 48'h0;
        end else begin
            if(field_combo.RENDER_MODE.RSVD_HI.load_next) begin
                field_storage.RENDER_MODE.RSVD_HI.value <= field_combo.RENDER_MODE.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.RENDER_MODE.RSVD_HI.value = field_storage.RENDER_MODE.RSVD_HI.value;
    // Field: gpu_regs.Z_RANGE.Z_RANGE_MIN
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.Z_RANGE_MIN.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.Z_RANGE_MIN.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.Z_RANGE_MIN.next = next_c;
        field_combo.Z_RANGE.Z_RANGE_MIN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.Z_RANGE_MIN.value <= 16'h0;
        end else begin
            if(field_combo.Z_RANGE.Z_RANGE_MIN.load_next) begin
                field_storage.Z_RANGE.Z_RANGE_MIN.value <= field_combo.Z_RANGE.Z_RANGE_MIN.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.Z_RANGE_MIN.value = field_storage.Z_RANGE.Z_RANGE_MIN.value;
    // Field: gpu_regs.Z_RANGE.Z_RANGE_MAX
    always_comb begin
        automatic logic [15:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.Z_RANGE_MAX.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.Z_RANGE_MAX.value & ~decoded_wr_biten[31:16]) | (decoded_wr_data[31:16] & decoded_wr_biten[31:16]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.Z_RANGE_MAX.next = next_c;
        field_combo.Z_RANGE.Z_RANGE_MAX.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.Z_RANGE_MAX.value <= 16'hffff;
        end else begin
            if(field_combo.Z_RANGE.Z_RANGE_MAX.load_next) begin
                field_storage.Z_RANGE.Z_RANGE_MAX.value <= field_combo.Z_RANGE.Z_RANGE_MAX.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.Z_RANGE_MAX.value = field_storage.Z_RANGE.Z_RANGE_MAX.value;
    // Field: gpu_regs.Z_RANGE.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.Z_RANGE.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.Z_RANGE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.Z_RANGE.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.Z_RANGE.RSVD.next = next_c;
        field_combo.Z_RANGE.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.Z_RANGE.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.Z_RANGE.RSVD.load_next) begin
                field_storage.Z_RANGE.RSVD.value <= field_combo.Z_RANGE.RSVD.next;
            end
        end
    end
    assign hwif_out.Z_RANGE.RSVD.value = field_storage.Z_RANGE.RSVD.value;
    // Field: gpu_regs.FB_DRAW.RSVD_LO
    always_comb begin
        automatic logic [11:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DRAW.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DRAW && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DRAW.RSVD_LO.value & ~decoded_wr_biten[11:0]) | (decoded_wr_data[11:0] & decoded_wr_biten[11:0]);
            load_next_c = '1;
        end
        field_combo.FB_DRAW.RSVD_LO.next = next_c;
        field_combo.FB_DRAW.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DRAW.RSVD_LO.value <= 12'h0;
        end else begin
            if(field_combo.FB_DRAW.RSVD_LO.load_next) begin
                field_storage.FB_DRAW.RSVD_LO.value <= field_combo.FB_DRAW.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.FB_DRAW.RSVD_LO.value = field_storage.FB_DRAW.RSVD_LO.value;
    // Field: gpu_regs.FB_DRAW.BASE_ADDR
    always_comb begin
        automatic logic [19:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DRAW.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DRAW && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DRAW.BASE_ADDR.value & ~decoded_wr_biten[31:12]) | (decoded_wr_data[31:12] & decoded_wr_biten[31:12]);
            load_next_c = '1;
        end
        field_combo.FB_DRAW.BASE_ADDR.next = next_c;
        field_combo.FB_DRAW.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DRAW.BASE_ADDR.value <= 20'h0;
        end else begin
            if(field_combo.FB_DRAW.BASE_ADDR.load_next) begin
                field_storage.FB_DRAW.BASE_ADDR.value <= field_combo.FB_DRAW.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DRAW.BASE_ADDR.value = field_storage.FB_DRAW.BASE_ADDR.value;
    // Field: gpu_regs.FB_DRAW.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DRAW.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DRAW && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DRAW.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FB_DRAW.RSVD_HI.next = next_c;
        field_combo.FB_DRAW.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DRAW.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.FB_DRAW.RSVD_HI.load_next) begin
                field_storage.FB_DRAW.RSVD_HI.value <= field_combo.FB_DRAW.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_DRAW.RSVD_HI.value = field_storage.FB_DRAW.RSVD_HI.value;
    // Field: gpu_regs.FB_DISPLAY.COLOR_GRADE_ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.next = next_c;
        field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.load_next) begin
                field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value <= field_combo.FB_DISPLAY.COLOR_GRADE_ENABLE.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.COLOR_GRADE_ENABLE.value = field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value;
    // Field: gpu_regs.FB_DISPLAY.RSVD_LO
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.RSVD_LO.value & ~decoded_wr_biten[5:1]) | (decoded_wr_data[5:1] & decoded_wr_biten[5:1]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.RSVD_LO.next = next_c;
        field_combo.FB_DISPLAY.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.RSVD_LO.value <= 5'h0;
        end else begin
            if(field_combo.FB_DISPLAY.RSVD_LO.load_next) begin
                field_storage.FB_DISPLAY.RSVD_LO.value <= field_combo.FB_DISPLAY.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.RSVD_LO.value = field_storage.FB_DISPLAY.RSVD_LO.value;
    // Field: gpu_regs.FB_DISPLAY.LUT_ADDR
    always_comb begin
        automatic logic [12:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.LUT_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.LUT_ADDR.value & ~decoded_wr_biten[18:6]) | (decoded_wr_data[18:6] & decoded_wr_biten[18:6]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.LUT_ADDR.next = next_c;
        field_combo.FB_DISPLAY.LUT_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.LUT_ADDR.value <= 13'h0;
        end else begin
            if(field_combo.FB_DISPLAY.LUT_ADDR.load_next) begin
                field_storage.FB_DISPLAY.LUT_ADDR.value <= field_combo.FB_DISPLAY.LUT_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.LUT_ADDR.value = field_storage.FB_DISPLAY.LUT_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY.FB_ADDR
    always_comb begin
        automatic logic [12:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.FB_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.FB_ADDR.value & ~decoded_wr_biten[31:19]) | (decoded_wr_data[31:19] & decoded_wr_biten[31:19]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.FB_ADDR.next = next_c;
        field_combo.FB_DISPLAY.FB_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.FB_ADDR.value <= 13'h0;
        end else begin
            if(field_combo.FB_DISPLAY.FB_ADDR.load_next) begin
                field_storage.FB_DISPLAY.FB_ADDR.value <= field_combo.FB_DISPLAY.FB_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.FB_ADDR.value = field_storage.FB_DISPLAY.FB_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY.RSVD_HI.next = next_c;
        field_combo.FB_DISPLAY.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.FB_DISPLAY.RSVD_HI.load_next) begin
                field_storage.FB_DISPLAY.RSVD_HI.value <= field_combo.FB_DISPLAY.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY.RSVD_HI.value = field_storage.FB_DISPLAY.RSVD_HI.value;
    // Field: gpu_regs.FB_ZBUFFER.RSVD_LO
    always_comb begin
        automatic logic [11:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_ZBUFFER.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_ZBUFFER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_ZBUFFER.RSVD_LO.value & ~decoded_wr_biten[11:0]) | (decoded_wr_data[11:0] & decoded_wr_biten[11:0]);
            load_next_c = '1;
        end
        field_combo.FB_ZBUFFER.RSVD_LO.next = next_c;
        field_combo.FB_ZBUFFER.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_ZBUFFER.RSVD_LO.value <= 12'h0;
        end else begin
            if(field_combo.FB_ZBUFFER.RSVD_LO.load_next) begin
                field_storage.FB_ZBUFFER.RSVD_LO.value <= field_combo.FB_ZBUFFER.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.FB_ZBUFFER.RSVD_LO.value = field_storage.FB_ZBUFFER.RSVD_LO.value;
    // Field: gpu_regs.FB_ZBUFFER.BASE_ADDR
    always_comb begin
        automatic logic [19:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_ZBUFFER.BASE_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_ZBUFFER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_ZBUFFER.BASE_ADDR.value & ~decoded_wr_biten[31:12]) | (decoded_wr_data[31:12] & decoded_wr_biten[31:12]);
            load_next_c = '1;
        end
        field_combo.FB_ZBUFFER.BASE_ADDR.next = next_c;
        field_combo.FB_ZBUFFER.BASE_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_ZBUFFER.BASE_ADDR.value <= 20'h0;
        end else begin
            if(field_combo.FB_ZBUFFER.BASE_ADDR.load_next) begin
                field_storage.FB_ZBUFFER.BASE_ADDR.value <= field_combo.FB_ZBUFFER.BASE_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_ZBUFFER.BASE_ADDR.value = field_storage.FB_ZBUFFER.BASE_ADDR.value;
    // Field: gpu_regs.FB_ZBUFFER.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_ZBUFFER.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_ZBUFFER && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_ZBUFFER.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FB_ZBUFFER.RSVD_HI.next = next_c;
        field_combo.FB_ZBUFFER.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_ZBUFFER.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.FB_ZBUFFER.RSVD_HI.load_next) begin
                field_storage.FB_ZBUFFER.RSVD_HI.value <= field_combo.FB_ZBUFFER.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_ZBUFFER.RSVD_HI.value = field_storage.FB_ZBUFFER.RSVD_HI.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_X
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_X.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_X.value & ~decoded_wr_biten[9:0]) | (decoded_wr_data[9:0] & decoded_wr_biten[9:0]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_X.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_X.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_X.value <= 10'h0;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_X.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_X.value <= field_combo.FB_CONTROL.SCISSOR_X.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_X.value = field_storage.FB_CONTROL.SCISSOR_X.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_Y
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_Y.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_Y.value & ~decoded_wr_biten[19:10]) | (decoded_wr_data[19:10] & decoded_wr_biten[19:10]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_Y.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_Y.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_Y.value <= 10'h0;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_Y.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_Y.value <= field_combo.FB_CONTROL.SCISSOR_Y.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_Y.value = field_storage.FB_CONTROL.SCISSOR_Y.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_WIDTH
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_WIDTH.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_WIDTH.value & ~decoded_wr_biten[29:20]) | (decoded_wr_data[29:20] & decoded_wr_biten[29:20]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_WIDTH.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_WIDTH.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_WIDTH.value <= 10'h3ff;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_WIDTH.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_WIDTH.value <= field_combo.FB_CONTROL.SCISSOR_WIDTH.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_WIDTH.value = field_storage.FB_CONTROL.SCISSOR_WIDTH.value;
    // Field: gpu_regs.FB_CONTROL.SCISSOR_HEIGHT
    always_comb begin
        automatic logic [9:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.SCISSOR_HEIGHT.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.SCISSOR_HEIGHT.value & ~decoded_wr_biten[39:30]) | (decoded_wr_data[39:30] & decoded_wr_biten[39:30]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.SCISSOR_HEIGHT.next = next_c;
        field_combo.FB_CONTROL.SCISSOR_HEIGHT.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.SCISSOR_HEIGHT.value <= 10'h3ff;
        end else begin
            if(field_combo.FB_CONTROL.SCISSOR_HEIGHT.load_next) begin
                field_storage.FB_CONTROL.SCISSOR_HEIGHT.value <= field_combo.FB_CONTROL.SCISSOR_HEIGHT.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.SCISSOR_HEIGHT.value = field_storage.FB_CONTROL.SCISSOR_HEIGHT.value;
    // Field: gpu_regs.FB_CONTROL.Z_WRITE_EN_OVERRIDE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value & ~decoded_wr_biten[40:40]) | (decoded_wr_data[40:40] & decoded_wr_biten[40:40]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.next = next_c;
        field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.load_next) begin
                field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value <= field_combo.FB_CONTROL.Z_WRITE_EN_OVERRIDE.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value = field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value;
    // Field: gpu_regs.FB_CONTROL.RSVD_41
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.RSVD_41.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.RSVD_41.value & ~decoded_wr_biten[41:41]) | (decoded_wr_data[41:41] & decoded_wr_biten[41:41]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.RSVD_41.next = next_c;
        field_combo.FB_CONTROL.RSVD_41.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.RSVD_41.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.RSVD_41.load_next) begin
                field_storage.FB_CONTROL.RSVD_41.value <= field_combo.FB_CONTROL.RSVD_41.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.RSVD_41.value = field_storage.FB_CONTROL.RSVD_41.value;
    // Field: gpu_regs.FB_CONTROL.STENCIL_WRITE_EN
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.STENCIL_WRITE_EN.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.STENCIL_WRITE_EN.value & ~decoded_wr_biten[42:42]) | (decoded_wr_data[42:42] & decoded_wr_biten[42:42]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.STENCIL_WRITE_EN.next = next_c;
        field_combo.FB_CONTROL.STENCIL_WRITE_EN.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.STENCIL_WRITE_EN.value <= 1'h0;
        end else begin
            if(field_combo.FB_CONTROL.STENCIL_WRITE_EN.load_next) begin
                field_storage.FB_CONTROL.STENCIL_WRITE_EN.value <= field_combo.FB_CONTROL.STENCIL_WRITE_EN.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.STENCIL_WRITE_EN.value = field_storage.FB_CONTROL.STENCIL_WRITE_EN.value;
    // Field: gpu_regs.FB_CONTROL.RSVD_HI
    always_comb begin
        automatic logic [20:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_CONTROL.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_CONTROL && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_CONTROL.RSVD_HI.value & ~decoded_wr_biten[63:43]) | (decoded_wr_data[63:43] & decoded_wr_biten[63:43]);
            load_next_c = '1;
        end
        field_combo.FB_CONTROL.RSVD_HI.next = next_c;
        field_combo.FB_CONTROL.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_CONTROL.RSVD_HI.value <= 21'h0;
        end else begin
            if(field_combo.FB_CONTROL.RSVD_HI.load_next) begin
                field_storage.FB_CONTROL.RSVD_HI.value <= field_combo.FB_CONTROL.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_CONTROL.RSVD_HI.value = field_storage.FB_CONTROL.RSVD_HI.value;
    // Field: gpu_regs.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY_SYNC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.next = next_c;
        field_combo.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value <= 1'h0;
        end else begin
            if(field_combo.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.load_next) begin
                field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value <= field_combo.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value = field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value;
    // Field: gpu_regs.FB_DISPLAY_SYNC.RSVD_LO
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY_SYNC.RSVD_LO.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY_SYNC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY_SYNC.RSVD_LO.value & ~decoded_wr_biten[5:1]) | (decoded_wr_data[5:1] & decoded_wr_biten[5:1]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY_SYNC.RSVD_LO.next = next_c;
        field_combo.FB_DISPLAY_SYNC.RSVD_LO.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY_SYNC.RSVD_LO.value <= 5'h0;
        end else begin
            if(field_combo.FB_DISPLAY_SYNC.RSVD_LO.load_next) begin
                field_storage.FB_DISPLAY_SYNC.RSVD_LO.value <= field_combo.FB_DISPLAY_SYNC.RSVD_LO.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY_SYNC.RSVD_LO.value = field_storage.FB_DISPLAY_SYNC.RSVD_LO.value;
    // Field: gpu_regs.FB_DISPLAY_SYNC.LUT_ADDR
    always_comb begin
        automatic logic [12:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY_SYNC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value & ~decoded_wr_biten[18:6]) | (decoded_wr_data[18:6] & decoded_wr_biten[18:6]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY_SYNC.LUT_ADDR.next = next_c;
        field_combo.FB_DISPLAY_SYNC.LUT_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value <= 13'h0;
        end else begin
            if(field_combo.FB_DISPLAY_SYNC.LUT_ADDR.load_next) begin
                field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value <= field_combo.FB_DISPLAY_SYNC.LUT_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY_SYNC.LUT_ADDR.value = field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY_SYNC.FB_ADDR
    always_comb begin
        automatic logic [12:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY_SYNC.FB_ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY_SYNC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY_SYNC.FB_ADDR.value & ~decoded_wr_biten[31:19]) | (decoded_wr_data[31:19] & decoded_wr_biten[31:19]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY_SYNC.FB_ADDR.next = next_c;
        field_combo.FB_DISPLAY_SYNC.FB_ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY_SYNC.FB_ADDR.value <= 13'h0;
        end else begin
            if(field_combo.FB_DISPLAY_SYNC.FB_ADDR.load_next) begin
                field_storage.FB_DISPLAY_SYNC.FB_ADDR.value <= field_combo.FB_DISPLAY_SYNC.FB_ADDR.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY_SYNC.FB_ADDR.value = field_storage.FB_DISPLAY_SYNC.FB_ADDR.value;
    // Field: gpu_regs.FB_DISPLAY_SYNC.RSVD_HI
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.FB_DISPLAY_SYNC.RSVD_HI.value;
        load_next_c = '0;
        if(decoded_reg_strb.FB_DISPLAY_SYNC && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.FB_DISPLAY_SYNC.RSVD_HI.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.FB_DISPLAY_SYNC.RSVD_HI.next = next_c;
        field_combo.FB_DISPLAY_SYNC.RSVD_HI.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.FB_DISPLAY_SYNC.RSVD_HI.value <= 32'h0;
        end else begin
            if(field_combo.FB_DISPLAY_SYNC.RSVD_HI.load_next) begin
                field_storage.FB_DISPLAY_SYNC.RSVD_HI.value <= field_combo.FB_DISPLAY_SYNC.RSVD_HI.next;
            end
        end
    end
    assign hwif_out.FB_DISPLAY_SYNC.RSVD_HI.value = field_storage.FB_DISPLAY_SYNC.RSVD_HI.value;
    assign hwif_out.PERF_TEX0.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_TEX0.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_TEX1.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_TEX1.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_PIXELS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_PIXELS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_FRAGMENTS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_FRAGMENTS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_STALL_VS.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_STALL_VS.COUNTER_B.value = 32'h0;
    assign hwif_out.PERF_STALL_CT.COUNTER_A.value = 32'h0;
    assign hwif_out.PERF_STALL_CT.COUNTER_B.value = 32'h0;
    // Field: gpu_regs.MEM_ADDR.ADDR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_ADDR.ADDR.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_ADDR.ADDR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end
        field_combo.MEM_ADDR.ADDR.next = next_c;
        field_combo.MEM_ADDR.ADDR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_ADDR.ADDR.value <= 32'h0;
        end else begin
            if(field_combo.MEM_ADDR.ADDR.load_next) begin
                field_storage.MEM_ADDR.ADDR.value <= field_combo.MEM_ADDR.ADDR.next;
            end
        end
    end
    assign hwif_out.MEM_ADDR.ADDR.value = field_storage.MEM_ADDR.ADDR.value;
    // Field: gpu_regs.MEM_ADDR.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_ADDR.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_ADDR && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_ADDR.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.MEM_ADDR.RSVD.next = next_c;
        field_combo.MEM_ADDR.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_ADDR.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.MEM_ADDR.RSVD.load_next) begin
                field_storage.MEM_ADDR.RSVD.value <= field_combo.MEM_ADDR.RSVD.next;
            end
        end
    end
    assign hwif_out.MEM_ADDR.RSVD.value = field_storage.MEM_ADDR.RSVD.value;
    // Field: gpu_regs.MEM_DATA.DATA
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_DATA.DATA.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_DATA && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_DATA.DATA.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end
        field_combo.MEM_DATA.DATA.next = next_c;
        field_combo.MEM_DATA.DATA.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_DATA.DATA.value <= 32'h0;
        end else begin
            if(field_combo.MEM_DATA.DATA.load_next) begin
                field_storage.MEM_DATA.DATA.value <= field_combo.MEM_DATA.DATA.next;
            end
        end
    end
    assign hwif_out.MEM_DATA.DATA.value = field_storage.MEM_DATA.DATA.value;
    // Field: gpu_regs.MEM_DATA.RSVD
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.MEM_DATA.RSVD.value;
        load_next_c = '0;
        if(decoded_reg_strb.MEM_DATA && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.MEM_DATA.RSVD.value & ~decoded_wr_biten[63:32]) | (decoded_wr_data[63:32] & decoded_wr_biten[63:32]);
            load_next_c = '1;
        end
        field_combo.MEM_DATA.RSVD.next = next_c;
        field_combo.MEM_DATA.RSVD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.MEM_DATA.RSVD.value <= 32'h0;
        end else begin
            if(field_combo.MEM_DATA.RSVD.load_next) begin
                field_storage.MEM_DATA.RSVD.value <= field_combo.MEM_DATA.RSVD.next;
            end
        end
    end
    assign hwif_out.MEM_DATA.RSVD.value = field_storage.MEM_DATA.RSVD.value;
    assign hwif_out.STATUS.FIFO_DEPTH.value = 8'h0;
    assign hwif_out.STATUS.BUSY.value = 1'h0;
    assign hwif_out.STATUS.VBLANK.value = 1'h0;
    assign hwif_out.STATUS.RSVD.value = 54'h0;
    assign hwif_out.ID.DEVICE_ID.value = 16'h6702;
    assign hwif_out.ID.VERSION.value = 16'ha00;
    assign hwif_out.ID.RSVD.value = 32'h0;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [63:0] readback_data;

    // Assign readback values to a flattened array
    logic [63:0] readback_array[35];
    assign readback_array[0][7:0] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_R.value : '0;
    assign readback_array[0][15:8] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_G.value : '0;
    assign readback_array[0][23:16] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_B.value : '0;
    assign readback_array[0][31:24] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR0_A.value : '0;
    assign readback_array[0][39:32] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_R.value : '0;
    assign readback_array[0][47:40] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_G.value : '0;
    assign readback_array[0][55:48] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_B.value : '0;
    assign readback_array[0][63:56] = (decoded_reg_strb.COLOR && !decoded_req_is_wr) ? field_storage.COLOR.COLOR1_A.value : '0;
    assign readback_array[1][15:0] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV0_UQ.value : '0;
    assign readback_array[1][31:16] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV0_VQ.value : '0;
    assign readback_array[1][47:32] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV1_UQ.value : '0;
    assign readback_array[1][63:48] = (decoded_reg_strb.UV0_UV1 && !decoded_req_is_wr) ? field_storage.UV0_UV1.UV1_VQ.value : '0;
    assign readback_array[2][7:0] = (decoded_reg_strb.LIGHT_DIR && !decoded_req_is_wr) ? field_storage.LIGHT_DIR.X_DIR.value : '0;
    assign readback_array[2][15:8] = (decoded_reg_strb.LIGHT_DIR && !decoded_req_is_wr) ? field_storage.LIGHT_DIR.Y_DIR.value : '0;
    assign readback_array[2][23:16] = (decoded_reg_strb.LIGHT_DIR && !decoded_req_is_wr) ? field_storage.LIGHT_DIR.Z_DIR.value : '0;
    assign readback_array[2][63:24] = (decoded_reg_strb.LIGHT_DIR && !decoded_req_is_wr) ? field_storage.LIGHT_DIR.RSVD.value : '0;
    assign readback_array[3][15:0] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.X.value : '0;
    assign readback_array[3][31:16] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Y.value : '0;
    assign readback_array[3][47:32] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Z.value : '0;
    assign readback_array[3][63:48] = (decoded_reg_strb.VERTEX_NOKICK && !decoded_req_is_wr) ? field_storage.VERTEX_NOKICK.Q.value : '0;
    assign readback_array[4][15:0] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.X.value : '0;
    assign readback_array[4][31:16] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Y.value : '0;
    assign readback_array[4][47:32] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Z.value : '0;
    assign readback_array[4][63:48] = (decoded_reg_strb.VERTEX_KICK_012 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_012.Q.value : '0;
    assign readback_array[5][15:0] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.X.value : '0;
    assign readback_array[5][31:16] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Y.value : '0;
    assign readback_array[5][47:32] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Z.value : '0;
    assign readback_array[5][63:48] = (decoded_reg_strb.VERTEX_KICK_021 && !decoded_req_is_wr) ? field_storage.VERTEX_KICK_021.Q.value : '0;
    assign readback_array[6][11:0] = (decoded_reg_strb.TEX0_BASE && !decoded_req_is_wr) ? field_storage.TEX0_BASE.RSVD_LO.value : '0;
    assign readback_array[6][31:12] = (decoded_reg_strb.TEX0_BASE && !decoded_req_is_wr) ? field_storage.TEX0_BASE.BASE_ADDR.value : '0;
    assign readback_array[6][63:32] = (decoded_reg_strb.TEX0_BASE && !decoded_req_is_wr) ? field_storage.TEX0_BASE.RSVD_HI.value : '0;
    assign readback_array[7][0:0] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.ENABLE.value : '0;
    assign readback_array[7][1:1] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.RSVD_1.value : '0;
    assign readback_array[7][3:2] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.FORMAT.value : '0;
    assign readback_array[7][5:4] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.RSVD_54.value : '0;
    assign readback_array[7][7:6] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.FILTER.value : '0;
    assign readback_array[7][11:8] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.WIDTH_LOG2.value : '0;
    assign readback_array[7][15:12] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.HEIGHT_LOG2.value : '0;
    assign readback_array[7][19:16] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.SWIZZLE.value : '0;
    assign readback_array[7][23:20] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.MIP_LEVELS.value : '0;
    assign readback_array[7][63:24] = (decoded_reg_strb.TEX0_FMT && !decoded_req_is_wr) ? field_storage.TEX0_FMT.RSVD_HI.value : '0;
    assign readback_array[8][7:0] = (decoded_reg_strb.TEX0_MIP_BIAS && !decoded_req_is_wr) ? field_storage.TEX0_MIP_BIAS.MIP_BIAS.value : '0;
    assign readback_array[8][63:8] = (decoded_reg_strb.TEX0_MIP_BIAS && !decoded_req_is_wr) ? field_storage.TEX0_MIP_BIAS.RSVD.value : '0;
    assign readback_array[9][1:0] = (decoded_reg_strb.TEX0_WRAP && !decoded_req_is_wr) ? field_storage.TEX0_WRAP.U_WRAP.value : '0;
    assign readback_array[9][3:2] = (decoded_reg_strb.TEX0_WRAP && !decoded_req_is_wr) ? field_storage.TEX0_WRAP.V_WRAP.value : '0;
    assign readback_array[9][63:4] = (decoded_reg_strb.TEX0_WRAP && !decoded_req_is_wr) ? field_storage.TEX0_WRAP.RSVD.value : '0;
    assign readback_array[10][11:0] = (decoded_reg_strb.TEX1_BASE && !decoded_req_is_wr) ? field_storage.TEX1_BASE.RSVD_LO.value : '0;
    assign readback_array[10][31:12] = (decoded_reg_strb.TEX1_BASE && !decoded_req_is_wr) ? field_storage.TEX1_BASE.BASE_ADDR.value : '0;
    assign readback_array[10][63:32] = (decoded_reg_strb.TEX1_BASE && !decoded_req_is_wr) ? field_storage.TEX1_BASE.RSVD_HI.value : '0;
    assign readback_array[11][0:0] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.ENABLE.value : '0;
    assign readback_array[11][1:1] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.RSVD_1.value : '0;
    assign readback_array[11][3:2] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.FORMAT.value : '0;
    assign readback_array[11][5:4] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.RSVD_54.value : '0;
    assign readback_array[11][7:6] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.FILTER.value : '0;
    assign readback_array[11][11:8] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.WIDTH_LOG2.value : '0;
    assign readback_array[11][15:12] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.HEIGHT_LOG2.value : '0;
    assign readback_array[11][19:16] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.SWIZZLE.value : '0;
    assign readback_array[11][23:20] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.MIP_LEVELS.value : '0;
    assign readback_array[11][63:24] = (decoded_reg_strb.TEX1_FMT && !decoded_req_is_wr) ? field_storage.TEX1_FMT.RSVD_HI.value : '0;
    assign readback_array[12][7:0] = (decoded_reg_strb.TEX1_MIP_BIAS && !decoded_req_is_wr) ? field_storage.TEX1_MIP_BIAS.MIP_BIAS.value : '0;
    assign readback_array[12][63:8] = (decoded_reg_strb.TEX1_MIP_BIAS && !decoded_req_is_wr) ? field_storage.TEX1_MIP_BIAS.RSVD.value : '0;
    assign readback_array[13][1:0] = (decoded_reg_strb.TEX1_WRAP && !decoded_req_is_wr) ? field_storage.TEX1_WRAP.U_WRAP.value : '0;
    assign readback_array[13][3:2] = (decoded_reg_strb.TEX1_WRAP && !decoded_req_is_wr) ? field_storage.TEX1_WRAP.V_WRAP.value : '0;
    assign readback_array[13][63:4] = (decoded_reg_strb.TEX1_WRAP && !decoded_req_is_wr) ? field_storage.TEX1_WRAP.RSVD.value : '0;
    assign readback_array[14][3:0] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_ALPHA_A.value : '0;
    assign readback_array[14][7:4] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_ALPHA_B.value : '0;
    assign readback_array[14][11:8] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_ALPHA_C.value : '0;
    assign readback_array[14][15:12] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_ALPHA_D.value : '0;
    assign readback_array[14][19:16] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_A_SOURCE.value : '0;
    assign readback_array[14][23:20] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_B_SOURCE.value : '0;
    assign readback_array[14][27:24] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_C_SOURCE.value : '0;
    assign readback_array[14][31:28] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.CC_D_SOURCE.value : '0;
    assign readback_array[14][63:32] = (decoded_reg_strb.CC_MODE && !decoded_req_is_wr) ? field_storage.CC_MODE.RSVD.value : '0;
    assign readback_array[15][7:0] = (decoded_reg_strb.MAT_COLOR0 && !decoded_req_is_wr) ? field_storage.MAT_COLOR0.RED.value : '0;
    assign readback_array[15][15:8] = (decoded_reg_strb.MAT_COLOR0 && !decoded_req_is_wr) ? field_storage.MAT_COLOR0.GREEN.value : '0;
    assign readback_array[15][23:16] = (decoded_reg_strb.MAT_COLOR0 && !decoded_req_is_wr) ? field_storage.MAT_COLOR0.BLUE.value : '0;
    assign readback_array[15][31:24] = (decoded_reg_strb.MAT_COLOR0 && !decoded_req_is_wr) ? field_storage.MAT_COLOR0.ALPHA.value : '0;
    assign readback_array[15][63:32] = (decoded_reg_strb.MAT_COLOR0 && !decoded_req_is_wr) ? field_storage.MAT_COLOR0.RSVD.value : '0;
    assign readback_array[16][7:0] = (decoded_reg_strb.MAT_COLOR1 && !decoded_req_is_wr) ? field_storage.MAT_COLOR1.RED.value : '0;
    assign readback_array[16][15:8] = (decoded_reg_strb.MAT_COLOR1 && !decoded_req_is_wr) ? field_storage.MAT_COLOR1.GREEN.value : '0;
    assign readback_array[16][23:16] = (decoded_reg_strb.MAT_COLOR1 && !decoded_req_is_wr) ? field_storage.MAT_COLOR1.BLUE.value : '0;
    assign readback_array[16][31:24] = (decoded_reg_strb.MAT_COLOR1 && !decoded_req_is_wr) ? field_storage.MAT_COLOR1.ALPHA.value : '0;
    assign readback_array[16][63:32] = (decoded_reg_strb.MAT_COLOR1 && !decoded_req_is_wr) ? field_storage.MAT_COLOR1.RSVD.value : '0;
    assign readback_array[17][7:0] = (decoded_reg_strb.FOG_COLOR && !decoded_req_is_wr) ? field_storage.FOG_COLOR.RED.value : '0;
    assign readback_array[17][15:8] = (decoded_reg_strb.FOG_COLOR && !decoded_req_is_wr) ? field_storage.FOG_COLOR.GREEN.value : '0;
    assign readback_array[17][23:16] = (decoded_reg_strb.FOG_COLOR && !decoded_req_is_wr) ? field_storage.FOG_COLOR.BLUE.value : '0;
    assign readback_array[17][31:24] = (decoded_reg_strb.FOG_COLOR && !decoded_req_is_wr) ? field_storage.FOG_COLOR.ALPHA.value : '0;
    assign readback_array[17][63:32] = (decoded_reg_strb.FOG_COLOR && !decoded_req_is_wr) ? field_storage.FOG_COLOR.RSVD.value : '0;
    assign readback_array[18][0:0] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.GOURAUD.value : '0;
    assign readback_array[18][1:1] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.RSVD_1.value : '0;
    assign readback_array[18][2:2] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_TEST_EN.value : '0;
    assign readback_array[18][3:3] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_WRITE_EN.value : '0;
    assign readback_array[18][4:4] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.COLOR_WRITE_EN.value : '0;
    assign readback_array[18][6:5] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.CULL_MODE.value : '0;
    assign readback_array[18][9:7] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.ALPHA_BLEND.value : '0;
    assign readback_array[18][10:10] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.DITHER_EN.value : '0;
    assign readback_array[18][12:11] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.DITHER_PATTERN.value : '0;
    assign readback_array[18][15:13] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.Z_COMPARE.value : '0;
    assign readback_array[18][63:16] = (decoded_reg_strb.RENDER_MODE && !decoded_req_is_wr) ? field_storage.RENDER_MODE.RSVD_HI.value : '0;
    assign readback_array[19][15:0] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.Z_RANGE_MIN.value : '0;
    assign readback_array[19][31:16] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.Z_RANGE_MAX.value : '0;
    assign readback_array[19][63:32] = (decoded_reg_strb.Z_RANGE && !decoded_req_is_wr) ? field_storage.Z_RANGE.RSVD.value : '0;
    assign readback_array[20][11:0] = (decoded_reg_strb.FB_DRAW && !decoded_req_is_wr) ? field_storage.FB_DRAW.RSVD_LO.value : '0;
    assign readback_array[20][31:12] = (decoded_reg_strb.FB_DRAW && !decoded_req_is_wr) ? field_storage.FB_DRAW.BASE_ADDR.value : '0;
    assign readback_array[20][63:32] = (decoded_reg_strb.FB_DRAW && !decoded_req_is_wr) ? field_storage.FB_DRAW.RSVD_HI.value : '0;
    assign readback_array[21][0:0] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.COLOR_GRADE_ENABLE.value : '0;
    assign readback_array[21][5:1] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.RSVD_LO.value : '0;
    assign readback_array[21][18:6] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.LUT_ADDR.value : '0;
    assign readback_array[21][31:19] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.FB_ADDR.value : '0;
    assign readback_array[21][63:32] = (decoded_reg_strb.FB_DISPLAY && !decoded_req_is_wr) ? field_storage.FB_DISPLAY.RSVD_HI.value : '0;
    assign readback_array[22][11:0] = (decoded_reg_strb.FB_ZBUFFER && !decoded_req_is_wr) ? field_storage.FB_ZBUFFER.RSVD_LO.value : '0;
    assign readback_array[22][31:12] = (decoded_reg_strb.FB_ZBUFFER && !decoded_req_is_wr) ? field_storage.FB_ZBUFFER.BASE_ADDR.value : '0;
    assign readback_array[22][63:32] = (decoded_reg_strb.FB_ZBUFFER && !decoded_req_is_wr) ? field_storage.FB_ZBUFFER.RSVD_HI.value : '0;
    assign readback_array[23][9:0] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_X.value : '0;
    assign readback_array[23][19:10] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_Y.value : '0;
    assign readback_array[23][29:20] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_WIDTH.value : '0;
    assign readback_array[23][39:30] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.SCISSOR_HEIGHT.value : '0;
    assign readback_array[23][40:40] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.Z_WRITE_EN_OVERRIDE.value : '0;
    assign readback_array[23][41:41] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.RSVD_41.value : '0;
    assign readback_array[23][42:42] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.STENCIL_WRITE_EN.value : '0;
    assign readback_array[23][63:43] = (decoded_reg_strb.FB_CONTROL && !decoded_req_is_wr) ? field_storage.FB_CONTROL.RSVD_HI.value : '0;
    assign readback_array[24][0:0] = (decoded_reg_strb.FB_DISPLAY_SYNC && !decoded_req_is_wr) ? field_storage.FB_DISPLAY_SYNC.COLOR_GRADE_ENABLE.value : '0;
    assign readback_array[24][5:1] = (decoded_reg_strb.FB_DISPLAY_SYNC && !decoded_req_is_wr) ? field_storage.FB_DISPLAY_SYNC.RSVD_LO.value : '0;
    assign readback_array[24][18:6] = (decoded_reg_strb.FB_DISPLAY_SYNC && !decoded_req_is_wr) ? field_storage.FB_DISPLAY_SYNC.LUT_ADDR.value : '0;
    assign readback_array[24][31:19] = (decoded_reg_strb.FB_DISPLAY_SYNC && !decoded_req_is_wr) ? field_storage.FB_DISPLAY_SYNC.FB_ADDR.value : '0;
    assign readback_array[24][63:32] = (decoded_reg_strb.FB_DISPLAY_SYNC && !decoded_req_is_wr) ? field_storage.FB_DISPLAY_SYNC.RSVD_HI.value : '0;
    assign readback_array[25][31:0] = (decoded_reg_strb.PERF_TEX0 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[25][63:32] = (decoded_reg_strb.PERF_TEX0 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[26][31:0] = (decoded_reg_strb.PERF_TEX1 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[26][63:32] = (decoded_reg_strb.PERF_TEX1 && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[27][31:0] = (decoded_reg_strb.PERF_PIXELS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[27][63:32] = (decoded_reg_strb.PERF_PIXELS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[28][31:0] = (decoded_reg_strb.PERF_FRAGMENTS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[28][63:32] = (decoded_reg_strb.PERF_FRAGMENTS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[29][31:0] = (decoded_reg_strb.PERF_STALL_VS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[29][63:32] = (decoded_reg_strb.PERF_STALL_VS && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[30][31:0] = (decoded_reg_strb.PERF_STALL_CT && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[30][63:32] = (decoded_reg_strb.PERF_STALL_CT && !decoded_req_is_wr) ? 32'h0 : '0;
    assign readback_array[31][31:0] = (decoded_reg_strb.MEM_ADDR && !decoded_req_is_wr) ? field_storage.MEM_ADDR.ADDR.value : '0;
    assign readback_array[31][63:32] = (decoded_reg_strb.MEM_ADDR && !decoded_req_is_wr) ? field_storage.MEM_ADDR.RSVD.value : '0;
    assign readback_array[32][31:0] = (decoded_reg_strb.MEM_DATA && !decoded_req_is_wr) ? field_storage.MEM_DATA.DATA.value : '0;
    assign readback_array[32][63:32] = (decoded_reg_strb.MEM_DATA && !decoded_req_is_wr) ? field_storage.MEM_DATA.RSVD.value : '0;
    assign readback_array[33][7:0] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[33][8:8] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[33][9:9] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[33][63:10] = (decoded_reg_strb.STATUS && !decoded_req_is_wr) ? 54'h0 : '0;
    assign readback_array[34][15:0] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 16'h6702 : '0;
    assign readback_array[34][31:16] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 16'ha00 : '0;
    assign readback_array[34][63:32] = (decoded_reg_strb.ID && !decoded_req_is_wr) ? 32'h0 : '0;

    // Reduce the array
    always_comb begin
        automatic logic [63:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<35; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
