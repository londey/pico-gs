// GPU Register Map — SystemRDL source of truth
//
// This file defines the canonical register addresses, bit fields, enumerations,
// and reset values for the ICEpi SPI GPU.  PeakRDL generates Rust and
// SystemVerilog outputs from this file.
//
// Address space: 7-bit register index (0x00–0x7F), 64-bit data width.
// Transaction format: 72 bits — [R/W̄(1)][addr(7)][data(64)].
//
// Command queuing: Write transactions are buffered in a 512-entry async FIFO
// (2 EBR blocks) and executed in strict FIFO order.  A long-running command
// (e.g. rasterization triggered by a vertex kick) stalls subsequent commands
// until it completes.  The host must check the CMD_FULL GPIO before each write
// and must check CMD_EMPTY (FIFO drained, no command executing) before issuing
// a register read.
//
// NOTE: SystemRDL uses byte addresses, so register index N maps to byte
// address N*8.  The GPU SPI interface uses the 7-bit register index directly.

// ---------------------------------------------------------------------------
// Enumerations
// ---------------------------------------------------------------------------

enum z_compare_e {
    LESS       = 3'd0 { desc = "Less than (<)"; };
    LEQUAL     = 3'd1 { desc = "Less than or equal (<=)"; };
    EQUAL      = 3'd2 { desc = "Equal (=)"; };
    GEQUAL     = 3'd3 { desc = "Greater than or equal (>=)"; };
    GREATER    = 3'd4 { desc = "Greater than (>)"; };
    NOTEQUAL   = 3'd5 { desc = "Not equal (!=)"; };
    ALWAYS     = 3'd6 { desc = "Always pass"; };
    NEVER      = 3'd7 { desc = "Never pass"; };
};

enum alpha_blend_e {
    DISABLED   = 3'd0 { desc = "Overwrite destination"; };
    ADD        = 3'd1 { desc = "Additive: src + dst, saturate"; };
    SUBTRACT   = 3'd2 { desc = "Subtractive: src - dst, saturate"; };
    BLEND      = 3'd3 { desc = "Alpha blend: src*a + dst*(1-a)"; };
};

enum cull_mode_e {
    CULL_NONE  = 2'd0 { desc = "No culling (draw all triangles)"; };
    CULL_CW    = 2'd1 { desc = "Cull clockwise-wound triangles"; };
    CULL_CCW   = 2'd2 { desc = "Cull counter-clockwise triangles"; };
};

enum tex_format_e {
    BC1        = 3'd0 { desc = "4 bpp, 64 bits per 4x4 block, opaque or 1-bit alpha"; };
    BC2        = 3'd1 { desc = "8 bpp, 128 bits per 4x4 block, explicit alpha"; };
    BC3        = 3'd2 { desc = "8 bpp, 128 bits per 4x4 block, interpolated alpha"; };
    BC4        = 3'd3 { desc = "4 bpp, 64 bits per 4x4 block, single channel"; };
    RGB565     = 3'd4 { desc = "16 bpp, 5-6-5 uncompressed, 4x4 tiled"; };
    RGBA8888   = 3'd5 { desc = "32 bpp, 8-8-8-8 uncompressed, 4x4 tiled"; };
    R8         = 3'd6 { desc = "8 bpp, single channel, 4x4 tiled"; };
};

enum tex_filter_e {
    NEAREST    = 2'd0 { desc = "No interpolation"; };
    BILINEAR   = 2'd1 { desc = "2x2 tap filter"; };
    TRILINEAR  = 2'd2 { desc = "Mipmap blend, requires MIP_LEVELS>1"; };
};

enum wrap_mode_e {
    REPEAT         = 2'd0 { desc = "Wrap around"; };
    CLAMP_TO_EDGE  = 2'd1 { desc = "Clamp to [0, size-1]"; };
    MIRROR         = 2'd2 { desc = "Reflect at boundaries"; };
    OCTAHEDRAL     = 2'd3 { desc = "Coupled diagonal mirror for octahedral mapping"; };
};

enum dither_pattern_e {
    BLUE_NOISE_16X16 = 2'd0 { desc = "Blue noise 16x16 (default)"; };
};

enum alpha_test_e {
    AT_ALWAYS   = 2'd0 { desc = "Always pass (alpha test disabled)"; };
    AT_LESS     = 2'd1 { desc = "Pass if fragment alpha < ALPHA_REF"; };
    AT_GEQUAL   = 2'd2 { desc = "Pass if fragment alpha >= ALPHA_REF (cutout transparency)"; };
    AT_NOTEQUAL = 2'd3 { desc = "Pass if fragment alpha != ALPHA_REF"; };
};

// Color combiner input sources (RGB A, B, D and all Alpha slots)
enum cc_source_e {
    CC_COMBINED    = 4'd0  { desc = "Previous combiner stage output"; };
    CC_TEX0        = 4'd1  { desc = "Texture unit 0 color/alpha"; };
    CC_TEX1        = 4'd2  { desc = "Texture unit 1 color/alpha"; };
    CC_SHADE0      = 4'd3  { desc = "Interpolated vertex color 0 (COLOR0, typically diffuse)"; };
    CC_CONST0      = 4'd4  { desc = "Constant color 0 (per-draw-call)"; };
    CC_CONST1      = 4'd5  { desc = "Constant color 1 (per-draw-call, also used for fog)"; };
    CC_ONE         = 4'd6  { desc = "Constant 1.0 (0xFF per channel)"; };
    CC_ZERO        = 4'd7  { desc = "Constant 0.0"; };
    CC_SHADE1      = 4'd8  { desc = "Interpolated vertex color 1 (COLOR1, typically specular)"; };
    CC_RSVD_9      = 4'd9  { desc = "Reserved (reads as 0)"; };
    CC_RSVD_10     = 4'd10 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_11     = 4'd11 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_12     = 4'd12 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_13     = 4'd13 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_14     = 4'd14 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_15     = 4'd15 { desc = "Reserved (reads as 0)"; };
};

// Extended sources for RGB C slot (blend/multiply factor)
enum cc_rgb_c_source_e {
    CC_C_COMBINED       = 4'd0  { desc = "Previous combiner stage RGB output"; };
    CC_C_TEX0           = 4'd1  { desc = "Texture 0 RGB"; };
    CC_C_TEX1           = 4'd2  { desc = "Texture 1 RGB"; };
    CC_C_SHADE0         = 4'd3  { desc = "Shade 0 RGB (COLOR0, typically diffuse)"; };
    CC_C_CONST0         = 4'd4  { desc = "Constant color 0 RGB"; };
    CC_C_CONST1         = 4'd5  { desc = "Constant color 1 RGB"; };
    CC_C_ONE            = 4'd6  { desc = "Constant 1.0"; };
    CC_C_ZERO           = 4'd7  { desc = "Constant 0.0"; };
    CC_C_TEX0_ALPHA     = 4'd8  { desc = "Texture 0 alpha broadcast to RGB"; };
    CC_C_TEX1_ALPHA     = 4'd9  { desc = "Texture 1 alpha broadcast to RGB"; };
    CC_C_SHADE0_ALPHA   = 4'd10 { desc = "Shade 0 alpha broadcast to RGB (COLOR0 alpha)"; };
    CC_C_CONST0_ALPHA   = 4'd11 { desc = "Constant color 0 alpha broadcast to RGB"; };
    CC_C_COMBINED_ALPHA = 4'd12 { desc = "Previous stage alpha broadcast to RGB"; };
    CC_C_SHADE1         = 4'd13 { desc = "Shade 1 RGB (COLOR1, typically specular)"; };
    CC_C_SHADE1_ALPHA   = 4'd14 { desc = "Shade 1 alpha broadcast to RGB (COLOR1 alpha)"; };
    CC_C_RSVD_15        = 4'd15 { desc = "Reserved (reads as 0)"; };
};

// ---------------------------------------------------------------------------
// Register definitions
// ---------------------------------------------------------------------------

addrmap gpu_regs #(longint unsigned ADDR_STRIDE = 8) {
    name = "GPU Register Map";
    desc = "ICEpi SPI GPU register map v11.0";

    default regwidth = 64;
    default hw = r;
    default sw = rw;

    // ===================================================================
    // Vertex State (index 0x00–0x0F)
    // ===================================================================

    reg color_reg {
        name = "COLOR";
        desc = "COLOR0[31:0] + COLOR1[63:32] vertex colors (RGBA8888 UNORM8 each)";
        field {} COLOR0_R[7:0]     = 0;
        field {} COLOR0_G[15:8]    = 0;
        field {} COLOR0_B[23:16]   = 0;
        field {} COLOR0_A[31:24]   = 0;
        field {} COLOR1_R[39:32]   = 0;
        field {} COLOR1_G[47:40]   = 0;
        field {} COLOR1_B[55:48]   = 0;
        field {} COLOR1_A[63:56]   = 0;
    };
    color_reg COLOR @ 0x000;  // index 0x00

    reg uv0_uv1_reg {
        name = "UV0_UV1";
        desc = "Texture units 0+1 UV coordinates (S3.12 signed fixed-point, range +/-8.0)";
        field {} UV0_UQ[15:0]  = 0;
        field {} UV0_VQ[31:16] = 0;
        field {} UV1_UQ[47:32] = 0;
        field {} UV1_VQ[63:48] = 0;
    };
    uv0_uv1_reg UV0_UV1 @ 0x008;  // index 0x01

    // index 0x02: Reserved (was UV2_UV3, removed in v10.0)

    // index 0x03: Reserved (was LIGHT_DIR, removed — use COLOR registers for light direction)

    // index 0x04-0x05: Reserved

    reg vertex_reg {
        name = "VERTEX";
        desc = "Vertex position + 1/W (write-only trigger).
               Origin (0,0) is the center of the top-left pixel,
               X+ right, Y+ down (S12.4). Integer coordinates
               address pixel centers directly. Coordinates extend
               beyond the framebuffer for guard-band clipping — the
               scissor rectangle (FB_CONTROL) defines the visible
               region; pixels outside are discarded per-fragment.
               KICK_RECT uses this vertex and the previous NOKICK
               vertex as opposite corners of an axis-aligned rectangle.";
        field {} X[15:0]  = 0;   // S12.4 signed fixed-point, range -2048.0 to +2047.9375
        field {} Y[31:16] = 0;   // S12.4 signed fixed-point, range -2048.0 to +2047.9375
        field {} Z[47:32] = 0;   // 16-bit unsigned depth
        field {} Q[63:48] = 0;   // 1/W, S3.12 signed fixed-point
    };
    vertex_reg VERTEX_NOKICK    @ 0x030;  // index 0x06
    vertex_reg VERTEX_KICK_012  @ 0x038;  // index 0x07
    vertex_reg VERTEX_KICK_021  @ 0x040;  // index 0x08
    vertex_reg VERTEX_KICK_RECT @ 0x048;  // index 0x09

    // index 0x0A-0x0F: Reserved

    // ===================================================================
    // Texture Samplers (index 0x10–0x11)
    // ===================================================================

    reg tex_cfg_reg {
        name = "TEXn_CFG";
        desc = "Texture sampler configuration (single 64-bit register per unit).
               All pixel data uses 4x4 block-tiled layout in SDRAM.
               BASE_ADDR is a 16-bit value multiplied by 512 to form the
               byte address (512-byte granularity, 32 MiB addressable).
               Octahedral wrap mode implements coupled diagonal mirroring:
               crossing one axis edge flips the other axis coordinate.
               Any write to this register invalidates the texture cache
               for the corresponding texture unit.";
        field {} ENABLE[0:0]                                = 0;
        field {} RSVD_1[1:1]                                = 0;
        field { encode = tex_filter_e; }  FILTER[3:2]       = 0;
        field { encode = tex_format_e; }  FORMAT[6:4]       = 0;
        field {} RSVD_7[7:7]                                = 0;
        field {} WIDTH_LOG2[11:8]                           = 0;
        field {} HEIGHT_LOG2[15:12]                         = 0;
        field { encode = wrap_mode_e; }   U_WRAP[17:16]     = 0;
        field { encode = wrap_mode_e; }   V_WRAP[19:18]     = 0;
        field {} MIP_LEVELS[23:20]                          = 0;
        field {} RSVD_MID[31:24]                            = 0;
        field {} BASE_ADDR[47:32]                           = 0;
        field {} RSVD_HI[63:48]                             = 0;
    };

    tex_cfg_reg TEX0_CFG @ 0x080;  // index 0x10
    tex_cfg_reg TEX1_CFG @ 0x088;  // index 0x11

    // index 0x12-0x17: Reserved (freed by texture register consolidation)

    // ===================================================================
    // Color Combiner (index 0x18–0x1F) 
    // ===================================================================

    reg cc_mode_reg {
        name = "CC_MODE";
        desc = "Color combiner mode: equation (A-B)*C+D, independent RGB and Alpha.
               The hardware always pipelines two combiner stages at one pixel
               per clock.  Cycle 0 output feeds cycle 1 via the COMBINED source.
               For single-equation behavior, configure cycle 1 as a pass-through:
               A=COMBINED, B=ZERO, C=ONE, D=ZERO.
               The RGB C slot uses an extended source set (cc_rgb_c_source_e)
               that includes alpha-to-RGB broadcast sources for blend factors.
               All other slots use cc_source_e.";

        // Cycle 0
        field { encode = cc_source_e; }       C0_RGB_A[3:0]     = 0;
        field { encode = cc_source_e; }       C0_RGB_B[7:4]     = 0;
        field { encode = cc_rgb_c_source_e; } C0_RGB_C[11:8]    = 0;
        field { encode = cc_source_e; }       C0_RGB_D[15:12]   = 0;
        field { encode = cc_source_e; }       C0_ALPHA_A[19:16] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_B[23:20] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_C[27:24] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_D[31:28] = 0;

        // Cycle 1
        field { encode = cc_source_e; }       C1_RGB_A[35:32]   = 0;
        field { encode = cc_source_e; }       C1_RGB_B[39:36]   = 0;
        field { encode = cc_rgb_c_source_e; } C1_RGB_C[43:40]   = 0;
        field { encode = cc_source_e; }       C1_RGB_D[47:44]   = 0;
        field { encode = cc_source_e; }       C1_ALPHA_A[51:48] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_B[55:52] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_C[59:56] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_D[63:60] = 0;
    };
    cc_mode_reg CC_MODE @ 0x0C0;  // index 0x18

    reg const_color_reg {
        name = "CONST_COLOR";
        desc = "Two per-draw-call constant colors packed into one 64-bit register (RGBA8888 UNORM8 each).
               CONST1 (bits [63:32]) doubles as the fog color.";
        field {} CONST0_R[7:0]    = 0;
        field {} CONST0_G[15:8]   = 0;
        field {} CONST0_B[23:16]  = 0;
        field {} CONST0_A[31:24]  = 0;
        field {} CONST1_R[39:32]  = 0;
        field {} CONST1_G[47:40]  = 0;
        field {} CONST1_B[55:48]  = 0;
        field {} CONST1_A[63:56]  = 0;
    };
    const_color_reg CONST_COLOR @ 0x0C8;  // index 0x19

    // index 0x1A: Reserved (was MAT_COLOR1, merged into CONST_COLOR)
    // index 0x1B: Reserved (was FOG_COLOR, removed — use CONST1 for fog)

    // index 0x1C-0x2F: Reserved

    // ===================================================================
    // Rendering Configuration (index 0x30–0x3F)
    // ===================================================================

    reg render_mode_reg {
        name = "RENDER_MODE";
        desc = "Unified rendering state (Gouraud, Z, alpha, culling, dithering, stipple)";
        field {} GOURAUD[0:0]                                  = 0;
        field {} RSVD_1[1:1]                                   = 0;
        field {} Z_TEST_EN[2:2]                                = 0;
        field {} Z_WRITE_EN[3:3]                               = 0;
        field {} COLOR_WRITE_EN[4:4]                           = 0;
        field { encode = cull_mode_e; }      CULL_MODE[6:5]    = 0;
        field { encode = alpha_blend_e; }    ALPHA_BLEND[9:7]  = 0;
        field {} DITHER_EN[10:10]                              = 0;
        field { encode = dither_pattern_e; } DITHER_PATTERN[12:11] = 0;
        field { encode = z_compare_e; }      Z_COMPARE[15:13]  = 0;
        field {} STIPPLE_EN[16:16]                             = 0;
        field { encode = alpha_test_e; }     ALPHA_TEST_FUNC[18:17] = 0;
        field {} ALPHA_REF[26:19]                              = 0;
        field {} RSVD_HI[63:27]                                = 0;
    };
    render_mode_reg RENDER_MODE @ 0x180;  // index 0x30

    reg z_range_reg {
        name = "Z_RANGE";
        desc = "Depth range clipping (Z scissor) min/max";
        field {} Z_RANGE_MIN[15:0]  = 0;
        field {} Z_RANGE_MAX[31:16] = 16'hFFFF;
        field {} RSVD[63:32]        = 0;
    };
    z_range_reg Z_RANGE @ 0x188;  // index 0x31

    reg stipple_pattern_reg {
        name = "STIPPLE_PATTERN";
        desc = "8x8 stipple bitmask (row-major, bit 0 = pixel (0,0)).
               Bit index = y[2:0] * 8 + x[2:0].  Fragment passes if the
               corresponding bit is 1; discarded if 0.  Only active when
               RENDER_MODE.STIPPLE_EN = 1.  Screen coordinates are masked
               to 3 bits (x & 7, y & 7) to index into the pattern.";
        field {} PATTERN[63:0] = 64'hFFFFFFFFFFFFFFFF;
    };
    stipple_pattern_reg STIPPLE_PATTERN @ 0x190;  // index 0x32

    // index 0x33-0x3F: Reserved

    // ===================================================================
    // Framebuffer & Z-Buffer (index 0x40–0x4F)
    // ===================================================================

    reg fb_config_reg {
        name = "FB_CONFIG";
        desc = "Render target configuration: color/Z-buffer base addresses and
               power-of-two surface dimensions.
               COLOR_BASE and Z_BASE are 16-bit values multiplied by 512
               to form the byte address (512-byte granularity, 32 MiB
               addressable), matching the texture BASE_ADDR encoding.
               WIDTH_LOG2 and HEIGHT_LOG2 define the surface dimensions in
               pixels as 1 << n; both the color buffer and Z-buffer use 4×4
               block-tiled layout at these dimensions.  A paired Z-buffer at
               Z_BASE always has the same dimensions as the color buffer.
               The host reprograms this register between render passes to
               switch between display framebuffer and off-screen render
               targets; the pixel writer uses WIDTH_LOG2 for tiled address
               calculation (shift-only, no multiply).";
        field {} COLOR_BASE[15:0]   = 0;
        field {} Z_BASE[31:16]      = 0;
        field {} WIDTH_LOG2[35:32]  = 0;   // surface width = 1 << WIDTH_LOG2 pixels
        field {} HEIGHT_LOG2[39:36] = 0;   // surface height = 1 << HEIGHT_LOG2 pixels
        field {} RSVD[63:40]        = 0;
    };
    fb_config_reg FB_CONFIG @ 0x200;  // index 0x40

    // index 0x42: Reserved (was FB_ZBUFFER, merged into FB_CONFIG)

    reg fb_display_reg {
        name = "FB_DISPLAY";
        desc = "Display scanout configuration (write-blocks-until-vsync).
               Writing this register blocks the GPU pipeline until the next
               vertical blanking interval, then atomically switches the
               display scanout address and latches all display mode fields.
               The DVI output is always 640×480 at 60 Hz.  The display
               controller reads from a 4×4 block-tiled framebuffer and
               stretches the source image to 640×480 using nearest-neighbor
               horizontal scaling (Bresenham accumulator, no multiply HW).
               FB_WIDTH_LOG2 specifies the tiled surface width for scanout
               address calculation — latched independently from FB_CONFIG
               so that render-to-texture passes can reprogram FB_CONFIG
               mid-frame without affecting display scanout.
               When LINE_DOUBLE is set, only 240 source rows are read and
               each is output twice to fill 480 display lines; the line
               buffer is reused without re-reading SDRAM.
               Horizontal interpolation operates on UNORM8 values post
               color-grade LUT, ensuring tone mapping precedes any pixel
               blending.
               If COLOR_GRADE_ENABLE is set, the color grading LUT is
               loaded from LUT_ADDR during the blanking interval before
               the new frame begins scanout.
               FB_ADDR and LUT_ADDR are 16-bit values multiplied by 512
               to form the byte address (512-byte granularity, 32 MiB
               addressable), matching the texture BASE_ADDR encoding.";
        field {} COLOR_GRADE_ENABLE[0:0] = 0;
        field {} LINE_DOUBLE[1:1]        = 0;   // 0 = 480 rows (1:1), 1 = 240 rows (each doubled)
        field {} RSVD_LO[15:2]           = 0;
        field {} LUT_ADDR[31:16]         = 0;
        field {} FB_ADDR[47:32]          = 0;
        field {} FB_WIDTH_LOG2[51:48]    = 0;   // display FB width = 1 << n (e.g. 9 = 512)
        field {} RSVD_HI[63:52]          = 0;
    };
    fb_display_reg FB_DISPLAY @ 0x208;  // index 0x41

    reg fb_control_reg {
        name = "FB_CONTROL";
        desc = "Scissor rectangle";
        field {} SCISSOR_X[9:0]              = 0;
        field {} SCISSOR_Y[19:10]            = 0;
        field {} SCISSOR_WIDTH[29:20]        = 10'd1023;
        field {} SCISSOR_HEIGHT[39:30]       = 10'd1023;
        field {} RSVD_HI[63:40]              = 0;
    };
    fb_control_reg FB_CONTROL @ 0x218;  // index 0x43

    reg mem_fill_reg {
        name = "MEM_FILL";
        desc = "Hardware memory fill (write-triggers-fill).
               Writes a 16-bit constant value to a contiguous region of SDRAM.
               FILL_BASE uses the same 512-byte-granularity encoding as
               COLOR_BASE, Z_BASE, and texture BASE_ADDR.
               The fill unit generates sequential SDRAM burst writes for
               maximum throughput.  Blocks the GPU pipeline until complete;
               the SPI command FIFO continues accepting commands.";
        field {} FILL_BASE[15:0]    = 0;   // target address >> 9
        field {} FILL_VALUE[31:16]  = 0;   // 16-bit constant (RGB565 or Z16)
        field {} FILL_COUNT[51:32]  = 0;   // count in 16-bit words (up to 1,048,576)
        field {} RSVD[63:52]        = 0;
    };
    mem_fill_reg MEM_FILL @ 0x220;  // index 0x44

    // index 0x45-0x4F: Reserved

    // ===================================================================
    // Performance Timestamp (index 0x50)
    // ===================================================================

    reg perf_timestamp_reg {
        name = "PERF_TIMESTAMP";
        desc = "Command-stream timestamp marker.
               Write: DATA[22:0] = 23-bit SDRAM word address (32-bit word
               granularity, 32 MiB addressable).  When this command reaches
               the front of the command FIFO, the GPU captures the current
               frame-relative cycle counter (32-bit unsigned saturating,
               clk_core, resets to 0 on vsync rising edge) and writes it
               as a 32-bit word to the specified SDRAM address via the
               memory arbiter.
               Read: returns the live (instantaneous) cycle counter in
               bits [31:0], zero-extended to 64 bits.  Not FIFO-ordered.";
        field {} SDRAM_ADDR[22:0]  = 0;
        field {} RSVD[63:23]       = 0;
    };
    perf_timestamp_reg PERF_TIMESTAMP @ 0x280;  // index 0x50

    // index 0x51-0x6F: Reserved

    // ===================================================================
    // Status & Control (index 0x70–0x7F)
    // ===================================================================

    reg mem_addr_reg {
        name = "MEM_ADDR";
        desc = "Memory access dword address pointer (22-bit, addresses 8-byte dwords
               in 32 MiB SDRAM).  Writing this register sets the SDRAM target
               address and triggers a read prefetch so that the next SPI read of
               MEM_DATA can return data immediately.";
        field {} ADDR[21:0]   = 0;
        field {} RSVD[63:22]  = 0;
    };
    mem_addr_reg MEM_ADDR @ 0x380;  // index 0x70

    reg mem_data_reg {
        name = "MEM_DATA";
        desc = "Memory data register (bidirectional 64-bit, auto-increments MEM_ADDR by 1).
               Write: stores DATA[63:0] to SDRAM at MEM_ADDR, then increments.
               Read: returns prefetched 64-bit SDRAM dword and triggers next prefetch.";
        field {} DATA[63:0]   = 0;
    };
    mem_data_reg MEM_DATA @ 0x388;  // index 0x71

    // index 0x72-0x7D: Reserved

    // index 0x7E: Reserved (STATUS removed — host uses CMD_FULL/VSYNC GPIOs)

    reg id_reg {
        name = "ID";
        desc = "GPU identification (read-only)";
        default sw = r;
        field {} DEVICE_ID[15:0]  = 16'h6702;
        field {} VERSION[31:16]   = 16'h0A00;
        field {} RSVD[63:32]      = 0;
    };
    id_reg ID @ 0x3F8;  // index 0x7F
};
