// GPU Register Map — SystemRDL source of truth
//
// This file defines the canonical register addresses, bit fields, enumerations,
// and reset values for the ICEpi SPI GPU.  PeakRDL generates Rust and
// SystemVerilog outputs from this file.
//
// Address space: 7-bit register index (0x00–0x7F), 64-bit data width.
// Transaction format: 72 bits — [R/W̄(1)][addr(7)][data(64)].
//
// NOTE: SystemRDL uses byte addresses, so register index N maps to byte
// address N*8.  The GPU SPI interface uses the 7-bit register index directly.

// ---------------------------------------------------------------------------
// Enumerations
// ---------------------------------------------------------------------------

enum z_compare_e {
    LESS       = 3'd0 { desc = "Less than (<)"; };
    LEQUAL     = 3'd1 { desc = "Less than or equal (<=)"; };
    EQUAL      = 3'd2 { desc = "Equal (=)"; };
    GEQUAL     = 3'd3 { desc = "Greater than or equal (>=)"; };
    GREATER    = 3'd4 { desc = "Greater than (>)"; };
    NOTEQUAL   = 3'd5 { desc = "Not equal (!=)"; };
    ALWAYS     = 3'd6 { desc = "Always pass"; };
    NEVER      = 3'd7 { desc = "Never pass"; };
};

enum alpha_blend_e {
    DISABLED   = 3'd0 { desc = "Overwrite destination"; };
    ADD        = 3'd1 { desc = "Additive: src + dst, saturate"; };
    SUBTRACT   = 3'd2 { desc = "Subtractive: src - dst, saturate"; };
    BLEND      = 3'd3 { desc = "Alpha blend: src*a + dst*(1-a)"; };
};

enum cull_mode_e {
    CULL_NONE  = 2'd0 { desc = "No culling (draw all triangles)"; };
    CULL_CW    = 2'd1 { desc = "Cull clockwise-wound triangles"; };
    CULL_CCW   = 2'd2 { desc = "Cull counter-clockwise triangles"; };
};

enum tex_format_e {
    BC1        = 3'd0 { desc = "4 bpp, 64 bits per 4x4 block, opaque or 1-bit alpha"; };
    BC2        = 3'd1 { desc = "8 bpp, 128 bits per 4x4 block, explicit alpha"; };
    BC3        = 3'd2 { desc = "8 bpp, 128 bits per 4x4 block, interpolated alpha"; };
    BC4        = 3'd3 { desc = "4 bpp, 64 bits per 4x4 block, single channel"; };
    RGB565     = 3'd4 { desc = "16 bpp, 5-6-5 uncompressed, 4x4 tiled"; };
    RGBA8888   = 3'd5 { desc = "32 bpp, 8-8-8-8 uncompressed, 4x4 tiled"; };
    R8         = 3'd6 { desc = "8 bpp, single channel, 4x4 tiled"; };
};

enum tex_filter_e {
    NEAREST    = 2'd0 { desc = "No interpolation"; };
    BILINEAR   = 2'd1 { desc = "2x2 tap filter"; };
    TRILINEAR  = 2'd2 { desc = "Mipmap blend, requires MIP_LEVELS>1"; };
};

enum wrap_mode_e {
    REPEAT         = 2'd0 { desc = "Wrap around"; };
    CLAMP_TO_EDGE  = 2'd1 { desc = "Clamp to [0, size-1]"; };
    MIRROR         = 2'd2 { desc = "Reflect at boundaries"; };
    OCTAHEDRAL     = 2'd3 { desc = "Coupled diagonal mirror for octahedral mapping"; };
};

enum dither_pattern_e {
    BLUE_NOISE_16X16 = 2'd0 { desc = "Blue noise 16x16 (default)"; };
};

// Color combiner input sources (RGB A, B, D and all Alpha slots)
enum cc_source_e {
    CC_COMBINED    = 4'd0  { desc = "Previous combiner stage output"; };
    CC_TEX0        = 4'd1  { desc = "Texture unit 0 color/alpha"; };
    CC_TEX1        = 4'd2  { desc = "Texture unit 1 color/alpha"; };
    CC_SHADE       = 4'd3  { desc = "Interpolated vertex color/alpha (Gouraud)"; };
    CC_CONST0      = 4'd4  { desc = "Constant color 0 (per-draw-call)"; };
    CC_CONST1      = 4'd5  { desc = "Constant color 1 (per-draw-call, also used for fog)"; };
    CC_ONE         = 4'd6  { desc = "Constant 1.0 (0xFF per channel)"; };
    CC_ZERO        = 4'd7  { desc = "Constant 0.0"; };
    CC_RSVD_8      = 4'd8  { desc = "Reserved (reads as 0)"; };
    CC_RSVD_9      = 4'd9  { desc = "Reserved (reads as 0)"; };
    CC_RSVD_10     = 4'd10 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_11     = 4'd11 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_12     = 4'd12 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_13     = 4'd13 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_14     = 4'd14 { desc = "Reserved (reads as 0)"; };
    CC_RSVD_15     = 4'd15 { desc = "Reserved (reads as 0)"; };
};

// Extended sources for RGB C slot (blend/multiply factor)
enum cc_rgb_c_source_e {
    CC_C_COMBINED       = 4'd0  { desc = "Previous combiner stage RGB output"; };
    CC_C_TEX0           = 4'd1  { desc = "Texture 0 RGB"; };
    CC_C_TEX1           = 4'd2  { desc = "Texture 1 RGB"; };
    CC_C_SHADE          = 4'd3  { desc = "Shade RGB"; };
    CC_C_CONST0         = 4'd4  { desc = "Constant color 0 RGB"; };
    CC_C_CONST1         = 4'd5  { desc = "Constant color 1 RGB"; };
    CC_C_ONE            = 4'd6  { desc = "Constant 1.0"; };
    CC_C_ZERO           = 4'd7  { desc = "Constant 0.0"; };
    CC_C_TEX0_ALPHA     = 4'd8  { desc = "Texture 0 alpha broadcast to RGB"; };
    CC_C_TEX1_ALPHA     = 4'd9  { desc = "Texture 1 alpha broadcast to RGB"; };
    CC_C_SHADE_ALPHA    = 4'd10 { desc = "Shade alpha broadcast to RGB"; };
    CC_C_CONST0_ALPHA   = 4'd11 { desc = "Constant color 0 alpha broadcast to RGB"; };
    CC_C_COMBINED_ALPHA = 4'd12 { desc = "Previous stage alpha broadcast to RGB"; };
    CC_C_RSVD_13        = 4'd13 { desc = "Reserved (reads as 0)"; };
    CC_C_RSVD_14        = 4'd14 { desc = "Reserved (reads as 0)"; };
    CC_C_RSVD_15        = 4'd15 { desc = "Reserved (reads as 0)"; };
};

// ---------------------------------------------------------------------------
// Register definitions
// ---------------------------------------------------------------------------

addrmap gpu_regs #(longint unsigned ADDR_STRIDE = 8) {
    name = "GPU Register Map";
    desc = "ICEpi SPI GPU register map v11.0";

    default regwidth = 64;
    default hw = r;
    default sw = rw;

    // ===================================================================
    // Vertex State (index 0x00–0x0F)
    // ===================================================================

    reg color_reg {
        name = "COLOR";
        desc = "COLOR0[31:0] + COLOR1[63:32] vertex colors (RGBA8888 UNORM8 each)";
        field {} COLOR0_R[7:0]     = 0;
        field {} COLOR0_G[15:8]    = 0;
        field {} COLOR0_B[23:16]   = 0;
        field {} COLOR0_A[31:24]   = 0;
        field {} COLOR1_R[39:32]   = 0;
        field {} COLOR1_G[47:40]   = 0;
        field {} COLOR1_B[55:48]   = 0;
        field {} COLOR1_A[63:56]   = 0;
    };
    color_reg COLOR @ 0x000;  // index 0x00

    reg uv0_uv1_reg {
        name = "UV0_UV1";
        desc = "Texture units 0+1 UV coordinates (S3.12 signed fixed-point, range +/-8.0)";
        field {} UV0_UQ[15:0]  = 0;
        field {} UV0_VQ[31:16] = 0;
        field {} UV1_UQ[47:32] = 0;
        field {} UV1_VQ[63:48] = 0;
    };
    uv0_uv1_reg UV0_UV1 @ 0x008;  // index 0x01

    // index 0x02: Reserved (was UV2_UV3, removed in v10.0)

    // index 0x03: Reserved (was LIGHT_DIR, removed — use COLOR registers for light direction)

    // index 0x04-0x05: Reserved

    reg vertex_reg {
        name = "VERTEX";
        desc = "Vertex position + 1/W (write-only trigger).
               Origin (0,0) is the center of the top-left pixel,
               X+ right, Y+ down (S12.4). Integer coordinates
               address pixel centers directly. Coordinates extend
               beyond the framebuffer for guard-band clipping — the
               scissor rectangle (FB_CONTROL) defines the visible
               region; pixels outside are discarded per-fragment.
               KICK_RECT uses this vertex and the previous NOKICK
               vertex as opposite corners of an axis-aligned rectangle.";
        field {} X[15:0]  = 0;   // S12.4 signed fixed-point, range -2048.0 to +2047.9375
        field {} Y[31:16] = 0;   // S12.4 signed fixed-point, range -2048.0 to +2047.9375
        field {} Z[47:32] = 0;   // 16-bit unsigned depth
        field {} Q[63:48] = 0;   // 1/W, S3.12 signed fixed-point
    };
    vertex_reg VERTEX_NOKICK    @ 0x030;  // index 0x06
    vertex_reg VERTEX_KICK_012  @ 0x038;  // index 0x07
    vertex_reg VERTEX_KICK_021  @ 0x040;  // index 0x08
    vertex_reg VERTEX_KICK_RECT @ 0x048;  // index 0x09

    // index 0x0A-0x0F: Reserved

    // ===================================================================
    // Texture Samplers (index 0x10–0x11)
    // ===================================================================

    reg tex_cfg_reg {
        name = "TEXn_CFG";
        desc = "Texture sampler configuration (single 64-bit register per unit).
               All pixel data uses 4x4 block-tiled layout in SDRAM.
               BASE_ADDR is a 16-bit value multiplied by 512 to form the
               byte address (512-byte granularity, 32 MiB addressable).
               Octahedral wrap mode implements coupled diagonal mirroring:
               crossing one axis edge flips the other axis coordinate.
               Any write to this register invalidates the texture cache
               for the corresponding texture unit.";
        field {} ENABLE[0:0]                                = 0;
        field {} RSVD_1[1:1]                                = 0;
        field { encode = tex_filter_e; }  FILTER[3:2]       = 0;
        field { encode = tex_format_e; }  FORMAT[6:4]       = 0;
        field {} RSVD_7[7:7]                                = 0;
        field {} WIDTH_LOG2[11:8]                           = 0;
        field {} HEIGHT_LOG2[15:12]                         = 0;
        field { encode = wrap_mode_e; }   U_WRAP[17:16]     = 0;
        field { encode = wrap_mode_e; }   V_WRAP[19:18]     = 0;
        field {} MIP_LEVELS[23:20]                          = 0;
        field {} RSVD_MID[31:24]                            = 0;
        field {} BASE_ADDR[47:32]                           = 0;
        field {} RSVD_HI[63:48]                             = 0;
    };

    tex_cfg_reg TEX0_CFG @ 0x080;  // index 0x10
    tex_cfg_reg TEX1_CFG @ 0x088;  // index 0x11

    // index 0x12-0x17: Reserved (freed by texture register consolidation)

    // ===================================================================
    // Color Combiner (index 0x18–0x1F) 
    // ===================================================================

    reg cc_mode_reg {
        name = "CC_MODE";
        desc = "Color combiner mode: equation (A-B)*C+D, independent RGB and Alpha.
               The hardware always pipelines two combiner stages at one pixel
               per clock.  Cycle 0 output feeds cycle 1 via the COMBINED source.
               For single-equation behavior, configure cycle 1 as a pass-through:
               A=COMBINED, B=ZERO, C=ONE, D=ZERO.
               The RGB C slot uses an extended source set (cc_rgb_c_source_e)
               that includes alpha-to-RGB broadcast sources for blend factors.
               All other slots use cc_source_e.";

        // Cycle 0
        field { encode = cc_source_e; }       C0_RGB_A[3:0]     = 0;
        field { encode = cc_source_e; }       C0_RGB_B[7:4]     = 0;
        field { encode = cc_rgb_c_source_e; } C0_RGB_C[11:8]    = 0;
        field { encode = cc_source_e; }       C0_RGB_D[15:12]   = 0;
        field { encode = cc_source_e; }       C0_ALPHA_A[19:16] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_B[23:20] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_C[27:24] = 0;
        field { encode = cc_source_e; }       C0_ALPHA_D[31:28] = 0;

        // Cycle 1
        field { encode = cc_source_e; }       C1_RGB_A[35:32]   = 0;
        field { encode = cc_source_e; }       C1_RGB_B[39:36]   = 0;
        field { encode = cc_rgb_c_source_e; } C1_RGB_C[43:40]   = 0;
        field { encode = cc_source_e; }       C1_RGB_D[47:44]   = 0;
        field { encode = cc_source_e; }       C1_ALPHA_A[51:48] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_B[55:52] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_C[59:56] = 0;
        field { encode = cc_source_e; }       C1_ALPHA_D[63:60] = 0;
    };
    cc_mode_reg CC_MODE @ 0x0C0;  // index 0x18

    reg const_color_reg {
        name = "CONST_COLOR";
        desc = "Two per-draw-call constant colors packed into one 64-bit register (RGBA8888 UNORM8 each).
               CONST1 (bits [63:32]) doubles as the fog color.";
        field {} CONST0_R[7:0]    = 0;
        field {} CONST0_G[15:8]   = 0;
        field {} CONST0_B[23:16]  = 0;
        field {} CONST0_A[31:24]  = 0;
        field {} CONST1_R[39:32]  = 0;
        field {} CONST1_G[47:40]  = 0;
        field {} CONST1_B[55:48]  = 0;
        field {} CONST1_A[63:56]  = 0;
    };
    const_color_reg CONST_COLOR @ 0x0C8;  // index 0x19

    // index 0x1A: Reserved (was MAT_COLOR1, merged into CONST_COLOR)
    // index 0x1B: Reserved (was FOG_COLOR, removed — use CONST1 for fog)

    // index 0x1C-0x2F: Reserved

    // ===================================================================
    // Rendering Configuration (index 0x30–0x3F)
    // ===================================================================

    reg render_mode_reg {
        name = "RENDER_MODE";
        desc = "Unified rendering state (Gouraud, Z, alpha, culling, dithering)";
        field {} GOURAUD[0:0]                                = 0;
        field {} RSVD_1[1:1]                                 = 0;
        field {} Z_TEST_EN[2:2]                              = 0;
        field {} Z_WRITE_EN[3:3]                             = 0;
        field {} COLOR_WRITE_EN[4:4]                         = 0;
        field { encode = cull_mode_e; }    CULL_MODE[6:5]    = 0;
        field { encode = alpha_blend_e; }  ALPHA_BLEND[9:7]  = 0;
        field {} DITHER_EN[10:10]                            = 0;
        field { encode = dither_pattern_e; } DITHER_PATTERN[12:11] = 0;
        field { encode = z_compare_e; }    Z_COMPARE[15:13]  = 0;
        field {} RSVD_HI[63:16]                              = 0;
    };
    render_mode_reg RENDER_MODE @ 0x180;  // index 0x30

    reg z_range_reg {
        name = "Z_RANGE";
        desc = "Depth range clipping (Z scissor) min/max";
        field {} Z_RANGE_MIN[15:0]  = 0;
        field {} Z_RANGE_MAX[31:16] = 16'hFFFF;
        field {} RSVD[63:32]        = 0;
    };
    z_range_reg Z_RANGE @ 0x188;  // index 0x31

    // index 0x32-0x3F: Reserved

    // ===================================================================
    // Framebuffer & Z-Buffer (index 0x40–0x4F)
    // ===================================================================

    reg fb_config_reg {
        name = "FB_CONFIG";
        desc = "Draw framebuffer and Z-buffer base addresses.
               COLOR_BASE and Z_BASE are 16-bit values multiplied by 512
               to form the byte address (512-byte granularity, 32 MiB
               addressable), matching the texture BASE_ADDR encoding.";
        field {} COLOR_BASE[15:0]   = 0;
        field {} Z_BASE[31:16]      = 0;
        field {} RSVD[63:32]        = 0;
    };
    fb_config_reg FB_CONFIG @ 0x200;  // index 0x40

    // index 0x42: Reserved (was FB_ZBUFFER, merged into FB_CONFIG)

    reg fb_display_reg {
        name = "FB_DISPLAY";
        desc = "Display scanout framebuffer + LUT control (write-blocks-until-vsync).
               Writing this register blocks the GPU pipeline until the next
               vertical blanking interval, then atomically switches the display
               scanout address.  If COLOR_GRADE_ENABLE is set, the color
               grading LUT is loaded from LUT_ADDR during the blanking
               interval before the new frame begins scanout.
               FB_ADDR and LUT_ADDR are 16-bit values multiplied by 512
               to form the byte address (512-byte granularity, 32 MiB
               addressable), matching the texture BASE_ADDR encoding.";
        field {} COLOR_GRADE_ENABLE[0:0] = 0;
        field {} RSVD_LO[15:1]           = 0;
        field {} LUT_ADDR[31:16]         = 0;
        field {} FB_ADDR[47:32]          = 0;
        field {} RSVD_HI[63:48]          = 0;
    };
    fb_display_reg FB_DISPLAY @ 0x208;  // index 0x41

    reg fb_control_reg {
        name = "FB_CONTROL";
        desc = "Scissor rectangle + write enable masks";
        field {} SCISSOR_X[9:0]              = 0;
        field {} SCISSOR_Y[19:10]            = 0;
        field {} SCISSOR_WIDTH[29:20]        = 10'd1023;
        field {} SCISSOR_HEIGHT[39:30]       = 10'd1023;
        field {} Z_WRITE_EN_OVERRIDE[40:40]  = 0;
        field {} RSVD_41[41:41]              = 0;
        field {} STENCIL_WRITE_EN[42:42]     = 0;
        field {} RSVD_HI[63:43]              = 0;
    };
    fb_control_reg FB_CONTROL @ 0x218;  // index 0x43

    reg mem_fill_reg {
        name = "MEM_FILL";
        desc = "Hardware memory fill (write-triggers-fill).
               Writes a 16-bit constant value to a contiguous region of SDRAM.
               FILL_BASE uses the same 512-byte-granularity encoding as
               COLOR_BASE, Z_BASE, and texture BASE_ADDR.
               The fill unit generates sequential SDRAM burst writes for
               maximum throughput.  Blocks the GPU pipeline until complete;
               the SPI command FIFO continues accepting commands.";
        field {} FILL_BASE[15:0]    = 0;   // target address >> 9
        field {} FILL_VALUE[31:16]  = 0;   // 16-bit constant (RGB565 or Z16)
        field {} FILL_COUNT[51:32]  = 0;   // count in 16-bit words (up to 1,048,576)
        field {} RSVD[63:52]        = 0;
    };
    mem_fill_reg MEM_FILL @ 0x220;  // index 0x44

    // index 0x45-0x4F: Reserved

    // ===================================================================
    // Performance Counters (index 0x50–0x57) — clear-on-read
    // ===================================================================

    reg perf_pair_reg {
        name = "PERF counter pair";
        desc = "Packed 2x32-bit unsigned saturating counters, clear-on-read";
        default sw = r;
        field {} COUNTER_A[31:0]  = 0;
        field {} COUNTER_B[63:32] = 0;
    };

    perf_pair_reg PERF_TEX0       @ 0x280;  // index 0x50
    perf_pair_reg PERF_TEX1       @ 0x288;  // index 0x51
    // index 0x52-0x53: Reserved (was PERF_TEX2, PERF_TEX3)
    perf_pair_reg PERF_PIXELS     @ 0x2A0;  // index 0x54
    perf_pair_reg PERF_FRAGMENTS  @ 0x2A8;  // index 0x55
    perf_pair_reg PERF_STALL_VS   @ 0x2B0;  // index 0x56
    perf_pair_reg PERF_STALL_CT   @ 0x2B8;  // index 0x57

    // index 0x58-0x6F: Reserved

    // ===================================================================
    // Status & Control (index 0x70–0x7F)
    // ===================================================================

    reg mem_addr_reg {
        name = "MEM_ADDR";
        desc = "Memory upload address pointer";
        field {} ADDR[31:0]   = 0;
        field {} RSVD[63:32]  = 0;
    };
    mem_addr_reg MEM_ADDR @ 0x380;  // index 0x70

    reg mem_data_reg {
        name = "MEM_DATA";
        desc = "Memory upload data (auto-increments MEM_ADDR by 4)";
        field {} DATA[31:0]   = 0;
        field {} RSVD[63:32]  = 0;
    };
    mem_data_reg MEM_DATA @ 0x388;  // index 0x71

    // index 0x72-0x7D: Reserved

    reg status_reg {
        name = "STATUS";
        desc = "GPU status (read-only)";
        default sw = r;
        field {} FIFO_DEPTH[7:0] = 0;
        field {} BUSY[8:8]       = 0;
        field {} VBLANK[9:9]     = 0;
        field {} RSVD[63:10]     = 0;
    };
    status_reg STATUS @ 0x3F0;  // index 0x7E

    reg id_reg {
        name = "ID";
        desc = "GPU identification (read-only)";
        default sw = r;
        field {} DEVICE_ID[15:0]  = 16'h6702;
        field {} VERSION[31:16]   = 16'h0A00;
        field {} RSVD[63:32]      = 0;
    };
    id_reg ID @ 0x3F8;  // index 0x7F
};
